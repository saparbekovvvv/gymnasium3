(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_next_dist_compiled_react-dom_cjs_react-dom_development_c9a189.js", {

"[project]/node_modules/next/dist/compiled/react-dom/cjs/react-dom.development.js [app-client] (ecmascript)": (function({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports, t: require }) { !function() {

/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
'use strict';
if ("TURBOPACK compile-time truthy", 1) {
    (function() {
        'use strict';
        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
        var Scheduler = (()=>{
            const e = new Error("Cannot find module 'next/dist/compiled/scheduler'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
        var Internals = {
            usingClientEntryPoint: false,
            Events: null,
            Dispatcher: {
                current: null
            }
        };
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        var suppressWarning = false;
        function setSuppressWarning(newSuppressWarning) {
            {
                suppressWarning = newSuppressWarning;
            }
        } // In DEV, calls to console.warn and console.error get replaced
        // by calls to these methods by a Babel plugin.
        //
        // In PROD (or in packages without access to React internals),
        // they are left as they are instead.
        function warn(format) {
            {
                if (!suppressWarning) {
                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        args[_key - 1] = arguments[_key];
                    }
                    printWarning('warn', format, args);
                }
            }
        }
        function error(format) {
            {
                if (!suppressWarning) {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    printWarning('error', format, args);
                }
            }
        }
        function printWarning(level, format, args) {
            // When changing this logic, you might want to also
            // update consoleWithStackDev.www.js as well.
            {
                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
                var stack = ReactDebugCurrentFrame.getStackAddendum();
                if (stack !== '') {
                    format += '%s';
                    args = args.concat([
                        stack
                    ]);
                } // eslint-disable-next-line react-internal/safe-string-coercion
                var argsWithFormat = args.map(function(item) {
                    return String(item);
                }); // Careful: RN currently depends on this prefix
                argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
                // breaks IE9: https://github.com/facebook/react/issues/13610
                // eslint-disable-next-line react-internal/no-production-logging
                Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
        }
        var assign = Object.assign;
        // -----------------------------------------------------------------------------
        // Killswitch
        //
        // Flags that exist solely to turn off a change in case it causes a regression
        // when it rolls out to prod. We should remove these as soon as possible.
        // -----------------------------------------------------------------------------
        // -----------------------------------------------------------------------------
        // Land or remove (moderate effort)
        //
        // Flags that can be probably deleted or landed, but might require extra effort
        // like migrating internal callers or performance testing.
        // -----------------------------------------------------------------------------
        // TODO: Finish rolling out in www
        var enableClientRenderFallbackOnTextMismatch = true;
        var enableFormActions = true;
        var enableAsyncActions = true; // Need to remove didTimeout argument from Scheduler before landing
        // Slated for removal in the future (significant effort)
        //
        // These are experiments that didn't work out, and never shipped, but we can't
        // delete from the codebase until we migrate internal callers.
        // -----------------------------------------------------------------------------
        // Add a callback property to suspense to notify which promises are currently
        // in the update queue. This allows reporting and tracing of what is causing
        // the user to see a loading state.
        //
        // Also allows hydration callbacks to fire when a dehydrated boundary gets
        // hydrated or deleted.
        //
        // This will eventually be replaced by the Transition Tracing proposal.
        var enableSuspenseCallback = false; // Experimental Scope support.
        var enableLazyContextPropagation = false; // FB-only usage. The new API has different semantics.
        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
        var alwaysThrottleRetries = true;
        var syncLaneExpirationMs = 250;
        var transitionLaneExpirationMs = 5000; // -----------------------------------------------------------------------------
        // React DOM Chopping Block
        //
        // Similar to main Chopping Block but only flags related to React DOM. These are
        // grouped because we will likely batch all of them into a single major release.
        // -----------------------------------------------------------------------------
        // Disable support for comment nodes as React DOM containers. Already disabled
        // in open source, but www codebase still relies on it. Need to remove.
        var disableCommentsAsDOMContainers = true;
        // Debugging and DevTools
        // -----------------------------------------------------------------------------
        // Adds user timing marks for e.g. state updates, suspense, and work loop stuff,
        // for an experimental timeline tool.
        var enableSchedulingProfiler = true; // Helps identify side effects in render-phase lifecycle hooks and setState
        var enableProfilerTimer = true; // Record durations for commit and passive effects phases.
        var enableProfilerCommitHooks = true; // Phase param passed to onRender callback differentiates between an "update" and a "cascading-update".
        var enableProfilerNestedUpdatePhase = true; // Adds verbose console logging for e.g. state updates, suspense, and work loop
        var ReactCurrentDispatcher$3 = ReactSharedInternals.ReactCurrentDispatcher; // Since the "not pending" value is always the same, we can reuse the
        // same object across all transitions.
        var sharedNotPendingObject = {
            pending: false,
            data: null,
            method: null,
            action: null
        };
        var NotPending = Object.freeze(sharedNotPendingObject);
        function resolveDispatcher() {
            // Copied from react/src/ReactHooks.js. It's the same thing but in a
            // different package.
            var dispatcher = ReactCurrentDispatcher$3.current;
            {
                if (dispatcher === null) {
                    error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' + '2. You might be breaking the Rules of Hooks\n' + '3. You might have more than one copy of React in the same app\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');
                }
            }
            // intentionally don't throw our own error because this is in a hot path.
            // Also helps ensure this is inlined.
            return dispatcher;
        }
        function useFormStatus() {
            {
                var dispatcher = resolveDispatcher(); // $FlowFixMe[not-a-function] We know this exists because of the feature check above.
                return dispatcher.useHostTransitionStatus();
            }
        }
        function useFormState(action, initialState, permalink) {
            {
                var dispatcher = resolveDispatcher(); // $FlowFixMe[not-a-function] This is unstable, thus optional
                return dispatcher.useFormState(action, initialState, permalink);
            }
        }
        var valueStack = [];
        var fiberStack;
        {
            fiberStack = [];
        }
        var index = -1;
        function createCursor(defaultValue) {
            return {
                current: defaultValue
            };
        }
        function pop(cursor, fiber) {
            if (index < 0) {
                {
                    error('Unexpected pop.');
                }
                return;
            }
            {
                if (fiber !== fiberStack[index]) {
                    error('Unexpected Fiber popped.');
                }
            }
            cursor.current = valueStack[index];
            valueStack[index] = null;
            {
                fiberStack[index] = null;
            }
            index--;
        }
        function push(cursor, value, fiber) {
            index++;
            valueStack[index] = cursor.current;
            {
                fiberStack[index] = fiber;
            }
            cursor.current = value;
        }
        // ATTENTION
        // When adding new symbols to this file,
        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
        // The Symbol used to tag the ReactElement-like types.
        var REACT_ELEMENT_TYPE = Symbol.for('react.element');
        var REACT_PORTAL_TYPE = Symbol.for('react.portal');
        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
        var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
        var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
        var REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext
        var REACT_CONSUMER_TYPE = Symbol.for('react.consumer');
        var REACT_CONTEXT_TYPE = Symbol.for('react.context');
        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
        var REACT_MEMO_TYPE = Symbol.for('react.memo');
        var REACT_LAZY_TYPE = Symbol.for('react.lazy');
        var REACT_SCOPE_TYPE = Symbol.for('react.scope');
        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode');
        var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');
        var REACT_CACHE_TYPE = Symbol.for('react.cache');
        var REACT_TRACING_MARKER_TYPE = Symbol.for('react.tracing_marker');
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = '@@iterator';
        function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== 'object') {
                return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === 'function') {
                return maybeIterator;
            }
            return null;
        }
        var contextStackCursor$1 = createCursor(null);
        var contextFiberStackCursor = createCursor(null);
        var rootInstanceStackCursor = createCursor(null); // Represents the nearest host transition provider (in React DOM, a <form />)
        // NOTE: Since forms cannot be nested, and this feature is only implemented by
        // React DOM, we don't technically need this to be a stack. It could be a single
        // module variable instead.
        var hostTransitionProviderCursor = createCursor(null); // TODO: This should initialize to NotPendingTransition, a constant
        // imported from the fiber config. However, because of a cycle in the module
        // graph, that value isn't defined during this module's initialization. I can't
        // think of a way to work around this without moving that value out of the
        // fiber config. For now, the "no provider" case is handled when reading,
        // inside useHostTransitionStatus.
        var HostTransitionContext = {
            $$typeof: REACT_CONTEXT_TYPE,
            _currentValue: null,
            _currentValue2: null,
            _threadCount: 0,
            Provider: null,
            Consumer: null
        };
        function requiredContext(c) {
            {
                if (c === null) {
                    error('Expected host context to exist. This error is likely caused by a bug ' + 'in React. Please file an issue.');
                }
            }
            return c;
        }
        function getCurrentRootHostContainer() {
            return rootInstanceStackCursor.current;
        }
        function getRootHostContainer() {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            return rootInstance;
        }
        function pushHostContainer(fiber, nextRootInstance) {
            // Push current root instance onto the stack;
            // This allows us to reset root when portals are popped.
            push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.
            // This enables us to pop only Fibers that provide unique contexts.
            push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.
            // However, we can't just call getRootHostContext() and push it because
            // we'd have a different number of entries on the stack depending on
            // whether getRootHostContext() throws somewhere in renderer code or not.
            // So we push an empty value first. This lets us safely unwind on errors.
            push(contextStackCursor$1, null, fiber);
            var nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.
            pop(contextStackCursor$1, fiber);
            push(contextStackCursor$1, nextRootContext, fiber);
        }
        function popHostContainer(fiber) {
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
            pop(rootInstanceStackCursor, fiber);
        }
        function getHostContext() {
            var context = requiredContext(contextStackCursor$1.current);
            return context;
        }
        function pushHostContext(fiber) {
            {
                var stateHook = fiber.memoizedState;
                if (stateHook !== null) {
                    // Only provide context if this fiber has been upgraded by a host
                    // transition. We use the same optimization for regular host context below.
                    push(hostTransitionProviderCursor, fiber, fiber);
                }
            }
            var context = requiredContext(contextStackCursor$1.current);
            var nextContext = getChildHostContext(context, fiber.type); // Don't push this Fiber's context unless it's unique.
            if (context !== nextContext) {
                // Track the context and the Fiber that provided it.
                // This enables us to pop only Fibers that provide unique contexts.
                push(contextFiberStackCursor, fiber, fiber);
                push(contextStackCursor$1, nextContext, fiber);
            }
        }
        function popHostContext(fiber) {
            if (contextFiberStackCursor.current === fiber) {
                // Do not pop unless this Fiber provided the current context.
                // pushHostContext() only pushes Fibers that provide unique contexts.
                pop(contextStackCursor$1, fiber);
                pop(contextFiberStackCursor, fiber);
            }
            {
                if (hostTransitionProviderCursor.current === fiber) {
                    // Do not pop unless this Fiber provided the current context. This is mostly
                    // a performance optimization, but conveniently it also prevents a potential
                    // data race where a host provider is upgraded (i.e. memoizedState becomes
                    // non-null) during a concurrent event. This is a bit of a flaw in the way
                    // we upgrade host components, but because we're accounting for it here, it
                    // should be fine.
                    pop(hostTransitionProviderCursor, fiber); // When popping the transition provider, we reset the context value back
                    // to `null`. We can do this because you're not allowd to nest forms. If
                    // we allowed for multiple nested host transition providers, then we'd
                    // need to reset this to the parent provider's status.
                    {
                        HostTransitionContext._currentValue = null;
                    }
                }
            }
        }
        var NoFlags$1 = /*                      */ 0;
        var PerformedWork = /*                */ 1;
        var Placement = /*                    */ 2;
        var DidCapture = /*                   */ 128;
        var Hydrating = /*                    */ 4096; // You can change the rest (and add more).
        var Update = /*                       */ 4;
        /* Skipped value:                                 0b0000000000000000000000001000; */ var ChildDeletion = /*                */ 16;
        var ContentReset = /*                 */ 32;
        var Callback = /*                     */ 64;
        /* Used by DidCapture:                            0b0000000000000000000010000000; */ var ForceClientRender = /*            */ 256;
        var Ref = /*                          */ 512;
        var Snapshot = /*                     */ 1024;
        var Passive$1 = /*                      */ 2048;
        /* Used by Hydrating:                             0b0000000000000001000000000000; */ var Visibility = /*                   */ 8192;
        var StoreConsistency = /*             */ 16384; // It's OK to reuse these bits because these flags are mutually exclusive for
        // different fiber types. We should really be doing this for as many flags as
        // possible, because we're about to run out of bits.
        var ScheduleRetry = StoreConsistency;
        var ShouldSuspendCommit = Visibility;
        var DidDefer = ContentReset;
        var LifecycleEffectMask = Passive$1 | Update | Callback | Ref | Snapshot | StoreConsistency; // Union of all commit flags (flags with the lifetime of a particular commit)
        var HostEffectMask = /*               */ 32767; // These are not really side effects, but we still reuse this field.
        var Incomplete = /*                   */ 32768;
        var ShouldCapture = /*                */ 65536;
        var ForceUpdateForLegacySuspense = /* */ 131072;
        var Forked = /*                       */ 1048576; // Static tags describe aspects of a fiber that are not specific to a render,
        // e.g. a fiber uses a passive effect (even if there are no updates on this particular render).
        // This enables us to defer more work in the unmount case,
        // since we can defer traversing the tree during layout to look for Passive effects,
        // and instead rely on the static flag as a signal that there may be cleanup work.
        var RefStatic = /*                    */ 2097152;
        var LayoutStatic = /*                 */ 4194304;
        var PassiveStatic = /*                */ 8388608;
        var MaySuspendCommit = /*             */ 16777216; // Flag used to identify newly inserted fibers. It isn't reset after commit unlike `Placement`.
        var PlacementDEV = /*                 */ 33554432;
        var MountLayoutDev = /*               */ 67108864;
        var MountPassiveDev = /*              */ 134217728; // Groups of flags that are used in the commit phase to skip over trees that
        // don't contain effects, by checking subtreeFlags.
        var BeforeMutationMask = // flag logic (see #20043)
        Update | Snapshot | 0;
        var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
        var LayoutMask = Update | Callback | Ref | Visibility; // TODO: Split into PassiveMountMask and PassiveUnmountMask
        var PassiveMask = Passive$1 | Visibility | ChildDeletion; // Union of tags that don't get reset on clones.
        // This allows certain concepts to persist without recalculating them,
        // e.g. whether a subtree contains passive effects or portals.
        var StaticMask = LayoutStatic | PassiveStatic | RefStatic | MaySuspendCommit;
        // This module only exists as an ESM wrapper around the external CommonJS
        var scheduleCallback$3 = Scheduler.unstable_scheduleCallback;
        var cancelCallback$1 = Scheduler.unstable_cancelCallback;
        var shouldYield = Scheduler.unstable_shouldYield;
        var requestPaint = Scheduler.unstable_requestPaint;
        var now$1 = Scheduler.unstable_now;
        var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
        var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
        var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
        var NormalPriority$1 = Scheduler.unstable_NormalPriority;
        var LowPriority = Scheduler.unstable_LowPriority;
        var IdlePriority = Scheduler.unstable_IdlePriority; // this doesn't actually exist on the scheduler, but it *does*
        // on scheduler/unstable_mock, which we'll need for internal testing
        var log$1 = Scheduler.log;
        var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
        // Helpers to patch console.logs to avoid logging during side-effect free
        // replaying on render function. This currently only patches the object
        // lazily which won't cover if the log function was extracted eagerly.
        // We could also eagerly patch the method.
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {}
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
            {
                if (disabledDepth === 0) {
                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;
                    prevInfo = console.info;
                    prevWarn = console.warn;
                    prevError = console.error;
                    prevGroup = console.group;
                    prevGroupCollapsed = console.groupCollapsed;
                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099
                    var props = {
                        configurable: true,
                        enumerable: true,
                        value: disabledLog,
                        writable: true
                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.
                    Object.defineProperties(console, {
                        info: props,
                        log: props,
                        warn: props,
                        error: props,
                        group: props,
                        groupCollapsed: props,
                        groupEnd: props
                    });
                /* eslint-enable react-internal/no-production-logging */ }
                disabledDepth++;
            }
        }
        function reenableLogs() {
            {
                disabledDepth--;
                if (disabledDepth === 0) {
                    /* eslint-disable react-internal/no-production-logging */ var props = {
                        configurable: true,
                        enumerable: true,
                        writable: true
                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.
                    Object.defineProperties(console, {
                        log: assign({}, props, {
                            value: prevLog
                        }),
                        info: assign({}, props, {
                            value: prevInfo
                        }),
                        warn: assign({}, props, {
                            value: prevWarn
                        }),
                        error: assign({}, props, {
                            value: prevError
                        }),
                        group: assign({}, props, {
                            value: prevGroup
                        }),
                        groupCollapsed: assign({}, props, {
                            value: prevGroupCollapsed
                        }),
                        groupEnd: assign({}, props, {
                            value: prevGroupEnd
                        })
                    });
                /* eslint-enable react-internal/no-production-logging */ }
                if (disabledDepth < 0) {
                    error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
                }
            }
        }
        var rendererID = null;
        var injectedHook = null;
        var injectedProfilingHooks = null;
        var hasLoggedError = false;
        var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';
        function injectInternals(internals) {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
                // No DevTools
                return false;
            }
            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (hook.isDisabled) {
                // This isn't a real property on the hook, but it can be set to opt out
                // of DevTools integration and associated warnings and logs.
                // https://github.com/facebook/react/issues/3877
                return true;
            }
            if (!hook.supportsFiber) {
                {
                    error('The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://reactjs.org/link/react-devtools');
                }
                return true;
            }
            try {
                if ("TURBOPACK compile-time truthy", 1) {
                    // Conditionally inject these hooks only if Timeline profiler is supported by this build.
                    // This gives DevTools a way to feature detect that isn't tied to version number
                    // (since profiling and timeline are controlled by different feature flags).
                    internals = assign({}, internals, {
                        getLaneLabelMap: getLaneLabelMap,
                        injectProfilingHooks: injectProfilingHooks
                    });
                }
                rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.
                injectedHook = hook;
            } catch (err) {
                // Catch all errors because it is unsafe to throw during initialization.
                {
                    error('React instrumentation encountered an error: %s.', err);
                }
            }
            if (hook.checkDCE) {
                // This is the real DevTools.
                return true;
            } else {
                // This is likely a hook installed by Fast Refresh runtime.
                return false;
            }
        }
        function onScheduleRoot(root, children) {
            {
                if (injectedHook && typeof injectedHook.onScheduleFiberRoot === 'function') {
                    try {
                        injectedHook.onScheduleFiberRoot(rendererID, root, children);
                    } catch (err) {
                        if (!hasLoggedError) {
                            hasLoggedError = true;
                            error('React instrumentation encountered an error: %s', err);
                        }
                    }
                }
            }
        }
        function onCommitRoot$1(root, eventPriority) {
            if (injectedHook && typeof injectedHook.onCommitFiberRoot === 'function') {
                try {
                    var didError = (root.current.flags & DidCapture) === DidCapture;
                    if ("TURBOPACK compile-time truthy", 1) {
                        var schedulerPriority;
                        switch(eventPriority){
                            case DiscreteEventPriority:
                                schedulerPriority = ImmediatePriority;
                                break;
                            case ContinuousEventPriority:
                                schedulerPriority = UserBlockingPriority;
                                break;
                            case DefaultEventPriority:
                                schedulerPriority = NormalPriority$1;
                                break;
                            case IdleEventPriority:
                                schedulerPriority = IdlePriority;
                                break;
                            default:
                                schedulerPriority = NormalPriority$1;
                                break;
                        }
                        injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);
                    }
                } catch (err) {
                    {
                        if (!hasLoggedError) {
                            hasLoggedError = true;
                            error('React instrumentation encountered an error: %s', err);
                        }
                    }
                }
            }
        }
        function onPostCommitRoot(root) {
            if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === 'function') {
                try {
                    injectedHook.onPostCommitFiberRoot(rendererID, root);
                } catch (err) {
                    {
                        if (!hasLoggedError) {
                            hasLoggedError = true;
                            error('React instrumentation encountered an error: %s', err);
                        }
                    }
                }
            }
        }
        function onCommitUnmount(fiber) {
            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === 'function') {
                try {
                    injectedHook.onCommitFiberUnmount(rendererID, fiber);
                } catch (err) {
                    {
                        if (!hasLoggedError) {
                            hasLoggedError = true;
                            error('React instrumentation encountered an error: %s', err);
                        }
                    }
                }
            }
        }
        function setIsStrictModeForDevtools(newIsStrictMode) {
            {
                if (typeof log$1 === 'function') {
                    // We're in a test because Scheduler.log only exists
                    // in SchedulerMock. To reduce the noise in strict mode tests,
                    // suppress warnings and disable scheduler yielding during the double render
                    unstable_setDisableYieldValue(newIsStrictMode);
                    setSuppressWarning(newIsStrictMode);
                }
                if (injectedHook && typeof injectedHook.setStrictMode === 'function') {
                    try {
                        injectedHook.setStrictMode(rendererID, newIsStrictMode);
                    } catch (err) {
                        {
                            if (!hasLoggedError) {
                                hasLoggedError = true;
                                error('React instrumentation encountered an error: %s', err);
                            }
                        }
                    }
                }
            }
        } // Profiler API hooks
        function injectProfilingHooks(profilingHooks) {
            injectedProfilingHooks = profilingHooks;
        }
        function getLaneLabelMap() {
            {
                var map = new Map();
                var lane = 1;
                for(var index = 0; index < TotalLanes; index++){
                    var label = getLabelForLane(lane);
                    map.set(lane, label);
                    lane *= 2;
                }
                return map;
            }
        }
        function markCommitStarted(lanes) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === 'function') {
                    injectedProfilingHooks.markCommitStarted(lanes);
                }
            }
        }
        function markCommitStopped() {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === 'function') {
                    injectedProfilingHooks.markCommitStopped();
                }
            }
        }
        function markComponentRenderStarted(fiber) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === 'function') {
                    injectedProfilingHooks.markComponentRenderStarted(fiber);
                }
            }
        }
        function markComponentRenderStopped() {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === 'function') {
                    injectedProfilingHooks.markComponentRenderStopped();
                }
            }
        }
        function markComponentPassiveEffectMountStarted(fiber) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === 'function') {
                    injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
                }
            }
        }
        function markComponentPassiveEffectMountStopped() {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === 'function') {
                    injectedProfilingHooks.markComponentPassiveEffectMountStopped();
                }
            }
        }
        function markComponentPassiveEffectUnmountStarted(fiber) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === 'function') {
                    injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
                }
            }
        }
        function markComponentPassiveEffectUnmountStopped() {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === 'function') {
                    injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
                }
            }
        }
        function markComponentLayoutEffectMountStarted(fiber) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === 'function') {
                    injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
                }
            }
        }
        function markComponentLayoutEffectMountStopped() {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === 'function') {
                    injectedProfilingHooks.markComponentLayoutEffectMountStopped();
                }
            }
        }
        function markComponentLayoutEffectUnmountStarted(fiber) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === 'function') {
                    injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
                }
            }
        }
        function markComponentLayoutEffectUnmountStopped() {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === 'function') {
                    injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
                }
            }
        }
        function markComponentErrored(fiber, thrownValue, lanes) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === 'function') {
                    injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
                }
            }
        }
        function markComponentSuspended(fiber, wakeable, lanes) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === 'function') {
                    injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
                }
            }
        }
        function markLayoutEffectsStarted(lanes) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === 'function') {
                    injectedProfilingHooks.markLayoutEffectsStarted(lanes);
                }
            }
        }
        function markLayoutEffectsStopped() {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === 'function') {
                    injectedProfilingHooks.markLayoutEffectsStopped();
                }
            }
        }
        function markPassiveEffectsStarted(lanes) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === 'function') {
                    injectedProfilingHooks.markPassiveEffectsStarted(lanes);
                }
            }
        }
        function markPassiveEffectsStopped() {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === 'function') {
                    injectedProfilingHooks.markPassiveEffectsStopped();
                }
            }
        }
        function markRenderStarted(lanes) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === 'function') {
                    injectedProfilingHooks.markRenderStarted(lanes);
                }
            }
        }
        function markRenderYielded() {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === 'function') {
                    injectedProfilingHooks.markRenderYielded();
                }
            }
        }
        function markRenderStopped() {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === 'function') {
                    injectedProfilingHooks.markRenderStopped();
                }
            }
        }
        function markRenderScheduled(lane) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === 'function') {
                    injectedProfilingHooks.markRenderScheduled(lane);
                }
            }
        }
        function markForceUpdateScheduled(fiber, lane) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === 'function') {
                    injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
                }
            }
        }
        function markStateUpdateScheduled(fiber, lane) {
            {
                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === 'function') {
                    injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
                }
            }
        }
        var NoMode = /*                         */ 0; // TODO: Remove ConcurrentMode by reading from the root tag instead
        var ConcurrentMode = /*                 */ 1;
        var ProfileMode = /*                    */ 2;
        var StrictLegacyMode = /*               */ 8;
        var StrictEffectsMode = /*              */ 16;
        var NoStrictPassiveEffectsMode = /*     */ 64;
        // TODO: This is pretty well supported by browsers. Maybe we can drop it.
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.
        // Based on:
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32
        var log = Math.log;
        var LN2 = Math.LN2;
        function clz32Fallback(x) {
            var asUint = x >>> 0;
            if (asUint === 0) {
                return 32;
            }
            return 31 - (log(asUint) / LN2 | 0) | 0;
        }
        // If those values are changed that package should be rebuilt and redeployed.
        var TotalLanes = 31;
        var NoLanes = /*                        */ 0;
        var NoLane = /*                          */ 0;
        var SyncHydrationLane = /*               */ 1;
        var SyncLane = /*                        */ 2;
        var SyncLaneIndex = 1;
        var InputContinuousHydrationLane = /*    */ 4;
        var InputContinuousLane = /*             */ 8;
        var DefaultHydrationLane = /*            */ 16;
        var DefaultLane = /*                     */ 32;
        var SyncUpdateLanes = SyncLane | InputContinuousLane | DefaultLane;
        var TransitionHydrationLane = /*                */ 64;
        var TransitionLanes = /*                       */ 4194176;
        var TransitionLane1 = /*                        */ 128;
        var TransitionLane2 = /*                        */ 256;
        var TransitionLane3 = /*                        */ 512;
        var TransitionLane4 = /*                        */ 1024;
        var TransitionLane5 = /*                        */ 2048;
        var TransitionLane6 = /*                        */ 4096;
        var TransitionLane7 = /*                        */ 8192;
        var TransitionLane8 = /*                        */ 16384;
        var TransitionLane9 = /*                        */ 32768;
        var TransitionLane10 = /*                       */ 65536;
        var TransitionLane11 = /*                       */ 131072;
        var TransitionLane12 = /*                       */ 262144;
        var TransitionLane13 = /*                       */ 524288;
        var TransitionLane14 = /*                       */ 1048576;
        var TransitionLane15 = /*                       */ 2097152;
        var RetryLanes = /*                            */ 62914560;
        var RetryLane1 = /*                             */ 4194304;
        var RetryLane2 = /*                             */ 8388608;
        var RetryLane3 = /*                             */ 16777216;
        var RetryLane4 = /*                             */ 33554432;
        var SomeRetryLane = RetryLane1;
        var SelectiveHydrationLane = /*          */ 67108864;
        var NonIdleLanes = /*                          */ 134217727;
        var IdleHydrationLane = /*               */ 134217728;
        var IdleLane = /*                        */ 268435456;
        var OffscreenLane = /*                   */ 536870912;
        var DeferredLane = /*                    */ 1073741824; // Any lane that might schedule an update. This is used to detect infinite
        // update loops, so it doesn't include hydration lanes or retries.
        var UpdateLanes = SyncLane | InputContinuousLane | DefaultLane | TransitionLanes; // This function is used for the experimental timeline (react-devtools-timeline)
        // It should be kept in sync with the Lanes values above.
        function getLabelForLane(lane) {
            {
                if (lane & SyncHydrationLane) {
                    return 'SyncHydrationLane';
                }
                if (lane & SyncLane) {
                    return 'Sync';
                }
                if (lane & InputContinuousHydrationLane) {
                    return 'InputContinuousHydration';
                }
                if (lane & InputContinuousLane) {
                    return 'InputContinuous';
                }
                if (lane & DefaultHydrationLane) {
                    return 'DefaultHydration';
                }
                if (lane & DefaultLane) {
                    return 'Default';
                }
                if (lane & TransitionHydrationLane) {
                    return 'TransitionHydration';
                }
                if (lane & TransitionLanes) {
                    return 'Transition';
                }
                if (lane & RetryLanes) {
                    return 'Retry';
                }
                if (lane & SelectiveHydrationLane) {
                    return 'SelectiveHydration';
                }
                if (lane & IdleHydrationLane) {
                    return 'IdleHydration';
                }
                if (lane & IdleLane) {
                    return 'Idle';
                }
                if (lane & OffscreenLane) {
                    return 'Offscreen';
                }
                if (lane & DeferredLane) {
                    return 'Deferred';
                }
            }
        }
        var NoTimestamp = -1;
        var nextTransitionLane = TransitionLane1;
        var nextRetryLane = RetryLane1;
        function getHighestPriorityLanes(lanes) {
            {
                var pendingSyncLanes = lanes & SyncUpdateLanes;
                if (pendingSyncLanes !== 0) {
                    return pendingSyncLanes;
                }
            }
            switch(getHighestPriorityLane(lanes)){
                case SyncHydrationLane:
                    return SyncHydrationLane;
                case SyncLane:
                    return SyncLane;
                case InputContinuousHydrationLane:
                    return InputContinuousHydrationLane;
                case InputContinuousLane:
                    return InputContinuousLane;
                case DefaultHydrationLane:
                    return DefaultHydrationLane;
                case DefaultLane:
                    return DefaultLane;
                case TransitionHydrationLane:
                    return TransitionHydrationLane;
                case TransitionLane1:
                case TransitionLane2:
                case TransitionLane3:
                case TransitionLane4:
                case TransitionLane5:
                case TransitionLane6:
                case TransitionLane7:
                case TransitionLane8:
                case TransitionLane9:
                case TransitionLane10:
                case TransitionLane11:
                case TransitionLane12:
                case TransitionLane13:
                case TransitionLane14:
                case TransitionLane15:
                    return lanes & TransitionLanes;
                case RetryLane1:
                case RetryLane2:
                case RetryLane3:
                case RetryLane4:
                    return lanes & RetryLanes;
                case SelectiveHydrationLane:
                    return SelectiveHydrationLane;
                case IdleHydrationLane:
                    return IdleHydrationLane;
                case IdleLane:
                    return IdleLane;
                case OffscreenLane:
                    return OffscreenLane;
                case DeferredLane:
                    // This shouldn't be reachable because deferred work is always entangled
                    // with something else.
                    return NoLanes;
                default:
                    {
                        error('Should have found matching lanes. This is a bug in React.');
                    }
                    return lanes;
            }
        }
        function getNextLanes(root, wipLanes) {
            // Early bailout if there's no pending work left.
            var pendingLanes = root.pendingLanes;
            if (pendingLanes === NoLanes) {
                return NoLanes;
            }
            var nextLanes = NoLanes;
            var suspendedLanes = root.suspendedLanes;
            var pingedLanes = root.pingedLanes; // Do not work on any idle work until all the non-idle work has finished,
            // even if the work is suspended.
            var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
            if (nonIdlePendingLanes !== NoLanes) {
                var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
                if (nonIdleUnblockedLanes !== NoLanes) {
                    nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
                } else {
                    var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
                    if (nonIdlePingedLanes !== NoLanes) {
                        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
                    }
                }
            } else {
                // The only remaining work is Idle.
                var unblockedLanes = pendingLanes & ~suspendedLanes;
                if (unblockedLanes !== NoLanes) {
                    nextLanes = getHighestPriorityLanes(unblockedLanes);
                } else {
                    if (pingedLanes !== NoLanes) {
                        nextLanes = getHighestPriorityLanes(pingedLanes);
                    }
                }
            }
            if (nextLanes === NoLanes) {
                // This should only be reachable if we're suspended
                // TODO: Consider warning in this path if a fallback timer is not scheduled.
                return NoLanes;
            } // If we're already in the middle of a render, switching lanes will interrupt
            // it and we'll lose our progress. We should only do this if the new lanes are
            // higher priority.
            if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
            // bother waiting until the root is complete.
            (wipLanes & suspendedLanes) === NoLanes) {
                var nextLane = getHighestPriorityLane(nextLanes);
                var wipLane = getHighestPriorityLane(wipLanes);
                if (// one. This works because the bits decrease in priority as you go left.
                nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The
                // only difference between default updates and transition updates is that
                // default updates do not support refresh transitions.
                nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {
                    // Keep working on the existing in-progress tree. Do not interrupt.
                    return wipLanes;
                }
            }
            return nextLanes;
        }
        function getEntangledLanes(root, renderLanes) {
            var entangledLanes = renderLanes;
            if ((entangledLanes & InputContinuousLane) !== NoLanes) {
                // When updates are sync by default, we entangle continuous priority updates
                // and default updates, so they render in the same batch. The only reason
                // they use separate lanes is because continuous updates should interrupt
                // transitions, but default updates should not.
                entangledLanes |= entangledLanes & DefaultLane;
            } // Check for entangled lanes and add them to the batch.
            //
            // A lane is said to be entangled with another when it's not allowed to render
            // in a batch that does not also include the other lane. Typically we do this
            // when multiple updates have the same source, and we only want to respond to
            // the most recent event from that source.
            //
            // Note that we apply entanglements *after* checking for partial work above.
            // This means that if a lane is entangled during an interleaved event while
            // it's already rendering, we won't interrupt it. This is intentional, since
            // entanglement is usually "best effort": we'll try our best to render the
            // lanes in the same batch, but it's not worth throwing out partially
            // completed work in order to do it.
            // TODO: Reconsider this. The counter-argument is that the partial work
            // represents an intermediate state, which we don't want to show to the user.
            // And by spending extra time finishing it, we're increasing the amount of
            // time it takes to show the final state, which is what they are actually
            // waiting for.
            //
            // For those exceptions where entanglement is semantically important,
            // we should ensure that there is no partial work at the
            // time we apply the entanglement.
            var allEntangledLanes = root.entangledLanes;
            if (allEntangledLanes !== NoLanes) {
                var entanglements = root.entanglements;
                var lanes = entangledLanes & allEntangledLanes;
                while(lanes > 0){
                    var index = pickArbitraryLaneIndex(lanes);
                    var lane = 1 << index;
                    entangledLanes |= entanglements[index];
                    lanes &= ~lane;
                }
            }
            return entangledLanes;
        }
        function computeExpirationTime(lane, currentTime) {
            switch(lane){
                case SyncHydrationLane:
                case SyncLane:
                case InputContinuousHydrationLane:
                case InputContinuousLane:
                    // User interactions should expire slightly more quickly.
                    //
                    // NOTE: This is set to the corresponding constant as in Scheduler.js.
                    // When we made it larger, a product metric in www regressed, suggesting
                    // there's a user interaction that's being starved by a series of
                    // synchronous updates. If that theory is correct, the proper solution is
                    // to fix the starvation. However, this scenario supports the idea that
                    // expiration times are an important safeguard when starvation
                    // does happen.
                    return currentTime + syncLaneExpirationMs;
                case DefaultHydrationLane:
                case DefaultLane:
                case TransitionHydrationLane:
                case TransitionLane1:
                case TransitionLane2:
                case TransitionLane3:
                case TransitionLane4:
                case TransitionLane5:
                case TransitionLane6:
                case TransitionLane7:
                case TransitionLane8:
                case TransitionLane9:
                case TransitionLane10:
                case TransitionLane11:
                case TransitionLane12:
                case TransitionLane13:
                case TransitionLane14:
                case TransitionLane15:
                    return currentTime + transitionLaneExpirationMs;
                case RetryLane1:
                case RetryLane2:
                case RetryLane3:
                case RetryLane4:
                    // TODO: Retries should be allowed to expire if they are CPU bound for
                    // too long, but when I made this change it caused a spike in browser
                    // crashes. There must be some other underlying bug; not super urgent but
                    // ideally should figure out why and fix it. Unfortunately we don't have
                    // a repro for the crashes, only detected via production metrics.
                    return NoTimestamp;
                case SelectiveHydrationLane:
                case IdleHydrationLane:
                case IdleLane:
                case OffscreenLane:
                case DeferredLane:
                    // Anything idle priority or lower should never expire.
                    return NoTimestamp;
                default:
                    {
                        error('Should have found matching lanes. This is a bug in React.');
                    }
                    return NoTimestamp;
            }
        }
        function markStarvedLanesAsExpired(root, currentTime) {
            // TODO: This gets called every time we yield. We can optimize by storing
            // the earliest expiration time on the root. Then use that to quickly bail out
            // of this function.
            var pendingLanes = root.pendingLanes;
            var suspendedLanes = root.suspendedLanes;
            var pingedLanes = root.pingedLanes;
            var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their
            // expiration time. If so, we'll assume the update is being starved and mark
            // it as expired to force it to finish.
            // TODO: We should be able to replace this with upgradePendingLanesToSync
            //
            // We exclude retry lanes because those must always be time sliced, in order
            // to unwrap uncached promises.
            // TODO: Write a test for this
            var lanes = pendingLanes & ~RetryLanes;
            while(lanes > 0){
                var index = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index;
                var expirationTime = expirationTimes[index];
                if (expirationTime === NoTimestamp) {
                    // Found a pending lane with no expiration time. If it's not suspended, or
                    // if it's pinged, assume it's CPU-bound. Compute a new expiration time
                    // using the current time.
                    if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                        // Assumes timestamps are monotonically increasing.
                        expirationTimes[index] = computeExpirationTime(lane, currentTime);
                    }
                } else if (expirationTime <= currentTime) {
                    // This lane expired
                    root.expiredLanes |= lane;
                }
                lanes &= ~lane;
            }
        } // This returns the highest priority pending lanes regardless of whether they
        // are suspended.
        function getHighestPriorityPendingLanes(root) {
            return getHighestPriorityLanes(root.pendingLanes);
        }
        function getLanesToRetrySynchronouslyOnError(root, originallyAttemptedLanes) {
            if (root.errorRecoveryDisabledLanes & originallyAttemptedLanes) {
                // The error recovery mechanism is disabled until these lanes are cleared.
                return NoLanes;
            }
            var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;
            if (everythingButOffscreen !== NoLanes) {
                return everythingButOffscreen;
            }
            if (everythingButOffscreen & OffscreenLane) {
                return OffscreenLane;
            }
            return NoLanes;
        }
        function includesSyncLane(lanes) {
            return (lanes & (SyncLane | SyncHydrationLane)) !== NoLanes;
        }
        function includesNonIdleWork(lanes) {
            return (lanes & NonIdleLanes) !== NoLanes;
        }
        function includesOnlyRetries(lanes) {
            return (lanes & RetryLanes) === lanes;
        }
        function includesOnlyNonUrgentLanes(lanes) {
            // TODO: Should hydration lanes be included here? This function is only
            // used in `updateDeferredValueImpl`.
            var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
            return (lanes & UrgentLanes) === NoLanes;
        }
        function includesOnlyTransitions(lanes) {
            return (lanes & TransitionLanes) === lanes;
        }
        function includesBlockingLane(root, lanes) {
            var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
            return (lanes & SyncDefaultLanes) !== NoLanes;
        }
        function includesExpiredLane(root, lanes) {
            // This is a separate check from includesBlockingLane because a lane can
            // expire after a render has already started.
            return (lanes & root.expiredLanes) !== NoLanes;
        }
        function isTransitionLane(lane) {
            return (lane & TransitionLanes) !== NoLanes;
        }
        function claimNextTransitionLane() {
            // Cycle through the lanes, assigning each new transition to the next lane.
            // In most cases, this means every transition gets its own lane, until we
            // run out of lanes and cycle back to the beginning.
            var lane = nextTransitionLane;
            nextTransitionLane <<= 1;
            if ((nextTransitionLane & TransitionLanes) === NoLanes) {
                nextTransitionLane = TransitionLane1;
            }
            return lane;
        }
        function claimNextRetryLane() {
            var lane = nextRetryLane;
            nextRetryLane <<= 1;
            if ((nextRetryLane & RetryLanes) === NoLanes) {
                nextRetryLane = RetryLane1;
            }
            return lane;
        }
        function getHighestPriorityLane(lanes) {
            return lanes & -lanes;
        }
        function pickArbitraryLane(lanes) {
            // This wrapper function gets inlined. Only exists so to communicate that it
            // doesn't matter which bit is selected; you can pick any bit without
            // affecting the algorithms where its used. Here I'm using
            // getHighestPriorityLane because it requires the fewest operations.
            return getHighestPriorityLane(lanes);
        }
        function pickArbitraryLaneIndex(lanes) {
            return 31 - clz32(lanes);
        }
        function laneToIndex(lane) {
            return pickArbitraryLaneIndex(lane);
        }
        function includesSomeLane(a, b) {
            return (a & b) !== NoLanes;
        }
        function isSubsetOfLanes(set, subset) {
            return (set & subset) === subset;
        }
        function mergeLanes(a, b) {
            return a | b;
        }
        function removeLanes(set, subset) {
            return set & ~subset;
        }
        function intersectLanes(a, b) {
            return a & b;
        } // Seems redundant, but it changes the type from a single lane (used for
        // updates) to a group of lanes (used for flushing work).
        function laneToLanes(lane) {
            return lane;
        }
        function higherPriorityLane(a, b) {
            // This works because the bit ranges decrease in priority as you go left.
            return a !== NoLane && a < b ? a : b;
        }
        function createLaneMap(initial) {
            // Intentionally pushing one by one.
            // https://v8.dev/blog/elements-kinds#avoid-creating-holes
            var laneMap = [];
            for(var i = 0; i < TotalLanes; i++){
                laneMap.push(initial);
            }
            return laneMap;
        }
        function markRootUpdated$1(root, updateLane) {
            root.pendingLanes |= updateLane; // If there are any suspended transitions, it's possible this new update
            // could unblock them. Clear the suspended lanes so that we can try rendering
            // them again.
            //
            // TODO: We really only need to unsuspend only lanes that are in the
            // `subtreeLanes` of the updated fiber, or the update lanes of the return
            // path. This would exclude suspended updates in an unrelated sibling tree,
            // since there's no way for this update to unblock it.
            //
            // We don't do this if the incoming update is idle, because we never process
            // idle updates until after all the regular updates have finished; there's no
            // way it could unblock a transition.
            if (updateLane !== IdleLane) {
                root.suspendedLanes = NoLanes;
                root.pingedLanes = NoLanes;
            }
        }
        function markRootSuspended$1(root, suspendedLanes, spawnedLane) {
            root.suspendedLanes |= suspendedLanes;
            root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.
            var expirationTimes = root.expirationTimes;
            var lanes = suspendedLanes;
            while(lanes > 0){
                var index = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index;
                expirationTimes[index] = NoTimestamp;
                lanes &= ~lane;
            }
            if (spawnedLane !== NoLane) {
                markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
            }
        }
        function markRootPinged$1(root, pingedLanes) {
            root.pingedLanes |= root.suspendedLanes & pingedLanes;
        }
        function markRootFinished(root, remainingLanes, spawnedLane) {
            var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
            root.pendingLanes = remainingLanes; // Let's try everything again
            root.suspendedLanes = NoLanes;
            root.pingedLanes = NoLanes;
            root.expiredLanes &= remainingLanes;
            root.entangledLanes &= remainingLanes;
            root.errorRecoveryDisabledLanes &= remainingLanes;
            root.shellSuspendCounter = 0;
            var entanglements = root.entanglements;
            var expirationTimes = root.expirationTimes;
            var hiddenUpdates = root.hiddenUpdates; // Clear the lanes that no longer have pending work
            var lanes = noLongerPendingLanes;
            while(lanes > 0){
                var index = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index;
                entanglements[index] = NoLanes;
                expirationTimes[index] = NoTimestamp;
                var hiddenUpdatesForLane = hiddenUpdates[index];
                if (hiddenUpdatesForLane !== null) {
                    hiddenUpdates[index] = null; // "Hidden" updates are updates that were made to a hidden component. They
                    // have special logic associated with them because they may be entangled
                    // with updates that occur outside that tree. But once the outer tree
                    // commits, they behave like regular updates.
                    for(var i = 0; i < hiddenUpdatesForLane.length; i++){
                        var update = hiddenUpdatesForLane[i];
                        if (update !== null) {
                            update.lane &= ~OffscreenLane;
                        }
                    }
                }
                lanes &= ~lane;
            }
            if (spawnedLane !== NoLane) {
                markSpawnedDeferredLane(root, spawnedLane, // to entangle the spawned task with the parent task.
                NoLanes);
            }
        }
        function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
            // This render spawned a deferred task. Mark it as pending.
            root.pendingLanes |= spawnedLane;
            root.suspendedLanes &= ~spawnedLane; // Entangle the spawned lane with the DeferredLane bit so that we know it
            // was the result of another render. This lets us avoid a useDeferredValue
            // waterfall — only the first level will defer.
            var spawnedLaneIndex = laneToIndex(spawnedLane);
            root.entangledLanes |= spawnedLane;
            root.entanglements[spawnedLaneIndex] |= DeferredLane | // If the parent render task suspended, we must also entangle those lanes
            // with the spawned task, so that the deferred task includes all the same
            // updates that the parent task did. We can exclude any lane that is not
            // used for updates (e.g. Offscreen).
            entangledLanes & UpdateLanes;
        }
        function markRootEntangled(root, entangledLanes) {
            // In addition to entangling each of the given lanes with each other, we also
            // have to consider _transitive_ entanglements. For each lane that is already
            // entangled with *any* of the given lanes, that lane is now transitively
            // entangled with *all* the given lanes.
            //
            // Translated: If C is entangled with A, then entangling A with B also
            // entangles C with B.
            //
            // If this is hard to grasp, it might help to intentionally break this
            // function and look at the tests that fail in ReactTransition-test.js. Try
            // commenting out one of the conditions below.
            var rootEntangledLanes = root.entangledLanes |= entangledLanes;
            var entanglements = root.entanglements;
            var lanes = rootEntangledLanes;
            while(lanes){
                var index = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index;
                if (lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?
                entanglements[index] & entangledLanes) {
                    entanglements[index] |= entangledLanes;
                }
                lanes &= ~lane;
            }
        }
        function upgradePendingLaneToSync(root, lane) {
            // Since we're upgrading the priority of the given lane, there is now pending
            // sync work.
            root.pendingLanes |= SyncLane; // Entangle the sync lane with the lane we're upgrading. This means SyncLane
            // will not be allowed to finish without also finishing the given lane.
            root.entangledLanes |= SyncLane;
            root.entanglements[SyncLaneIndex] |= lane;
        }
        function upgradePendingLanesToSync(root, lanesToUpgrade) {
            // Same as upgradePendingLaneToSync but accepts multiple lanes, so it's a
            // bit slower.
            root.pendingLanes |= SyncLane;
            root.entangledLanes |= SyncLane;
            var lanes = lanesToUpgrade;
            while(lanes){
                var index = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index;
                root.entanglements[SyncLaneIndex] |= lane;
                lanes &= ~lane;
            }
        }
        function markHiddenUpdate(root, update, lane) {
            var index = laneToIndex(lane);
            var hiddenUpdates = root.hiddenUpdates;
            var hiddenUpdatesForLane = hiddenUpdates[index];
            if (hiddenUpdatesForLane === null) {
                hiddenUpdates[index] = [
                    update
                ];
            } else {
                hiddenUpdatesForLane.push(update);
            }
            update.lane = lane | OffscreenLane;
        }
        function getBumpedLaneForHydration(root, renderLanes) {
            var renderLane = getHighestPriorityLane(renderLanes);
            var lane;
            if ((renderLane & SyncUpdateLanes) !== NoLane) {
                lane = SyncHydrationLane;
            } else {
                switch(renderLane){
                    case SyncLane:
                        lane = SyncHydrationLane;
                        break;
                    case InputContinuousLane:
                        lane = InputContinuousHydrationLane;
                        break;
                    case DefaultLane:
                        lane = DefaultHydrationLane;
                        break;
                    case TransitionLane1:
                    case TransitionLane2:
                    case TransitionLane3:
                    case TransitionLane4:
                    case TransitionLane5:
                    case TransitionLane6:
                    case TransitionLane7:
                    case TransitionLane8:
                    case TransitionLane9:
                    case TransitionLane10:
                    case TransitionLane11:
                    case TransitionLane12:
                    case TransitionLane13:
                    case TransitionLane14:
                    case TransitionLane15:
                    case RetryLane1:
                    case RetryLane2:
                    case RetryLane3:
                    case RetryLane4:
                        lane = TransitionHydrationLane;
                        break;
                    case IdleLane:
                        lane = IdleHydrationLane;
                        break;
                    default:
                        // Everything else is already either a hydration lane, or shouldn't
                        // be retried at a hydration lane.
                        lane = NoLane;
                        break;
                }
            } // Check if the lane we chose is suspended. If so, that indicates that we
            // already attempted and failed to hydrate at that level. Also check if we're
            // already rendering that lane, which is rare but could happen.
            if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {
                // Give up trying to hydrate and fall back to client render.
                return NoLane;
            }
            return lane;
        }
        function addFiberToLanesMap(root, fiber, lanes) {
            if (!isDevToolsPresent) {
                return;
            }
            var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;
            while(lanes > 0){
                var index = laneToIndex(lanes);
                var lane = 1 << index;
                var updaters = pendingUpdatersLaneMap[index];
                updaters.add(fiber);
                lanes &= ~lane;
            }
        }
        function movePendingFibersToMemoized(root, lanes) {
            if (!isDevToolsPresent) {
                return;
            }
            var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;
            var memoizedUpdaters = root.memoizedUpdaters;
            while(lanes > 0){
                var index = laneToIndex(lanes);
                var lane = 1 << index;
                var updaters = pendingUpdatersLaneMap[index];
                if (updaters.size > 0) {
                    updaters.forEach(function(fiber) {
                        var alternate = fiber.alternate;
                        if (alternate === null || !memoizedUpdaters.has(alternate)) {
                            memoizedUpdaters.add(fiber);
                        }
                    });
                    updaters.clear();
                }
                lanes &= ~lane;
            }
        }
        function getTransitionsForLanes(root, lanes) {
            {
                return null;
            }
        }
        var DiscreteEventPriority = SyncLane;
        var ContinuousEventPriority = InputContinuousLane;
        var DefaultEventPriority = DefaultLane;
        var IdleEventPriority = IdleLane;
        var currentUpdatePriority = NoLane;
        function getCurrentUpdatePriority() {
            return currentUpdatePriority;
        }
        function setCurrentUpdatePriority(newPriority) {
            currentUpdatePriority = newPriority;
        }
        function runWithPriority(priority, fn) {
            var previousPriority = currentUpdatePriority;
            try {
                currentUpdatePriority = priority;
                return fn();
            } finally{
                currentUpdatePriority = previousPriority;
            }
        }
        function higherEventPriority(a, b) {
            return a !== 0 && a < b ? a : b;
        }
        function lowerEventPriority(a, b) {
            return a === 0 || a > b ? a : b;
        }
        function isHigherEventPriority(a, b) {
            return a !== 0 && a < b;
        }
        function lanesToEventPriority(lanes) {
            var lane = getHighestPriorityLane(lanes);
            if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
                return DiscreteEventPriority;
            }
            if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
                return ContinuousEventPriority;
            }
            if (includesNonIdleWork(lane)) {
                return DefaultEventPriority;
            }
            return IdleEventPriority;
        }
        // $FlowFixMe[method-unbinding]
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        /*
 * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol
 * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
 *
 * The functions in this module will throw an easier-to-understand,
 * easier-to-debug exception with a clear errors message message explaining the
 * problem. (Instead of a confusing exception thrown inside the implementation
 * of the `value` object).
 */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.
        function typeName(value) {
            {
                // toStringTag is needed for namespaced types like Temporal.Instant
                var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]
                return type;
            }
        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.
        function willCoercionThrow(value) {
            {
                try {
                    testStringCoercion(value);
                    return false;
                } catch (e) {
                    return true;
                }
            }
        }
        function testStringCoercion(value) {
            // If you ended up here by following an exception call stack, here's what's
            // happened: you supplied an object or symbol value to React (as a prop, key,
            // DOM attribute, CSS property, string ref, etc.) and when React tried to
            // coerce it to a string using `'' + value`, an exception was thrown.
            //
            // The most common types that will cause this exception are `Symbol` instances
            // and Temporal objects like `Temporal.Instant`. But any object that has a
            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
            // exception. (Library authors do this to prevent users from using built-in
            // numeric operators like `+` or comparison operators like `>=` because custom
            // methods are needed to perform accurate arithmetic or comparison.)
            //
            // To fix the problem, coerce this object or symbol value to a string before
            // passing it to React. The most reliable way is usually `String(value)`.
            //
            // To find which value is throwing, check the browser or debugger console.
            // Before this exception was thrown, there should be `console.error` output
            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
            // problem and how that type was used: key, atrribute, input value prop, etc.
            // In most cases, this console output also shows the component and its
            // ancestor components where the exception happened.
            //
            // eslint-disable-next-line react-internal/safe-string-coercion
            return '' + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
            {
                if (willCoercionThrow(value)) {
                    error('The provided `%s` attribute is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', attributeName, typeName(value));
                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
                }
            }
        }
        function checkKeyStringCoercion(value) {
            {
                if (willCoercionThrow(value)) {
                    error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));
                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
                }
            }
        }
        function checkPropStringCoercion(value, propName) {
            {
                if (willCoercionThrow(value)) {
                    error('The provided `%s` prop is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', propName, typeName(value));
                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
                }
            }
        }
        function checkCSSPropertyStringCoercion(value, propName) {
            {
                if (willCoercionThrow(value)) {
                    error('The provided `%s` CSS property is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', propName, typeName(value));
                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
                }
            }
        }
        function checkHtmlStringCoercion(value) {
            {
                if (willCoercionThrow(value)) {
                    error('The provided HTML markup uses a value of unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));
                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
                }
            }
        }
        function checkFormFieldValueStringCoercion(value) {
            {
                if (willCoercionThrow(value)) {
                    error('Form field values (value, checked, defaultValue, or defaultChecked props)' + ' must be strings, not %s.' + ' This value must be coerced to a string before using it here.', typeName(value));
                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
                }
            }
        }
        var FunctionComponent = 0;
        var ClassComponent = 1;
        var IndeterminateComponent = 2; // Before we know whether it is function or class
        var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
        var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
        var HostComponent = 5;
        var HostText = 6;
        var Fragment = 7;
        var Mode = 8;
        var ContextConsumer = 9;
        var ContextProvider = 10;
        var ForwardRef = 11;
        var Profiler = 12;
        var SuspenseComponent = 13;
        var MemoComponent = 14;
        var SimpleMemoComponent = 15;
        var LazyComponent = 16;
        var IncompleteClassComponent = 17;
        var DehydratedFragment = 18;
        var SuspenseListComponent = 19;
        var ScopeComponent = 21;
        var OffscreenComponent = 22;
        var LegacyHiddenComponent = 23;
        var CacheComponent = 24;
        var TracingMarkerComponent = 25;
        var HostHoistable = 26;
        var HostSingleton = 27;
        var randomKey = Math.random().toString(36).slice(2);
        var internalInstanceKey = '__reactFiber$' + randomKey;
        var internalPropsKey = '__reactProps$' + randomKey;
        var internalContainerInstanceKey = '__reactContainer$' + randomKey;
        var internalEventHandlersKey = '__reactEvents$' + randomKey;
        var internalEventHandlerListenersKey = '__reactListeners$' + randomKey;
        var internalEventHandlesSetKey = '__reactHandles$' + randomKey;
        var internalRootNodeResourcesKey = '__reactResources$' + randomKey;
        var internalHoistableMarker = '__reactMarker$' + randomKey;
        function detachDeletedInstance(node) {
            // TODO: This function is only called on host components. I don't think all of
            // these fields are relevant.
            delete node[internalInstanceKey];
            delete node[internalPropsKey];
            delete node[internalEventHandlersKey];
            delete node[internalEventHandlerListenersKey];
            delete node[internalEventHandlesSetKey];
        }
        function precacheFiberNode(hostInst, node) {
            node[internalInstanceKey] = hostInst;
        }
        function markContainerAsRoot(hostRoot, node) {
            // $FlowFixMe[prop-missing]
            node[internalContainerInstanceKey] = hostRoot;
        }
        function unmarkContainerAsRoot(node) {
            // $FlowFixMe[prop-missing]
            node[internalContainerInstanceKey] = null;
        }
        function isContainerMarkedAsRoot(node) {
            // $FlowFixMe[prop-missing]
            return !!node[internalContainerInstanceKey];
        } // Given a DOM node, return the closest HostComponent or HostText fiber ancestor.
        // If the target node is part of a hydrated or not yet rendered subtree, then
        // this may also return a SuspenseComponent or HostRoot to indicate that.
        // Conceptually the HostRoot fiber is a child of the Container node. So if you
        // pass the Container node as the targetNode, you will not actually get the
        // HostRoot back. To get to the HostRoot, you need to pass a child of it.
        // The same thing applies to Suspense boundaries.
        function getClosestInstanceFromNode(targetNode) {
            var targetInst = targetNode[internalInstanceKey];
            if (targetInst) {
                // Don't return HostRoot or SuspenseComponent here.
                return targetInst;
            } // If the direct event target isn't a React owned DOM node, we need to look
            // to see if one of its parents is a React owned DOM node.
            var parentNode = targetNode.parentNode;
            while(parentNode){
                // We'll check if this is a container root that could include
                // React nodes in the future. We need to check this first because
                // if we're a child of a dehydrated container, we need to first
                // find that inner container before moving on to finding the parent
                // instance. Note that we don't check this field on  the targetNode
                // itself because the fibers are conceptually between the container
                // node and the first child. It isn't surrounding the container node.
                // If it's not a container, we check if it's an instance.
                targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
                if (targetInst) {
                    // Since this wasn't the direct target of the event, we might have
                    // stepped past dehydrated DOM nodes to get here. However they could
                    // also have been non-React nodes. We need to answer which one.
                    // If we the instance doesn't have any children, then there can't be
                    // a nested suspense boundary within it. So we can use this as a fast
                    // bailout. Most of the time, when people add non-React children to
                    // the tree, it is using a ref to a child-less DOM node.
                    // Normally we'd only need to check one of the fibers because if it
                    // has ever gone from having children to deleting them or vice versa
                    // it would have deleted the dehydrated boundary nested inside already.
                    // However, since the HostRoot starts out with an alternate it might
                    // have one on the alternate so we need to check in case this was a
                    // root.
                    var alternate = targetInst.alternate;
                    if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                        // Next we need to figure out if the node that skipped past is
                        // nested within a dehydrated boundary and if so, which one.
                        var suspenseInstance = getParentSuspenseInstance(targetNode);
                        while(suspenseInstance !== null){
                            // We found a suspense instance. That means that we haven't
                            // hydrated it yet. Even though we leave the comments in the
                            // DOM after hydrating, and there are boundaries in the DOM
                            // that could already be hydrated, we wouldn't have found them
                            // through this pass since if the target is hydrated it would
                            // have had an internalInstanceKey on it.
                            // Let's get the fiber associated with the SuspenseComponent
                            // as the deepest instance.
                            // $FlowFixMe[prop-missing]
                            var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                            if (targetSuspenseInst) {
                                return targetSuspenseInst;
                            } // If we don't find a Fiber on the comment, it might be because
                            // we haven't gotten to hydrate it yet. There might still be a
                            // parent boundary that hasn't above this one so we need to find
                            // the outer most that is known.
                            suspenseInstance = getParentSuspenseInstance(suspenseInstance); // If we don't find one, then that should mean that the parent
                        // host component also hasn't hydrated yet. We can return it
                        // below since it will bail out on the isMounted check later.
                        }
                    }
                    return targetInst;
                }
                targetNode = parentNode;
                parentNode = targetNode.parentNode;
            }
            return null;
        }
        /**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */ function getInstanceFromNode(node) {
            var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
            if (inst) {
                var tag = inst.tag;
                if (tag === HostComponent || tag === HostText || tag === SuspenseComponent || tag === HostHoistable || tag === HostSingleton || tag === HostRoot) {
                    return inst;
                } else {
                    return null;
                }
            }
            return null;
        }
        /**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */ function getNodeFromInstance(inst) {
            var tag = inst.tag;
            if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton || tag === HostText) {
                // In Fiber this, is just the state node right now. We assume it will be
                // a host component or host text.
                return inst.stateNode;
            } // Without this first invariant, passing a non-DOM-component triggers the next
            // invariant for a missing parent, which is super confusing.
            throw new Error('getNodeFromInstance: Invalid argument.');
        }
        function getFiberCurrentPropsFromNode(node) {
            return node[internalPropsKey] || null;
        }
        function updateFiberProps(node, props) {
            node[internalPropsKey] = props;
        }
        function getEventListenerSet(node) {
            var elementListenerSet = node[internalEventHandlersKey];
            if (elementListenerSet === undefined) {
                elementListenerSet = node[internalEventHandlersKey] = new Set();
            }
            return elementListenerSet;
        }
        function getResourcesFromRoot(root) {
            var resources = root[internalRootNodeResourcesKey];
            if (!resources) {
                resources = root[internalRootNodeResourcesKey] = {
                    hoistableStyles: new Map(),
                    hoistableScripts: new Map()
                };
            }
            return resources;
        }
        function isMarkedHoistable(node) {
            return !!node[internalHoistableMarker];
        }
        function markNodeAsHoistable(node) {
            node[internalHoistableMarker] = true;
        }
        function isOwnedInstance(node) {
            return !!(node[internalHoistableMarker] || node[internalInstanceKey]);
        }
        var allNativeEvents = new Set();
        /**
 * Mapping from registration name to event name
 */ var registrationNameDependencies = {};
        /**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in __DEV__.
 * @type {Object}
 */ var possibleRegistrationNames = {}; // Trust the developer to only use possibleRegistrationNames in true
        function registerTwoPhaseEvent(registrationName, dependencies) {
            registerDirectEvent(registrationName, dependencies);
            registerDirectEvent(registrationName + 'Capture', dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
            {
                if (registrationNameDependencies[registrationName]) {
                    error('EventRegistry: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName);
                }
            }
            registrationNameDependencies[registrationName] = dependencies;
            {
                var lowerCasedName = registrationName.toLowerCase();
                possibleRegistrationNames[lowerCasedName] = registrationName;
                if (registrationName === 'onDoubleClick') {
                    possibleRegistrationNames.ondblclick = registrationName;
                }
            }
            for(var i = 0; i < dependencies.length; i++){
                allNativeEvents.add(dependencies[i]);
            }
        }
        var canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');
        var hasReadOnlyValue = {
            button: true,
            checkbox: true,
            image: true,
            hidden: true,
            radio: true,
            reset: true,
            submit: true
        };
        function checkControlledValueProps(tagName, props) {
            {
                if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
                    if (tagName === 'select') {
                        error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, set `onChange`.');
                    } else {
                        error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.');
                    }
                }
                if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
                    error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
                }
            }
        }
        /* eslint-disable max-len */ var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        /* eslint-enable max-len */ var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
            if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
                return true;
            }
            if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
                return false;
            }
            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
                validatedAttributeNameCache[attributeName] = true;
                return true;
            }
            illegalAttributeNameCache[attributeName] = true;
            {
                error('Invalid attribute name: `%s`', attributeName);
            }
            return false;
        }
        /**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */ function getValueForAttribute(node, name, expected) {
            {
                if (!isAttributeNameSafe(name)) {
                    return;
                }
                if (!node.hasAttribute(name)) {
                    // shouldRemoveAttribute
                    switch(typeof expected){
                        case 'function':
                        case 'symbol':
                            // eslint-disable-line
                            return expected;
                        case 'boolean':
                            {
                                var prefix = name.toLowerCase().slice(0, 5);
                                if (prefix !== 'data-' && prefix !== 'aria-') {
                                    return expected;
                                }
                            }
                    }
                    return expected === undefined ? undefined : null;
                }
                var value = node.getAttribute(name);
                {
                    checkAttributeStringCoercion(expected, name);
                }
                if (value === '' + expected) {
                    return expected;
                }
                return value;
            }
        }
        function getValueForAttributeOnCustomComponent(node, name, expected) {
            {
                if (!isAttributeNameSafe(name)) {
                    return;
                }
                if (!node.hasAttribute(name)) {
                    // shouldRemoveAttribute
                    switch(typeof expected){
                        case 'symbol':
                        case 'object':
                            // Symbols and objects are ignored when they're emitted so
                            // it would be expected that they end up not having an attribute.
                            return expected;
                    }
                    return expected === undefined ? undefined : null;
                }
                var value = node.getAttribute(name);
                {
                    checkAttributeStringCoercion(expected, name);
                }
                if (value === '' + expected) {
                    return expected;
                }
                return value;
            }
        }
        function setValueForAttribute(node, name, value) {
            if (isAttributeNameSafe(name)) {
                // If the prop isn't in the special list, treat it as a simple attribute.
                // shouldRemoveAttribute
                if (value === null) {
                    node.removeAttribute(name);
                    return;
                }
                switch(typeof value){
                    case 'undefined':
                    case 'function':
                    case 'symbol':
                        // eslint-disable-line
                        node.removeAttribute(name);
                        return;
                    case 'boolean':
                        {
                            var prefix = name.toLowerCase().slice(0, 5);
                            if (prefix !== 'data-' && prefix !== 'aria-') {
                                node.removeAttribute(name);
                                return;
                            }
                        }
                }
                {
                    checkAttributeStringCoercion(value, name);
                }
                node.setAttribute(name, '' + value);
            }
        }
        function setValueForKnownAttribute(node, name, value) {
            if (value === null) {
                node.removeAttribute(name);
                return;
            }
            switch(typeof value){
                case 'undefined':
                case 'function':
                case 'symbol':
                case 'boolean':
                    {
                        node.removeAttribute(name);
                        return;
                    }
            }
            {
                checkAttributeStringCoercion(value, name);
            }
            node.setAttribute(name, '' + value);
        }
        function setValueForNamespacedAttribute(node, namespace, name, value) {
            if (value === null) {
                node.removeAttribute(name);
                return;
            }
            switch(typeof value){
                case 'undefined':
                case 'function':
                case 'symbol':
                case 'boolean':
                    {
                        node.removeAttribute(name);
                        return;
                    }
            }
            {
                checkAttributeStringCoercion(value, name);
            }
            node.setAttributeNS(namespace, name, '' + value);
        }
        var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, ownerFn) {
            {
                if (prefix === undefined) {
                    // Extract the VM specific prefix used by each line.
                    try {
                        throw Error();
                    } catch (x) {
                        var match = x.stack.trim().match(/\n( *(at )?)/);
                        prefix = match && match[1] || '';
                    }
                } // We use the prefix to ensure our stacks line up with native stack frames.
                return '\n' + prefix + name;
            }
        }
        function describeDebugInfoFrame(name, env) {
            return describeBuiltInComponentFrame(name + (env ? ' (' + env + ')' : ''));
        }
        var reentry = false;
        var componentFrameCache;
        {
            var PossiblyWeakMap$1 = typeof WeakMap === 'function' ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap$1();
        }
        /**
 * Leverages native browser/VM stack frames to get proper details (e.g.
 * filename, line + col number) for a single component in a component stack. We
 * do this by:
 *   (1) throwing and catching an error in the function - this will be our
 *       control error.
 *   (2) calling the component which will eventually throw an error that we'll
 *       catch - this will be our sample error.
 *   (3) diffing the control and sample error stacks to find the stack frame
 *       which represents our component.
 */ function describeNativeComponentFrame(fn, construct) {
            // If something asked for a stack inside a fake render, it should get ignored.
            if (!fn || reentry) {
                return '';
            }
            {
                var frame = componentFrameCache.get(fn);
                if (frame !== undefined) {
                    return frame;
                }
            }
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.
            Error.prepareStackTrace = undefined;
            var previousDispatcher;
            {
                previousDispatcher = ReactCurrentDispatcher$2.current; // Set the dispatcher in DEV because this might be call in the render function
                // for warnings.
                ReactCurrentDispatcher$2.current = null;
                disableLogs();
            }
            /**
   * Finding a common stack frame between sample and control errors can be
   * tricky given the different types and levels of stack trace truncation from
   * different JS VMs. So instead we'll attempt to control what that common
   * frame should be through this object method:
   * Having both the sample and control errors be in the function under the
   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and
   * `displayName` properties of the function ensures that a stack
   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in
   * it for both control and sample stacks.
   */ var RunInRootFrame = {
                DetermineComponentFrameRoot: function() {
                    var control;
                    try {
                        // This should throw.
                        if (construct) {
                            // Something should be setting the props in the constructor.
                            var Fake = function() {
                                throw Error();
                            }; // $FlowFixMe[prop-missing]
                            Object.defineProperty(Fake.prototype, 'props', {
                                set: function() {
                                    // We use a throwing setter instead of frozen or non-writable props
                                    // because that won't throw in a non-strict mode function.
                                    throw Error();
                                }
                            });
                            if (typeof Reflect === 'object' && Reflect.construct) {
                                // We construct a different control for this case to include any extra
                                // frames added by the construct call.
                                try {
                                    Reflect.construct(Fake, []);
                                } catch (x) {
                                    control = x;
                                }
                                Reflect.construct(fn, [], Fake);
                            } else {
                                try {
                                    Fake.call();
                                } catch (x) {
                                    control = x;
                                } // $FlowFixMe[prop-missing] found when upgrading Flow
                                fn.call(Fake.prototype);
                            }
                        } else {
                            try {
                                throw Error();
                            } catch (x) {
                                control = x;
                            } // TODO(luna): This will currently only throw if the function component
                            // tries to access React/ReactDOM/props. We should probably make this throw
                            // in simple components too
                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async
                            // component, which we don't yet support. Attach a noop catch handler to
                            // silence the error.
                            // TODO: Implement component stacks for async client components?
                            if (maybePromise && typeof maybePromise.catch === 'function') {
                                maybePromise.catch(function() {});
                            }
                        }
                    } catch (sample) {
                        // This is inlined manually because closure doesn't do it for us.
                        if (sample && control && typeof sample.stack === 'string') {
                            return [
                                sample.stack,
                                control.stack
                            ];
                        }
                    }
                    return [
                        null,
                        null
                    ];
                }
            }; // $FlowFixMe[prop-missing]
            RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';
            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.
            if (namePropDescriptor && namePropDescriptor.configurable) {
                // V8 utilizes a function's `name` property when generating a stack trace.
                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.
                // $FlowFixMe[cannot-write]
                'name', {
                    value: 'DetermineComponentFrameRoot'
                });
            }
            try {
                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
                if (sampleStack && controlStack) {
                    // This extracts the first frame from the sample that isn't also in the control.
                    // Skipping one frame that we assume is the frame that calls the two.
                    var sampleLines = sampleStack.split('\n');
                    var controlLines = controlStack.split('\n');
                    var s = 0;
                    var c = 0;
                    while(s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')){
                        s++;
                    }
                    while(c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')){
                        c++;
                    } // We couldn't find our intentionally injected common root frame, attempt
                    // to find another common root frame by search from the bottom of the
                    // control stack...
                    if (s === sampleLines.length || c === controlLines.length) {
                        s = sampleLines.length - 1;
                        c = controlLines.length - 1;
                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){
                            // We expect at least one stack frame to be shared.
                            // Typically this will be the root most one. However, stack frames may be
                            // cut off due to maximum stack limits. In this case, one maybe cut off
                            // earlier than the other. We assume that the sample is longer or the same
                            // and there for cut off earlier. So we should find the root most frame in
                            // the sample somewhere in the control.
                            c--;
                        }
                    }
                    for(; s >= 1 && c >= 0; s--, c--){
                        // Next we find the first one that isn't the same which should be the
                        // frame that called our sample function and the control.
                        if (sampleLines[s] !== controlLines[c]) {
                            // In V8, the first line is describing the message but other VMs don't.
                            // If we're about to return the first line, and the control is also on the same
                            // line, that's a pretty good indicator that our sample threw at same line as
                            // the control. I.e. before we entered the sample frame. So we ignore this result.
                            // This can happen if you passed a class to function component, or non-function.
                            if (s !== 1 || c !== 1) {
                                do {
                                    s--;
                                    c--; // We may still have similar intermediate frames from the construct call.
                                    // The next one that isn't the same should be our match though.
                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                                        // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                                        var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
                                        // but we have a user-provided "displayName"
                                        // splice it in to make the stack more readable.
                                        if (fn.displayName && _frame.includes('<anonymous>')) {
                                            _frame = _frame.replace('<anonymous>', fn.displayName);
                                        }
                                        if ("TURBOPACK compile-time truthy", 1) {
                                            if (typeof fn === 'function') {
                                                componentFrameCache.set(fn, _frame);
                                            }
                                        } // Return the line we found.
                                        return _frame;
                                    }
                                }while (s >= 1 && c >= 0)
                            }
                            break;
                        }
                    }
                }
            } finally{
                reentry = false;
                {
                    ReactCurrentDispatcher$2.current = previousDispatcher;
                    reenableLogs();
                }
                Error.prepareStackTrace = previousPrepareStackTrace;
            } // Fallback to just using the name if we couldn't make it throw.
            var name = fn ? fn.displayName || fn.name : '';
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
            {
                if (typeof fn === 'function') {
                    componentFrameCache.set(fn, syntheticFrame);
                }
            }
            return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, ownerFn) {
            {
                return describeNativeComponentFrame(ctor, true);
            }
        }
        function describeFunctionComponentFrame(fn, ownerFn) {
            {
                return describeNativeComponentFrame(fn, false);
            }
        }
        function describeFiber(fiber) {
            switch(fiber.tag){
                case HostHoistable:
                case HostSingleton:
                case HostComponent:
                    return describeBuiltInComponentFrame(fiber.type);
                case LazyComponent:
                    return describeBuiltInComponentFrame('Lazy');
                case SuspenseComponent:
                    return describeBuiltInComponentFrame('Suspense');
                case SuspenseListComponent:
                    return describeBuiltInComponentFrame('SuspenseList');
                case FunctionComponent:
                case IndeterminateComponent:
                case SimpleMemoComponent:
                    return describeFunctionComponentFrame(fiber.type);
                case ForwardRef:
                    return describeFunctionComponentFrame(fiber.type.render);
                case ClassComponent:
                    return describeClassComponentFrame(fiber.type);
                default:
                    return '';
            }
        }
        function getStackByFiberInDevAndProd(workInProgress) {
            try {
                var info = '';
                var node = workInProgress;
                do {
                    info += describeFiber(node);
                    if ("TURBOPACK compile-time truthy", 1) {
                        // Add any Server Component stack frames in reverse order.
                        var debugInfo = node._debugInfo;
                        if (debugInfo) {
                            for(var i = debugInfo.length - 1; i >= 0; i--){
                                var entry = debugInfo[i];
                                if (typeof entry.name === 'string') {
                                    info += describeDebugInfoFrame(entry.name, entry.env);
                                }
                            }
                        }
                    } // $FlowFixMe[incompatible-type] we bail out when we get a null
                    node = node.return;
                }while (node)
                return info;
            } catch (x) {
                return '\nError generating stack: ' + x.message + '\n' + x.stack;
            }
        }
        function getWrappedName$1(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
                return displayName;
            }
            var functionName = innerType.displayName || innerType.name || '';
            return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
        } // Keep in sync with react-reconciler/getComponentNameFromFiber
        function getContextName$1(type) {
            return type.displayName || 'Context';
        }
        var REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.
        function getComponentNameFromType(type) {
            if (type == null) {
                // Host root, text node or just invalid type.
                return null;
            }
            if (typeof type === 'function') {
                if (type.$$typeof === REACT_CLIENT_REFERENCE) {
                    // TODO: Create a convention for naming client references with debug info.
                    return null;
                }
                return type.displayName || type.name || null;
            }
            if (typeof type === 'string') {
                return type;
            }
            switch(type){
                case REACT_FRAGMENT_TYPE:
                    return 'Fragment';
                case REACT_PORTAL_TYPE:
                    return 'Portal';
                case REACT_PROFILER_TYPE:
                    return 'Profiler';
                case REACT_STRICT_MODE_TYPE:
                    return 'StrictMode';
                case REACT_SUSPENSE_TYPE:
                    return 'Suspense';
                case REACT_SUSPENSE_LIST_TYPE:
                    return 'SuspenseList';
                case REACT_CACHE_TYPE:
                    {
                        return 'Cache';
                    }
            }
            if (typeof type === 'object') {
                {
                    if (typeof type.tag === 'number') {
                        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
                    }
                }
                switch(type.$$typeof){
                    case REACT_PROVIDER_TYPE:
                        {
                            var provider = type;
                            return getContextName$1(provider._context) + '.Provider';
                        }
                    case REACT_CONTEXT_TYPE:
                        var context = type;
                        {
                            return getContextName$1(context) + '.Consumer';
                        }
                    case REACT_CONSUMER_TYPE:
                        {
                            return null;
                        }
                    case REACT_FORWARD_REF_TYPE:
                        return getWrappedName$1(type, type.render, 'ForwardRef');
                    case REACT_MEMO_TYPE:
                        var outerName = type.displayName || null;
                        if (outerName !== null) {
                            return outerName;
                        }
                        return getComponentNameFromType(type.type) || 'Memo';
                    case REACT_LAZY_TYPE:
                        {
                            var lazyComponent = type;
                            var payload = lazyComponent._payload;
                            var init = lazyComponent._init;
                            try {
                                return getComponentNameFromType(init(payload));
                            } catch (x) {
                                return null;
                            }
                        }
                }
            }
            return null;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
            var functionName = innerType.displayName || innerType.name || '';
            return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
        } // Keep in sync with shared/getComponentNameFromType
        function getContextName(type) {
            return type.displayName || 'Context';
        }
        function getComponentNameFromFiber(fiber) {
            var tag = fiber.tag, type = fiber.type;
            switch(tag){
                case CacheComponent:
                    return 'Cache';
                case ContextConsumer:
                    {
                        var context = type;
                        return getContextName(context) + '.Consumer';
                    }
                case ContextProvider:
                    {
                        var provider = type;
                        return getContextName(provider._context) + '.Provider';
                    }
                case DehydratedFragment:
                    return 'DehydratedFragment';
                case ForwardRef:
                    return getWrappedName(type, type.render, 'ForwardRef');
                case Fragment:
                    return 'Fragment';
                case HostHoistable:
                case HostSingleton:
                case HostComponent:
                    // Host component type is the display name (e.g. "div", "View")
                    return type;
                case HostPortal:
                    return 'Portal';
                case HostRoot:
                    return 'Root';
                case HostText:
                    return 'Text';
                case LazyComponent:
                    // Name comes from the type in this case; we don't have a tag.
                    return getComponentNameFromType(type);
                case Mode:
                    if (type === REACT_STRICT_MODE_TYPE) {
                        // Don't be less specific than shared/getComponentNameFromType
                        return 'StrictMode';
                    }
                    return 'Mode';
                case OffscreenComponent:
                    return 'Offscreen';
                case Profiler:
                    return 'Profiler';
                case ScopeComponent:
                    return 'Scope';
                case SuspenseComponent:
                    return 'Suspense';
                case SuspenseListComponent:
                    return 'SuspenseList';
                case TracingMarkerComponent:
                    return 'TracingMarker';
                // The display name for this tags come from the user-provided type:
                case ClassComponent:
                case FunctionComponent:
                case IncompleteClassComponent:
                case IndeterminateComponent:
                case MemoComponent:
                case SimpleMemoComponent:
                    if (typeof type === 'function') {
                        return type.displayName || type.name || null;
                    }
                    if (typeof type === 'string') {
                        return type;
                    }
                    break;
            }
            return null;
        }
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var current = null;
        var isRendering = false;
        function getCurrentFiberOwnerNameInDevOrNull() {
            {
                if (current === null) {
                    return null;
                }
                var owner = current._debugOwner;
                if (owner !== null && typeof owner !== 'undefined') {
                    return getComponentNameFromFiber(owner);
                }
            }
            return null;
        }
        function getCurrentFiberStackInDev() {
            {
                if (current === null) {
                    return '';
                } // Safe because if current fiber exists, we are reconciling,
                // and it is guaranteed to be the work-in-progress version.
                return getStackByFiberInDevAndProd(current);
            }
        }
        function resetCurrentFiber() {
            {
                ReactDebugCurrentFrame.getCurrentStack = null;
                current = null;
                isRendering = false;
            }
        }
        function setCurrentFiber(fiber) {
            {
                ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
                current = fiber;
                isRendering = false;
            }
        }
        function getCurrentFiber() {
            {
                return current;
            }
        }
        function setIsRendering(rendering) {
            {
                isRendering = rendering;
            }
        }
        // around this limitation, we use an opaque type that can only be obtained by
        // passing the value through getToStringValue first.
        function toString(value) {
            // The coercion safety check is performed in getToStringValue().
            // eslint-disable-next-line react-internal/safe-string-coercion
            return '' + value;
        }
        function getToStringValue(value) {
            switch(typeof value){
                case 'boolean':
                case 'number':
                case 'string':
                case 'undefined':
                    return value;
                case 'object':
                    {
                        checkFormFieldValueStringCoercion(value);
                    }
                    return value;
                default:
                    // function, symbol are assigned as empty strings
                    return '';
            }
        }
        function isCheckable(elem) {
            var type = elem.type;
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
        }
        function getTracker(node) {
            return node._valueTracker;
        }
        function detachTracker(node) {
            node._valueTracker = null;
        }
        function getValueFromNode(node) {
            var value = '';
            if (!node) {
                return value;
            }
            if (isCheckable(node)) {
                value = node.checked ? 'true' : 'false';
            } else {
                value = node.value;
            }
            return value;
        }
        function trackValueOnNode(node) {
            var valueField = isCheckable(node) ? 'checked' : 'value';
            var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
            {
                checkFormFieldValueStringCoercion(node[valueField]);
            }
            var currentValue = '' + node[valueField]; // if someone has already defined a value or Safari, then bail
            // and don't track value will cause over reporting of changes,
            // but it's better then a hard failure
            // (needed for certain tests that spyOn input values and Safari)
            if (node.hasOwnProperty(valueField) || typeof descriptor === 'undefined' || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
                return;
            }
            var get = descriptor.get, set = descriptor.set;
            Object.defineProperty(node, valueField, {
                configurable: true,
                // $FlowFixMe[missing-this-annot]
                get: function() {
                    return get.call(this);
                },
                // $FlowFixMe[missing-local-annot]
                // $FlowFixMe[missing-this-annot]
                set: function(value) {
                    {
                        checkFormFieldValueStringCoercion(value);
                    }
                    currentValue = '' + value;
                    set.call(this, value);
                }
            }); // We could've passed this the first time
            // but it triggers a bug in IE11 and Edge 14/15.
            // Calling defineProperty() again should be equivalent.
            // https://github.com/facebook/react/issues/11768
            Object.defineProperty(node, valueField, {
                enumerable: descriptor.enumerable
            });
            var tracker = {
                getValue: function() {
                    return currentValue;
                },
                setValue: function(value) {
                    {
                        checkFormFieldValueStringCoercion(value);
                    }
                    currentValue = '' + value;
                },
                stopTracking: function() {
                    detachTracker(node);
                    delete node[valueField];
                }
            };
            return tracker;
        }
        function track(node) {
            if (getTracker(node)) {
                return;
            }
            node._valueTracker = trackValueOnNode(node);
        }
        function updateValueIfChanged(node) {
            if (!node) {
                return false;
            }
            var tracker = getTracker(node); // if there is no tracker at this point it's unlikely
            // that trying again will succeed
            if (!tracker) {
                return true;
            }
            var lastValue = tracker.getValue();
            var nextValue = getValueFromNode(node);
            if (nextValue !== lastValue) {
                tracker.setValue(nextValue);
                return true;
            }
            return false;
        }
        function getActiveElement(doc) {
            doc = doc || (typeof document !== 'undefined' ? document : undefined);
            if (typeof doc === 'undefined') {
                return null;
            }
            try {
                return doc.activeElement || doc.body;
            } catch (e) {
                return doc.body;
            }
        }
        // When passing user input into querySelector(All) the embedded string must not alter
        // the semantics of the query. This escape function is safe to use when we know the
        // provided value is going to be wrapped in double quotes as part of an attribute selector
        // Do not use it anywhere else
        // we escape double quotes and backslashes
        var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n\"\\]/g;
        function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
            return value.replace(escapeSelectorAttributeValueInsideDoubleQuotesRegex, function(ch) {
                return '\\' + ch.charCodeAt(0).toString(16) + ' ';
            });
        }
        var didWarnValueDefaultValue$1 = false;
        var didWarnCheckedDefaultChecked = false;
        /**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */ function validateInputProps(element, props) {
            {
                // Normally we check for undefined and null the same, but explicitly specifying both
                // properties, at all is probably worth warning for. We could move this either direction
                // and just make it ok to pass null or just check hasOwnProperty.
                if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
                    error('%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);
                    didWarnCheckedDefaultChecked = true;
                }
                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
                    error('%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);
                    didWarnValueDefaultValue$1 = true;
                }
            }
        }
        function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
            var node = element; // Temporarily disconnect the input from any radio buttons.
            // Changing the type or name as the same time as changing the checked value
            // needs to be atomically applied. We can only ensure that by disconnecting
            // the name while do the mutations and then reapply the name after that's done.
            node.name = '';
            if (type != null && typeof type !== 'function' && typeof type !== 'symbol' && typeof type !== 'boolean') {
                {
                    checkAttributeStringCoercion(type, 'type');
                }
                node.type = type;
            } else {
                node.removeAttribute('type');
            }
            if (value != null) {
                if (type === 'number') {
                    if (value === 0 && node.value === '' || // We explicitly want to coerce to number here if possible.
                    // eslint-disable-next-line
                    node.value != value) {
                        node.value = toString(getToStringValue(value));
                    }
                } else if (node.value !== toString(getToStringValue(value))) {
                    node.value = toString(getToStringValue(value));
                }
            } else if (type === 'submit' || type === 'reset') {
                // Submit/reset inputs need the attribute removed completely to avoid
                // blank-text buttons.
                node.removeAttribute('value');
            }
            {
                // When syncing the value attribute, the value comes from a cascade of
                // properties:
                //  1. The value React property
                //  2. The defaultValue React property
                //  3. Otherwise there should be no change
                if (value != null) {
                    setDefaultValue(node, type, getToStringValue(value));
                } else if (defaultValue != null) {
                    setDefaultValue(node, type, getToStringValue(defaultValue));
                } else if (lastDefaultValue != null) {
                    node.removeAttribute('value');
                }
            }
            {
                // When syncing the checked attribute, it only changes when it needs
                // to be removed, such as transitioning from a checkbox into a text input
                if (checked == null && defaultChecked != null) {
                    node.defaultChecked = !!defaultChecked;
                }
            }
            if (checked != null) {
                // Important to set this even if it's not a change in order to update input
                // value tracking with radio buttons
                // TODO: Should really update input value tracking for the whole radio
                // button group in an effect or something (similar to #27024)
                node.checked = checked && typeof checked !== 'function' && typeof checked !== 'symbol';
            }
            if (name != null && typeof name !== 'function' && typeof name !== 'symbol' && typeof name !== 'boolean') {
                {
                    checkAttributeStringCoercion(name, 'name');
                }
                node.name = toString(getToStringValue(name));
            } else {
                node.removeAttribute('name');
            }
        }
        function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating) {
            var node = element;
            if (type != null && typeof type !== 'function' && typeof type !== 'symbol' && typeof type !== 'boolean') {
                {
                    checkAttributeStringCoercion(type, 'type');
                }
                node.type = type;
            }
            if (value != null || defaultValue != null) {
                var isButton = type === 'submit' || type === 'reset'; // Avoid setting value attribute on submit/reset inputs as it overrides the
                // default value provided by the browser. See: #12872
                if (isButton && (value === undefined || value === null)) {
                    return;
                }
                var defaultValueStr = defaultValue != null ? toString(getToStringValue(defaultValue)) : '';
                var initialValue = value != null ? toString(getToStringValue(value)) : defaultValueStr; // Do not assign value if it is already set. This prevents user text input
                // from being lost during SSR hydration.
                if (!isHydrating) {
                    {
                        // When syncing the value attribute, the value property should use
                        // the wrapperState._initialValue property. This uses:
                        //
                        //   1. The value React property when present
                        //   2. The defaultValue React property when present
                        //   3. An empty string
                        if (initialValue !== node.value) {
                            node.value = initialValue;
                        }
                    }
                }
                {
                    // Otherwise, the value attribute is synchronized to the property,
                    // so we assign defaultValue to the same thing as the value property
                    // assignment step above.
                    node.defaultValue = initialValue;
                }
            } // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
            // this is needed to work around a chrome bug where setting defaultChecked
            // will sometimes influence the value of checked (even after detachment).
            // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
            // We need to temporarily unset name to avoid disrupting radio button groups.
            var checkedOrDefault = checked != null ? checked : defaultChecked; // TODO: This 'function' or 'symbol' check isn't replicated in other places
            // so this semantic is inconsistent.
            var initialChecked = typeof checkedOrDefault !== 'function' && typeof checkedOrDefault !== 'symbol' && !!checkedOrDefault;
            if (isHydrating) {
                // Detach .checked from .defaultChecked but leave user input alone
                node.checked = node.checked;
            } else {
                node.checked = !!initialChecked;
            }
            {
                // When syncing the checked attribute, both the checked property and
                // attribute are assigned at the same time using defaultChecked. This uses:
                //
                //   1. The checked React property when present
                //   2. The defaultChecked React property when present
                //   3. Otherwise, false
                node.defaultChecked = !node.defaultChecked;
                node.defaultChecked = !!initialChecked;
            }
            if (name != null && typeof name !== 'function' && typeof name !== 'symbol' && typeof name !== 'boolean') {
                {
                    checkAttributeStringCoercion(name, 'name');
                }
                node.name = name;
            }
        }
        function restoreControlledInputState(element, props) {
            var rootNode = element;
            updateInput(rootNode, props.value, props.defaultValue, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name);
            var name = props.name;
            if (props.type === 'radio' && name != null) {
                var queryRoot = rootNode;
                while(queryRoot.parentNode){
                    queryRoot = queryRoot.parentNode;
                } // If `rootNode.form` was non-null, then we could try `form.elements`,
                // but that sometimes behaves strangely in IE8. We could also try using
                // `form.getElementsByName`, but that will only return direct children
                // and won't include inputs that use the HTML5 `form=` attribute. Since
                // the input might not even be in a form. It might not even be in the
                // document. Let's just use the local `querySelectorAll` to ensure we don't
                // miss anything.
                {
                    checkAttributeStringCoercion(name, 'name');
                }
                var group = queryRoot.querySelectorAll('input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes('' + name) + '"][type="radio"]');
                for(var i = 0; i < group.length; i++){
                    var otherNode = group[i];
                    if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                        continue;
                    } // This will throw if radio buttons rendered by different copies of React
                    // and the same name are rendered into the same form (same as #1939).
                    // That's probably okay; we don't support it just as we don't support
                    // mixing React radio buttons with non-React ones.
                    var otherProps = getFiberCurrentPropsFromNode(otherNode);
                    if (!otherProps) {
                        throw new Error('ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.');
                    } // If this is a controlled radio button group, forcing the input that
                    // was previously checked to update will cause it to be come re-checked
                    // as appropriate.
                    updateInput(otherNode, otherProps.value, otherProps.defaultValue, otherProps.defaultValue, otherProps.checked, otherProps.defaultChecked, otherProps.type, otherProps.name);
                } // If any updateInput() call set .checked to true, an input in this group
                // (often, `rootNode` itself) may have become unchecked
                for(var _i = 0; _i < group.length; _i++){
                    var _otherNode = group[_i];
                    if (_otherNode.form !== rootNode.form) {
                        continue;
                    }
                    updateValueIfChanged(_otherNode);
                }
            }
        } // In Chrome, assigning defaultValue to certain input types triggers input validation.
        // For number inputs, the display value loses trailing decimal points. For email inputs,
        // Chrome raises "The specified value <x> is not a valid email address".
        //
        // Here we check to see if the defaultValue has actually changed, avoiding these problems
        // when the user is inputting text
        //
        // https://github.com/facebook/react/issues/7253
        function setDefaultValue(node, type, value) {
            if (type !== 'number' || getActiveElement(node.ownerDocument) !== node) {
                if (node.defaultValue !== toString(value)) {
                    node.defaultValue = toString(value);
                }
            }
        }
        var didWarnSelectedSetOnOption = false;
        var didWarnInvalidChild = false;
        var didWarnInvalidInnerHTML = false;
        /**
 * Implements an <option> host component that warns when `selected` is set.
 */ function validateOptionProps(element, props) {
            {
                // If a value is not provided, then the children must be simple.
                if (props.value == null) {
                    if (typeof props.children === 'object' && props.children !== null) {
                        React.Children.forEach(props.children, function(child) {
                            if (child == null) {
                                return;
                            }
                            if (typeof child === 'string' || typeof child === 'number') {
                                return;
                            }
                            if (!didWarnInvalidChild) {
                                didWarnInvalidChild = true;
                                error('Cannot infer the option value of complex children. ' + 'Pass a `value` prop or use a plain string as children to <option>.');
                            }
                        });
                    } else if (props.dangerouslySetInnerHTML != null) {
                        if (!didWarnInvalidInnerHTML) {
                            didWarnInvalidInnerHTML = true;
                            error('Pass a `value` prop if you set dangerouslyInnerHTML so React knows ' + 'which value should be selected.');
                        }
                    }
                } // TODO: Remove support for `selected` in <option>.
                if (props.selected != null && !didWarnSelectedSetOnOption) {
                    error('Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');
                    didWarnSelectedSetOnOption = true;
                }
            }
        }
        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare
        function isArray(a) {
            return isArrayImpl(a);
        }
        var didWarnValueDefaultValue;
        {
            didWarnValueDefaultValue = false;
        }
        function getDeclarationErrorAddendum() {
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) {
                return '\n\nCheck the render method of `' + ownerName + '`.';
            }
            return '';
        }
        var valuePropNames = [
            'value',
            'defaultValue'
        ];
        /**
 * Validation function for `value` and `defaultValue`.
 */ function checkSelectPropTypes(props) {
            {
                for(var i = 0; i < valuePropNames.length; i++){
                    var propName = valuePropNames[i];
                    if (props[propName] == null) {
                        continue;
                    }
                    var propNameIsArray = isArray(props[propName]);
                    if (props.multiple && !propNameIsArray) {
                        error('The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());
                    } else if (!props.multiple && propNameIsArray) {
                        error('The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());
                    }
                }
            }
        }
        function updateOptions(node, multiple, propValue, setDefaultSelected) {
            var options = node.options;
            if (multiple) {
                var selectedValues = propValue;
                var selectedValue = {};
                for(var i = 0; i < selectedValues.length; i++){
                    // Prefix to avoid chaos with special keys.
                    selectedValue['$' + selectedValues[i]] = true;
                }
                for(var _i = 0; _i < options.length; _i++){
                    var selected = selectedValue.hasOwnProperty('$' + options[_i].value);
                    if (options[_i].selected !== selected) {
                        options[_i].selected = selected;
                    }
                    if (selected && setDefaultSelected) {
                        options[_i].defaultSelected = true;
                    }
                }
            } else {
                // Do not set `select.value` as exact behavior isn't consistent across all
                // browsers for all cases.
                var _selectedValue = toString(getToStringValue(propValue));
                var defaultSelected = null;
                for(var _i2 = 0; _i2 < options.length; _i2++){
                    if (options[_i2].value === _selectedValue) {
                        options[_i2].selected = true;
                        if (setDefaultSelected) {
                            options[_i2].defaultSelected = true;
                        }
                        return;
                    }
                    if (defaultSelected === null && !options[_i2].disabled) {
                        defaultSelected = options[_i2];
                    }
                }
                if (defaultSelected !== null) {
                    defaultSelected.selected = true;
                }
            }
        }
        /**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */ function validateSelectProps(element, props) {
            {
                checkSelectPropTypes(props);
                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
                    error('Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components');
                    didWarnValueDefaultValue = true;
                }
            }
        }
        function initSelect(element, value, defaultValue, multiple) {
            var node = element;
            node.multiple = !!multiple;
            if (value != null) {
                updateOptions(node, !!multiple, value, false);
            } else if (defaultValue != null) {
                updateOptions(node, !!multiple, defaultValue, true);
            }
        }
        function updateSelect(element, value, defaultValue, multiple, wasMultiple) {
            var node = element;
            if (value != null) {
                updateOptions(node, !!multiple, value, false);
            } else if (!!wasMultiple !== !!multiple) {
                // For simplicity, reapply `defaultValue` if `multiple` is toggled.
                if (defaultValue != null) {
                    updateOptions(node, !!multiple, defaultValue, true);
                } else {
                    // Revert the select back to its default unselected state.
                    updateOptions(node, !!multiple, multiple ? [] : '', false);
                }
            }
        }
        function restoreControlledSelectState(element, props) {
            var node = element;
            var value = props.value;
            if (value != null) {
                updateOptions(node, !!props.multiple, value, false);
            }
        }
        var didWarnValDefaultVal = false;
        /**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */ function validateTextareaProps(element, props) {
            {
                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
                    error('%s contains a textarea with both value and defaultValue props. ' + 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component');
                    didWarnValDefaultVal = true;
                }
                if (props.children != null && props.value == null) {
                    error('Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
                }
            }
        }
        function updateTextarea(element, value, defaultValue) {
            var node = element;
            if (value != null) {
                // Cast `value` to a string to ensure the value is set correctly. While
                // browsers typically do this as necessary, jsdom doesn't.
                var newValue = toString(getToStringValue(value)); // To avoid side effects (such as losing text selection), only set value if changed
                if (newValue !== node.value) {
                    node.value = newValue;
                } // TOOO: This should respect disableInputAttributeSyncing flag.
                if (defaultValue == null) {
                    if (node.defaultValue !== newValue) {
                        node.defaultValue = newValue;
                    }
                    return;
                }
            }
            if (defaultValue != null) {
                node.defaultValue = toString(getToStringValue(defaultValue));
            } else {
                node.defaultValue = '';
            }
        }
        function initTextarea(element, value, defaultValue, children) {
            var node = element;
            var initialValue = value; // Only bother fetching default value if we're going to use it
            if (initialValue == null) {
                if (children != null) {
                    {
                        if (defaultValue != null) {
                            throw new Error('If you supply `defaultValue` on a <textarea>, do not pass children.');
                        }
                        if (isArray(children)) {
                            if (children.length > 1) {
                                throw new Error('<textarea> can only have at most one child.');
                            }
                            children = children[0];
                        }
                        defaultValue = children;
                    }
                }
                if (defaultValue == null) {
                    defaultValue = '';
                }
                initialValue = defaultValue;
            }
            var stringValue = getToStringValue(initialValue);
            node.defaultValue = stringValue; // This will be toString:ed.
            // This is in postMount because we need access to the DOM node, which is not
            // available until after the component has mounted.
            var textContent = node.textContent; // Only set node.value if textContent is equal to the expected
            // initial value. In IE10/IE11 there is a bug where the placeholder attribute
            // will populate textContent as well.
            // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
            if (textContent === stringValue) {
                if (textContent !== '' && textContent !== null) {
                    node.value = textContent;
                }
            }
        }
        function restoreControlledTextareaState(element, props) {
            // DOM component is still mounted; update
            updateTextarea(element, props.value, props.defaultValue);
        }
        // This validation code was written based on the HTML5 parsing spec:
        // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
        //
        // Note: this does not catch all invalid nesting, nor does it try to (as it's
        // not clear what practical benefit doing so provides); instead, we warn only
        // for cases where the parser will give a parse tree differing from what React
        // intended. For example, <b><div></div></b> is invalid but we don't warn
        // because it still parses correctly; we do warn for other cases like nested
        // <p> tags where the beginning of the second element implicitly closes the
        // first, causing a confusing mess.
        // https://html.spec.whatwg.org/multipage/syntax.html#special
        var specialTags = [
            'address',
            'applet',
            'area',
            'article',
            'aside',
            'base',
            'basefont',
            'bgsound',
            'blockquote',
            'body',
            'br',
            'button',
            'caption',
            'center',
            'col',
            'colgroup',
            'dd',
            'details',
            'dir',
            'div',
            'dl',
            'dt',
            'embed',
            'fieldset',
            'figcaption',
            'figure',
            'footer',
            'form',
            'frame',
            'frameset',
            'h1',
            'h2',
            'h3',
            'h4',
            'h5',
            'h6',
            'head',
            'header',
            'hgroup',
            'hr',
            'html',
            'iframe',
            'img',
            'input',
            'isindex',
            'li',
            'link',
            'listing',
            'main',
            'marquee',
            'menu',
            'menuitem',
            'meta',
            'nav',
            'noembed',
            'noframes',
            'noscript',
            'object',
            'ol',
            'p',
            'param',
            'plaintext',
            'pre',
            'script',
            'section',
            'select',
            'source',
            'style',
            'summary',
            'table',
            'tbody',
            'td',
            'template',
            'textarea',
            'tfoot',
            'th',
            'thead',
            'title',
            'tr',
            'track',
            'ul',
            'wbr',
            'xmp'
        ]; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
        var inScopeTags = [
            'applet',
            'caption',
            'html',
            'table',
            'td',
            'th',
            'marquee',
            'object',
            'template',
            // TODO: Distinguish by namespace here -- for <title>, including it here
            // errs on the side of fewer warnings
            'foreignObject',
            'desc',
            'title'
        ]; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
        var buttonScopeTags = inScopeTags.concat([
            'button'
        ]); // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
        var impliedEndTags = [
            'dd',
            'dt',
            'li',
            'option',
            'optgroup',
            'p',
            'rp',
            'rt'
        ];
        var emptyAncestorInfoDev = {
            current: null,
            formTag: null,
            aTagInScope: null,
            buttonTagInScope: null,
            nobrTagInScope: null,
            pTagInButtonScope: null,
            listItemTagAutoclosing: null,
            dlItemTagAutoclosing: null,
            containerTagInScope: null
        };
        function updatedAncestorInfoDev(oldInfo, tag) {
            {
                var ancestorInfo = assign({}, oldInfo || emptyAncestorInfoDev);
                var info = {
                    tag: tag
                };
                if (inScopeTags.indexOf(tag) !== -1) {
                    ancestorInfo.aTagInScope = null;
                    ancestorInfo.buttonTagInScope = null;
                    ancestorInfo.nobrTagInScope = null;
                }
                if (buttonScopeTags.indexOf(tag) !== -1) {
                    ancestorInfo.pTagInButtonScope = null;
                } // See rules for 'li', 'dd', 'dt' start tags in
                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
                if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
                    ancestorInfo.listItemTagAutoclosing = null;
                    ancestorInfo.dlItemTagAutoclosing = null;
                }
                ancestorInfo.current = info;
                if (tag === 'form') {
                    ancestorInfo.formTag = info;
                }
                if (tag === 'a') {
                    ancestorInfo.aTagInScope = info;
                }
                if (tag === 'button') {
                    ancestorInfo.buttonTagInScope = info;
                }
                if (tag === 'nobr') {
                    ancestorInfo.nobrTagInScope = info;
                }
                if (tag === 'p') {
                    ancestorInfo.pTagInButtonScope = info;
                }
                if (tag === 'li') {
                    ancestorInfo.listItemTagAutoclosing = info;
                }
                if (tag === 'dd' || tag === 'dt') {
                    ancestorInfo.dlItemTagAutoclosing = info;
                }
                if (tag === '#document' || tag === 'html') {
                    ancestorInfo.containerTagInScope = null;
                } else if (!ancestorInfo.containerTagInScope) {
                    ancestorInfo.containerTagInScope = info;
                }
                return ancestorInfo;
            }
        }
        /**
 * Returns whether
 */ function isTagValidWithParent(tag, parentTag) {
            // First, let's check if we're in an unusual parsing mode...
            switch(parentTag){
                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
                case 'select':
                    return tag === 'hr' || tag === 'option' || tag === 'optgroup' || tag === '#text';
                case 'optgroup':
                    return tag === 'option' || tag === '#text';
                // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
                // but
                case 'option':
                    return tag === '#text';
                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
                // No special behavior since these rules fall back to "in body" mode for
                // all except special table nodes which cause bad parsing behavior anyway.
                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
                case 'tr':
                    return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
                case 'tbody':
                case 'thead':
                case 'tfoot':
                    return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
                case 'colgroup':
                    return tag === 'col' || tag === 'template';
                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
                case 'table':
                    return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
                case 'head':
                    return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
                // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
                case 'html':
                    return tag === 'head' || tag === 'body' || tag === 'frameset';
                case 'frameset':
                    return tag === 'frame';
                case '#document':
                    return tag === 'html';
            } // Probably in the "in body" parsing mode, so we outlaw only tag combos
            // where the parsing rules cause implicit opens or closes to be added.
            // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
            switch(tag){
                case 'h1':
                case 'h2':
                case 'h3':
                case 'h4':
                case 'h5':
                case 'h6':
                    return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
                case 'rp':
                case 'rt':
                    return impliedEndTags.indexOf(parentTag) === -1;
                case 'body':
                case 'caption':
                case 'col':
                case 'colgroup':
                case 'frameset':
                case 'frame':
                case 'head':
                case 'html':
                case 'tbody':
                case 'td':
                case 'tfoot':
                case 'th':
                case 'thead':
                case 'tr':
                    // These tags are only valid with a few parents that have special child
                    // parsing rules -- if we're down here, then none of those matched and
                    // so we allow it only if we don't know what the parent is, as all other
                    // cases are invalid.
                    return parentTag == null;
            }
            return true;
        }
        /**
 * Returns whether
 */ function findInvalidAncestorForTag(tag, ancestorInfo) {
            switch(tag){
                case 'address':
                case 'article':
                case 'aside':
                case 'blockquote':
                case 'center':
                case 'details':
                case 'dialog':
                case 'dir':
                case 'div':
                case 'dl':
                case 'fieldset':
                case 'figcaption':
                case 'figure':
                case 'footer':
                case 'header':
                case 'hgroup':
                case 'main':
                case 'menu':
                case 'nav':
                case 'ol':
                case 'p':
                case 'section':
                case 'summary':
                case 'ul':
                case 'pre':
                case 'listing':
                case 'table':
                case 'hr':
                case 'xmp':
                case 'h1':
                case 'h2':
                case 'h3':
                case 'h4':
                case 'h5':
                case 'h6':
                    return ancestorInfo.pTagInButtonScope;
                case 'form':
                    return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
                case 'li':
                    return ancestorInfo.listItemTagAutoclosing;
                case 'dd':
                case 'dt':
                    return ancestorInfo.dlItemTagAutoclosing;
                case 'button':
                    return ancestorInfo.buttonTagInScope;
                case 'a':
                    // Spec says something about storing a list of markers, but it sounds
                    // equivalent to this check.
                    return ancestorInfo.aTagInScope;
                case 'nobr':
                    return ancestorInfo.nobrTagInScope;
            }
            return null;
        }
        var didWarn$1 = {};
        function validateDOMNesting(childTag, ancestorInfo) {
            {
                ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
                var parentInfo = ancestorInfo.current;
                var parentTag = parentInfo && parentInfo.tag;
                var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
                var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
                var invalidParentOrAncestor = invalidParent || invalidAncestor;
                if (!invalidParentOrAncestor) {
                    return true;
                }
                var ancestorTag = invalidParentOrAncestor.tag;
                var warnKey = String(!!invalidParent) + '|' + childTag + '|' + ancestorTag;
                if (didWarn$1[warnKey]) {
                    return false;
                }
                didWarn$1[warnKey] = true;
                var tagDisplayName = '<' + childTag + '>';
                if (invalidParent) {
                    var info = '';
                    if (ancestorTag === 'table' && childTag === 'tr') {
                        info += ' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by ' + 'the browser.';
                    }
                    error('In HTML, %s cannot be a child of <%s>.%s\n' + 'This will cause a hydration error.', tagDisplayName, ancestorTag, info);
                } else {
                    error('In HTML, %s cannot be a descendant of <%s>.\n' + 'This will cause a hydration error.', tagDisplayName, ancestorTag);
                }
                return false;
            }
        }
        function validateTextNesting(childText, parentTag) {
            {
                if (isTagValidWithParent('#text', parentTag)) {
                    return true;
                } // eslint-disable-next-line react-internal/safe-string-coercion
                var warnKey = '#text|' + parentTag;
                if (didWarn$1[warnKey]) {
                    return false;
                }
                didWarn$1[warnKey] = true;
                if (/\S/.test(childText)) {
                    error('In HTML, text nodes cannot be a child of <%s>.\n' + 'This will cause a hydration error.', parentTag);
                } else {
                    error('In HTML, whitespace text nodes cannot be a child of <%s>. ' + "Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.\n' + 'This will cause a hydration error.', parentTag);
                }
                return false;
            }
        }
        var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
        var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
        var reusableSVGContainer;
        function setInnerHTMLImpl(node, html) {
            if (node.namespaceURI === SVG_NAMESPACE) {
                if (!('innerHTML' in node)) {
                    // IE does not have innerHTML for SVG nodes, so instead we inject the
                    // new markup in a temp node and then move the child nodes across into
                    // the target node
                    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
                    reusableSVGContainer.innerHTML = '<svg>' + html.valueOf().toString() + '</svg>';
                    var svgNode = reusableSVGContainer.firstChild;
                    while(node.firstChild){
                        node.removeChild(node.firstChild);
                    } // $FlowFixMe[incompatible-use]
                    // $FlowFixMe[incompatible-type]
                    while(svgNode.firstChild){
                        node.appendChild(svgNode.firstChild);
                    }
                    return;
                }
            }
            node.innerHTML = html;
        }
        var setInnerHTML = setInnerHTMLImpl; // $FlowFixMe[cannot-resolve-name]
        if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
            /**
   * Create a function which has 'unsafe' privileges (required by windows8 apps)
   */ setInnerHTML = function(node, html) {
                // $FlowFixMe[cannot-resolve-name]
                return MSApp.execUnsafeLocalFunction(function() {
                    return setInnerHTMLImpl(node, html);
                });
            };
        }
        var setInnerHTML$1 = setInnerHTML;
        /**
 * HTML nodeType values that represent the type of the node
 */ var ELEMENT_NODE = 1;
        var TEXT_NODE = 3;
        var COMMENT_NODE = 8;
        var DOCUMENT_NODE = 9;
        var DOCUMENT_TYPE_NODE = 10;
        var DOCUMENT_FRAGMENT_NODE = 11;
        /**
 * Set the textContent property of a node. For text updates, it's faster
 * to set the `nodeValue` of the Text node directly instead of using
 * `.textContent` which will remove the existing node and create a new one.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */ function setTextContent(node, text) {
            if (text) {
                var firstChild = node.firstChild;
                if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
                    firstChild.nodeValue = text;
                    return;
                }
            }
            node.textContent = text;
        }
        // List derived from Gecko source code:
        // https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js
        var shorthandToLonghand = {
            animation: [
                'animationDelay',
                'animationDirection',
                'animationDuration',
                'animationFillMode',
                'animationIterationCount',
                'animationName',
                'animationPlayState',
                'animationTimingFunction'
            ],
            background: [
                'backgroundAttachment',
                'backgroundClip',
                'backgroundColor',
                'backgroundImage',
                'backgroundOrigin',
                'backgroundPositionX',
                'backgroundPositionY',
                'backgroundRepeat',
                'backgroundSize'
            ],
            backgroundPosition: [
                'backgroundPositionX',
                'backgroundPositionY'
            ],
            border: [
                'borderBottomColor',
                'borderBottomStyle',
                'borderBottomWidth',
                'borderImageOutset',
                'borderImageRepeat',
                'borderImageSlice',
                'borderImageSource',
                'borderImageWidth',
                'borderLeftColor',
                'borderLeftStyle',
                'borderLeftWidth',
                'borderRightColor',
                'borderRightStyle',
                'borderRightWidth',
                'borderTopColor',
                'borderTopStyle',
                'borderTopWidth'
            ],
            borderBlockEnd: [
                'borderBlockEndColor',
                'borderBlockEndStyle',
                'borderBlockEndWidth'
            ],
            borderBlockStart: [
                'borderBlockStartColor',
                'borderBlockStartStyle',
                'borderBlockStartWidth'
            ],
            borderBottom: [
                'borderBottomColor',
                'borderBottomStyle',
                'borderBottomWidth'
            ],
            borderColor: [
                'borderBottomColor',
                'borderLeftColor',
                'borderRightColor',
                'borderTopColor'
            ],
            borderImage: [
                'borderImageOutset',
                'borderImageRepeat',
                'borderImageSlice',
                'borderImageSource',
                'borderImageWidth'
            ],
            borderInlineEnd: [
                'borderInlineEndColor',
                'borderInlineEndStyle',
                'borderInlineEndWidth'
            ],
            borderInlineStart: [
                'borderInlineStartColor',
                'borderInlineStartStyle',
                'borderInlineStartWidth'
            ],
            borderLeft: [
                'borderLeftColor',
                'borderLeftStyle',
                'borderLeftWidth'
            ],
            borderRadius: [
                'borderBottomLeftRadius',
                'borderBottomRightRadius',
                'borderTopLeftRadius',
                'borderTopRightRadius'
            ],
            borderRight: [
                'borderRightColor',
                'borderRightStyle',
                'borderRightWidth'
            ],
            borderStyle: [
                'borderBottomStyle',
                'borderLeftStyle',
                'borderRightStyle',
                'borderTopStyle'
            ],
            borderTop: [
                'borderTopColor',
                'borderTopStyle',
                'borderTopWidth'
            ],
            borderWidth: [
                'borderBottomWidth',
                'borderLeftWidth',
                'borderRightWidth',
                'borderTopWidth'
            ],
            columnRule: [
                'columnRuleColor',
                'columnRuleStyle',
                'columnRuleWidth'
            ],
            columns: [
                'columnCount',
                'columnWidth'
            ],
            flex: [
                'flexBasis',
                'flexGrow',
                'flexShrink'
            ],
            flexFlow: [
                'flexDirection',
                'flexWrap'
            ],
            font: [
                'fontFamily',
                'fontFeatureSettings',
                'fontKerning',
                'fontLanguageOverride',
                'fontSize',
                'fontSizeAdjust',
                'fontStretch',
                'fontStyle',
                'fontVariant',
                'fontVariantAlternates',
                'fontVariantCaps',
                'fontVariantEastAsian',
                'fontVariantLigatures',
                'fontVariantNumeric',
                'fontVariantPosition',
                'fontWeight',
                'lineHeight'
            ],
            fontVariant: [
                'fontVariantAlternates',
                'fontVariantCaps',
                'fontVariantEastAsian',
                'fontVariantLigatures',
                'fontVariantNumeric',
                'fontVariantPosition'
            ],
            gap: [
                'columnGap',
                'rowGap'
            ],
            grid: [
                'gridAutoColumns',
                'gridAutoFlow',
                'gridAutoRows',
                'gridTemplateAreas',
                'gridTemplateColumns',
                'gridTemplateRows'
            ],
            gridArea: [
                'gridColumnEnd',
                'gridColumnStart',
                'gridRowEnd',
                'gridRowStart'
            ],
            gridColumn: [
                'gridColumnEnd',
                'gridColumnStart'
            ],
            gridColumnGap: [
                'columnGap'
            ],
            gridGap: [
                'columnGap',
                'rowGap'
            ],
            gridRow: [
                'gridRowEnd',
                'gridRowStart'
            ],
            gridRowGap: [
                'rowGap'
            ],
            gridTemplate: [
                'gridTemplateAreas',
                'gridTemplateColumns',
                'gridTemplateRows'
            ],
            listStyle: [
                'listStyleImage',
                'listStylePosition',
                'listStyleType'
            ],
            margin: [
                'marginBottom',
                'marginLeft',
                'marginRight',
                'marginTop'
            ],
            marker: [
                'markerEnd',
                'markerMid',
                'markerStart'
            ],
            mask: [
                'maskClip',
                'maskComposite',
                'maskImage',
                'maskMode',
                'maskOrigin',
                'maskPositionX',
                'maskPositionY',
                'maskRepeat',
                'maskSize'
            ],
            maskPosition: [
                'maskPositionX',
                'maskPositionY'
            ],
            outline: [
                'outlineColor',
                'outlineStyle',
                'outlineWidth'
            ],
            overflow: [
                'overflowX',
                'overflowY'
            ],
            padding: [
                'paddingBottom',
                'paddingLeft',
                'paddingRight',
                'paddingTop'
            ],
            placeContent: [
                'alignContent',
                'justifyContent'
            ],
            placeItems: [
                'alignItems',
                'justifyItems'
            ],
            placeSelf: [
                'alignSelf',
                'justifySelf'
            ],
            textDecoration: [
                'textDecorationColor',
                'textDecorationLine',
                'textDecorationStyle'
            ],
            textEmphasis: [
                'textEmphasisColor',
                'textEmphasisStyle'
            ],
            transition: [
                'transitionDelay',
                'transitionDuration',
                'transitionProperty',
                'transitionTimingFunction'
            ],
            wordWrap: [
                'overflowWrap'
            ]
        };
        var uppercasePattern = /([A-Z])/g;
        var msPattern$1 = /^ms-/;
        /**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 */ function hyphenateStyleName(name) {
            return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern$1, '-ms-');
        }
        // 'msTransform' is correct, but the other prefixes should be capitalized
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
        var msPattern = /^-ms-/;
        var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon
        var badStyleValueWithSemicolonPattern = /;\s*$/;
        var warnedStyleNames = {};
        var warnedStyleValues = {};
        var warnedForNaNValue = false;
        var warnedForInfinityValue = false;
        function camelize(string) {
            return string.replace(hyphenPattern, function(_, character) {
                return character.toUpperCase();
            });
        }
        function warnHyphenatedStyleName(name) {
            {
                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                    return;
                }
                warnedStyleNames[name] = true;
                error('Unsupported style property %s. Did you mean %s?', name, // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
                // is converted to lowercase `ms`.
                camelize(name.replace(msPattern, 'ms-')));
            }
        }
        function warnBadVendoredStyleName(name) {
            {
                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                    return;
                }
                warnedStyleNames[name] = true;
                error('Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1));
            }
        }
        function warnStyleValueWithSemicolon(name, value) {
            {
                if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
                    return;
                }
                warnedStyleValues[value] = true;
                error("Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, ''));
            }
        }
        function warnStyleValueIsNaN(name, value) {
            {
                if (warnedForNaNValue) {
                    return;
                }
                warnedForNaNValue = true;
                error('`NaN` is an invalid value for the `%s` css style property.', name);
            }
        }
        function warnStyleValueIsInfinity(name, value) {
            {
                if (warnedForInfinityValue) {
                    return;
                }
                warnedForInfinityValue = true;
                error('`Infinity` is an invalid value for the `%s` css style property.', name);
            }
        }
        function warnValidStyle(name, value) {
            {
                if (name.indexOf('-') > -1) {
                    warnHyphenatedStyleName(name);
                } else if (badVendoredStyleNamePattern.test(name)) {
                    warnBadVendoredStyleName(name);
                } else if (badStyleValueWithSemicolonPattern.test(value)) {
                    warnStyleValueWithSemicolon(name, value);
                }
                if (typeof value === 'number') {
                    if (isNaN(value)) {
                        warnStyleValueIsNaN(name);
                    } else if (!isFinite(value)) {
                        warnStyleValueIsInfinity(name);
                    }
                }
            }
        }
        /**
 * CSS properties which accept numbers but are not in units of "px".
 */ var unitlessNumbers = new Set([
            'animationIterationCount',
            'aspectRatio',
            'borderImageOutset',
            'borderImageSlice',
            'borderImageWidth',
            'boxFlex',
            'boxFlexGroup',
            'boxOrdinalGroup',
            'columnCount',
            'columns',
            'flex',
            'flexGrow',
            'flexPositive',
            'flexShrink',
            'flexNegative',
            'flexOrder',
            'gridArea',
            'gridRow',
            'gridRowEnd',
            'gridRowSpan',
            'gridRowStart',
            'gridColumn',
            'gridColumnEnd',
            'gridColumnSpan',
            'gridColumnStart',
            'fontWeight',
            'lineClamp',
            'lineHeight',
            'opacity',
            'order',
            'orphans',
            'scale',
            'tabSize',
            'widows',
            'zIndex',
            'zoom',
            'fillOpacity',
            'floodOpacity',
            'stopOpacity',
            'strokeDasharray',
            'strokeDashoffset',
            'strokeMiterlimit',
            'strokeOpacity',
            'strokeWidth',
            'MozAnimationIterationCount',
            'MozBoxFlex',
            'MozBoxFlexGroup',
            'MozLineClamp',
            'msAnimationIterationCount',
            'msFlex',
            'msZoom',
            'msFlexGrow',
            'msFlexNegative',
            'msFlexOrder',
            'msFlexPositive',
            'msFlexShrink',
            'msGridColumn',
            'msGridColumnSpan',
            'msGridRow',
            'msGridRowSpan',
            'WebkitAnimationIterationCount',
            'WebkitBoxFlex',
            'WebKitBoxFlexGroup',
            'WebkitBoxOrdinalGroup',
            'WebkitColumnCount',
            'WebkitColumns',
            'WebkitFlex',
            'WebkitFlexGrow',
            'WebkitFlexPositive',
            'WebkitFlexShrink',
            'WebkitLineClamp'
        ]);
        function isUnitlessNumber(name) {
            return unitlessNumbers.has(name);
        }
        /**
 * Operations for dealing with CSS properties.
 */ /**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */ function createDangerousStringForStyles(styles) {
            {
                var serialized = '';
                var delimiter = '';
                for(var styleName in styles){
                    if (!styles.hasOwnProperty(styleName)) {
                        continue;
                    }
                    var value = styles[styleName];
                    if (value != null && typeof value !== 'boolean' && value !== '') {
                        var isCustomProperty = styleName.indexOf('--') === 0;
                        if (isCustomProperty) {
                            {
                                checkCSSPropertyStringCoercion(value, styleName);
                            }
                            serialized += delimiter + styleName + ':' + ('' + value).trim();
                        } else {
                            if (typeof value === 'number' && value !== 0 && !isUnitlessNumber(styleName)) {
                                serialized += delimiter + hyphenateStyleName(styleName) + ':' + value + 'px';
                            } else {
                                {
                                    checkCSSPropertyStringCoercion(value, styleName);
                                }
                                serialized += delimiter + hyphenateStyleName(styleName) + ':' + ('' + value).trim();
                            }
                        }
                        delimiter = ';';
                    }
                }
                return serialized || null;
            }
        }
        function setValueForStyle(style, styleName, value) {
            var isCustomProperty = styleName.indexOf('--') === 0;
            {
                if (!isCustomProperty) {
                    warnValidStyle(styleName, value);
                }
            }
            if (value == null || typeof value === 'boolean' || value === '') {
                if (isCustomProperty) {
                    style.setProperty(styleName, '');
                } else if (styleName === 'float') {
                    style.cssFloat = '';
                } else {
                    style[styleName] = '';
                }
            } else if (isCustomProperty) {
                style.setProperty(styleName, value);
            } else if (typeof value === 'number' && value !== 0 && !isUnitlessNumber(styleName)) {
                style[styleName] = value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
            } else {
                if (styleName === 'float') {
                    style.cssFloat = value;
                } else {
                    {
                        checkCSSPropertyStringCoercion(value, styleName);
                    }
                    style[styleName] = ('' + value).trim();
                }
            }
        }
        /**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */ function setValueForStyles(node, styles, prevStyles) {
            if (styles != null && typeof styles !== 'object') {
                throw new Error('The `style` prop expects a mapping from style properties to values, ' + "not a string. For example, style={{marginRight: spacing + 'em'}} when " + 'using JSX.');
            }
            {
                if (styles) {
                    // Freeze the next style object so that we can assume it won't be
                    // mutated. We have already warned for this in the past.
                    Object.freeze(styles);
                }
            }
            var style = node.style;
            if (prevStyles != null) {
                {
                    validateShorthandPropertyCollisionInDev(prevStyles, styles);
                }
                for(var styleName in prevStyles){
                    if (prevStyles.hasOwnProperty(styleName) && (styles == null || !styles.hasOwnProperty(styleName))) {
                        // Clear style
                        var isCustomProperty = styleName.indexOf('--') === 0;
                        if (isCustomProperty) {
                            style.setProperty(styleName, '');
                        } else if (styleName === 'float') {
                            style.cssFloat = '';
                        } else {
                            style[styleName] = '';
                        }
                    }
                }
                for(var _styleName in styles){
                    var value = styles[_styleName];
                    if (styles.hasOwnProperty(_styleName) && prevStyles[_styleName] !== value) {
                        setValueForStyle(style, _styleName, value);
                    }
                }
            } else {
                for(var _styleName2 in styles){
                    if (styles.hasOwnProperty(_styleName2)) {
                        var _value = styles[_styleName2];
                        setValueForStyle(style, _styleName2, _value);
                    }
                }
            }
        }
        function isValueEmpty(value) {
            return value == null || typeof value === 'boolean' || value === '';
        }
        /**
 * Given {color: 'red', overflow: 'hidden'} returns {
 *   color: 'color',
 *   overflowX: 'overflow',
 *   overflowY: 'overflow',
 * }. This can be read as "the overflowY property was set by the overflow
 * shorthand". That is, the values are the property that each was derived from.
 */ function expandShorthandMap(styles) {
            var expanded = {};
            for(var key in styles){
                var longhands = shorthandToLonghand[key] || [
                    key
                ];
                for(var i = 0; i < longhands.length; i++){
                    expanded[longhands[i]] = key;
                }
            }
            return expanded;
        }
        /**
 * When mixing shorthand and longhand property names, we warn during updates if
 * we expect an incorrect result to occur. In particular, we warn for:
 *
 * Updating a shorthand property (longhand gets overwritten):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}
 *   becomes .style.font = 'baz'
 * Removing a shorthand property (longhand gets lost too):
 *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}
 *   becomes .style.font = ''
 * Removing a longhand property (should revert to shorthand; doesn't):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}
 *   becomes .style.fontVariant = ''
 */ function validateShorthandPropertyCollisionInDev(prevStyles, nextStyles) {
            {
                if (!nextStyles) {
                    return;
                } // Compute the diff as it would happen elsewhere.
                var expandedUpdates = {};
                if (prevStyles) {
                    for(var key in prevStyles){
                        if (prevStyles.hasOwnProperty(key) && !nextStyles.hasOwnProperty(key)) {
                            var longhands = shorthandToLonghand[key] || [
                                key
                            ];
                            for(var i = 0; i < longhands.length; i++){
                                expandedUpdates[longhands[i]] = key;
                            }
                        }
                    }
                }
                for(var _key in nextStyles){
                    if (nextStyles.hasOwnProperty(_key) && (!prevStyles || prevStyles[_key] !== nextStyles[_key])) {
                        var _longhands = shorthandToLonghand[_key] || [
                            _key
                        ];
                        for(var _i = 0; _i < _longhands.length; _i++){
                            expandedUpdates[_longhands[_i]] = _key;
                        }
                    }
                }
                var expandedStyles = expandShorthandMap(nextStyles);
                var warnedAbout = {};
                for(var _key2 in expandedUpdates){
                    var originalKey = expandedUpdates[_key2];
                    var correctOriginalKey = expandedStyles[_key2];
                    if (correctOriginalKey && originalKey !== correctOriginalKey) {
                        var warningKey = originalKey + ',' + correctOriginalKey;
                        if (warnedAbout[warningKey]) {
                            continue;
                        }
                        warnedAbout[warningKey] = true;
                        error('%s a style property during rerender (%s) when a ' + 'conflicting property is set (%s) can lead to styling bugs. To ' + "avoid this, don't mix shorthand and non-shorthand properties " + 'for the same value; instead, replace the shorthand with ' + 'separate values.', isValueEmpty(nextStyles[originalKey]) ? 'Removing' : 'Updating', originalKey, correctOriginalKey);
                    }
                }
            }
        }
        function isCustomElement(tagName, props) {
            if (tagName.indexOf('-') === -1) {
                return false;
            }
            switch(tagName){
                // These are reserved SVG and MathML elements.
                // We don't mind this list too much because we expect it to never grow.
                // The alternative is to track the namespace in a few places which is convoluted.
                // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
                case 'annotation-xml':
                case 'color-profile':
                case 'font-face':
                case 'font-face-src':
                case 'font-face-uri':
                case 'font-face-format':
                case 'font-face-name':
                case 'missing-glyph':
                    return false;
                default:
                    return true;
            }
        }
        var aliases = new Map([
            [
                'acceptCharset',
                'accept-charset'
            ],
            [
                'htmlFor',
                'for'
            ],
            [
                'httpEquiv',
                'http-equiv'
            ],
            [
                'crossOrigin',
                'crossorigin'
            ],
            // Regular attributes that just accept strings.],
            [
                'accentHeight',
                'accent-height'
            ],
            [
                'alignmentBaseline',
                'alignment-baseline'
            ],
            [
                'arabicForm',
                'arabic-form'
            ],
            [
                'baselineShift',
                'baseline-shift'
            ],
            [
                'capHeight',
                'cap-height'
            ],
            [
                'clipPath',
                'clip-path'
            ],
            [
                'clipRule',
                'clip-rule'
            ],
            [
                'colorInterpolation',
                'color-interpolation'
            ],
            [
                'colorInterpolationFilters',
                'color-interpolation-filters'
            ],
            [
                'colorProfile',
                'color-profile'
            ],
            [
                'colorRendering',
                'color-rendering'
            ],
            [
                'dominantBaseline',
                'dominant-baseline'
            ],
            [
                'enableBackground',
                'enable-background'
            ],
            [
                'fillOpacity',
                'fill-opacity'
            ],
            [
                'fillRule',
                'fill-rule'
            ],
            [
                'floodColor',
                'flood-color'
            ],
            [
                'floodOpacity',
                'flood-opacity'
            ],
            [
                'fontFamily',
                'font-family'
            ],
            [
                'fontSize',
                'font-size'
            ],
            [
                'fontSizeAdjust',
                'font-size-adjust'
            ],
            [
                'fontStretch',
                'font-stretch'
            ],
            [
                'fontStyle',
                'font-style'
            ],
            [
                'fontVariant',
                'font-variant'
            ],
            [
                'fontWeight',
                'font-weight'
            ],
            [
                'glyphName',
                'glyph-name'
            ],
            [
                'glyphOrientationHorizontal',
                'glyph-orientation-horizontal'
            ],
            [
                'glyphOrientationVertical',
                'glyph-orientation-vertical'
            ],
            [
                'horizAdvX',
                'horiz-adv-x'
            ],
            [
                'horizOriginX',
                'horiz-origin-x'
            ],
            [
                'imageRendering',
                'image-rendering'
            ],
            [
                'letterSpacing',
                'letter-spacing'
            ],
            [
                'lightingColor',
                'lighting-color'
            ],
            [
                'markerEnd',
                'marker-end'
            ],
            [
                'markerMid',
                'marker-mid'
            ],
            [
                'markerStart',
                'marker-start'
            ],
            [
                'overlinePosition',
                'overline-position'
            ],
            [
                'overlineThickness',
                'overline-thickness'
            ],
            [
                'paintOrder',
                'paint-order'
            ],
            [
                'panose-1',
                'panose-1'
            ],
            [
                'pointerEvents',
                'pointer-events'
            ],
            [
                'renderingIntent',
                'rendering-intent'
            ],
            [
                'shapeRendering',
                'shape-rendering'
            ],
            [
                'stopColor',
                'stop-color'
            ],
            [
                'stopOpacity',
                'stop-opacity'
            ],
            [
                'strikethroughPosition',
                'strikethrough-position'
            ],
            [
                'strikethroughThickness',
                'strikethrough-thickness'
            ],
            [
                'strokeDasharray',
                'stroke-dasharray'
            ],
            [
                'strokeDashoffset',
                'stroke-dashoffset'
            ],
            [
                'strokeLinecap',
                'stroke-linecap'
            ],
            [
                'strokeLinejoin',
                'stroke-linejoin'
            ],
            [
                'strokeMiterlimit',
                'stroke-miterlimit'
            ],
            [
                'strokeOpacity',
                'stroke-opacity'
            ],
            [
                'strokeWidth',
                'stroke-width'
            ],
            [
                'textAnchor',
                'text-anchor'
            ],
            [
                'textDecoration',
                'text-decoration'
            ],
            [
                'textRendering',
                'text-rendering'
            ],
            [
                'transformOrigin',
                'transform-origin'
            ],
            [
                'underlinePosition',
                'underline-position'
            ],
            [
                'underlineThickness',
                'underline-thickness'
            ],
            [
                'unicodeBidi',
                'unicode-bidi'
            ],
            [
                'unicodeRange',
                'unicode-range'
            ],
            [
                'unitsPerEm',
                'units-per-em'
            ],
            [
                'vAlphabetic',
                'v-alphabetic'
            ],
            [
                'vHanging',
                'v-hanging'
            ],
            [
                'vIdeographic',
                'v-ideographic'
            ],
            [
                'vMathematical',
                'v-mathematical'
            ],
            [
                'vectorEffect',
                'vector-effect'
            ],
            [
                'vertAdvY',
                'vert-adv-y'
            ],
            [
                'vertOriginX',
                'vert-origin-x'
            ],
            [
                'vertOriginY',
                'vert-origin-y'
            ],
            [
                'wordSpacing',
                'word-spacing'
            ],
            [
                'writingMode',
                'writing-mode'
            ],
            [
                'xmlnsXlink',
                'xmlns:xlink'
            ],
            [
                'xHeight',
                'x-height'
            ]
        ]);
        function getAttributeAlias(name) {
            return aliases.get(name) || name;
        }
        // When adding attributes to the HTML or SVG allowed attribute list, be sure to
        // also add them to this module to ensure casing and incorrect name
        // warnings.
        var possibleStandardNames = {
            // HTML
            accept: 'accept',
            acceptcharset: 'acceptCharset',
            'accept-charset': 'acceptCharset',
            accesskey: 'accessKey',
            action: 'action',
            allowfullscreen: 'allowFullScreen',
            alt: 'alt',
            as: 'as',
            async: 'async',
            autocapitalize: 'autoCapitalize',
            autocomplete: 'autoComplete',
            autocorrect: 'autoCorrect',
            autofocus: 'autoFocus',
            autoplay: 'autoPlay',
            autosave: 'autoSave',
            capture: 'capture',
            cellpadding: 'cellPadding',
            cellspacing: 'cellSpacing',
            challenge: 'challenge',
            charset: 'charSet',
            checked: 'checked',
            children: 'children',
            cite: 'cite',
            class: 'className',
            classid: 'classID',
            classname: 'className',
            cols: 'cols',
            colspan: 'colSpan',
            content: 'content',
            contenteditable: 'contentEditable',
            contextmenu: 'contextMenu',
            controls: 'controls',
            controlslist: 'controlsList',
            coords: 'coords',
            crossorigin: 'crossOrigin',
            dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
            data: 'data',
            datetime: 'dateTime',
            default: 'default',
            defaultchecked: 'defaultChecked',
            defaultvalue: 'defaultValue',
            defer: 'defer',
            dir: 'dir',
            disabled: 'disabled',
            disablepictureinpicture: 'disablePictureInPicture',
            disableremoteplayback: 'disableRemotePlayback',
            download: 'download',
            draggable: 'draggable',
            enctype: 'encType',
            enterkeyhint: 'enterKeyHint',
            fetchpriority: 'fetchPriority',
            for: 'htmlFor',
            form: 'form',
            formmethod: 'formMethod',
            formaction: 'formAction',
            formenctype: 'formEncType',
            formnovalidate: 'formNoValidate',
            formtarget: 'formTarget',
            frameborder: 'frameBorder',
            headers: 'headers',
            height: 'height',
            hidden: 'hidden',
            high: 'high',
            href: 'href',
            hreflang: 'hrefLang',
            htmlfor: 'htmlFor',
            httpequiv: 'httpEquiv',
            'http-equiv': 'httpEquiv',
            icon: 'icon',
            id: 'id',
            imagesizes: 'imageSizes',
            imagesrcset: 'imageSrcSet',
            innerhtml: 'innerHTML',
            inputmode: 'inputMode',
            integrity: 'integrity',
            is: 'is',
            itemid: 'itemID',
            itemprop: 'itemProp',
            itemref: 'itemRef',
            itemscope: 'itemScope',
            itemtype: 'itemType',
            keyparams: 'keyParams',
            keytype: 'keyType',
            kind: 'kind',
            label: 'label',
            lang: 'lang',
            list: 'list',
            loop: 'loop',
            low: 'low',
            manifest: 'manifest',
            marginwidth: 'marginWidth',
            marginheight: 'marginHeight',
            max: 'max',
            maxlength: 'maxLength',
            media: 'media',
            mediagroup: 'mediaGroup',
            method: 'method',
            min: 'min',
            minlength: 'minLength',
            multiple: 'multiple',
            muted: 'muted',
            name: 'name',
            nomodule: 'noModule',
            nonce: 'nonce',
            novalidate: 'noValidate',
            open: 'open',
            optimum: 'optimum',
            pattern: 'pattern',
            placeholder: 'placeholder',
            playsinline: 'playsInline',
            poster: 'poster',
            preload: 'preload',
            profile: 'profile',
            radiogroup: 'radioGroup',
            readonly: 'readOnly',
            referrerpolicy: 'referrerPolicy',
            rel: 'rel',
            required: 'required',
            reversed: 'reversed',
            role: 'role',
            rows: 'rows',
            rowspan: 'rowSpan',
            sandbox: 'sandbox',
            scope: 'scope',
            scoped: 'scoped',
            scrolling: 'scrolling',
            seamless: 'seamless',
            selected: 'selected',
            shape: 'shape',
            size: 'size',
            sizes: 'sizes',
            span: 'span',
            spellcheck: 'spellCheck',
            src: 'src',
            srcdoc: 'srcDoc',
            srclang: 'srcLang',
            srcset: 'srcSet',
            start: 'start',
            step: 'step',
            style: 'style',
            summary: 'summary',
            tabindex: 'tabIndex',
            target: 'target',
            title: 'title',
            type: 'type',
            usemap: 'useMap',
            value: 'value',
            width: 'width',
            wmode: 'wmode',
            wrap: 'wrap',
            // SVG
            about: 'about',
            accentheight: 'accentHeight',
            'accent-height': 'accentHeight',
            accumulate: 'accumulate',
            additive: 'additive',
            alignmentbaseline: 'alignmentBaseline',
            'alignment-baseline': 'alignmentBaseline',
            allowreorder: 'allowReorder',
            alphabetic: 'alphabetic',
            amplitude: 'amplitude',
            arabicform: 'arabicForm',
            'arabic-form': 'arabicForm',
            ascent: 'ascent',
            attributename: 'attributeName',
            attributetype: 'attributeType',
            autoreverse: 'autoReverse',
            azimuth: 'azimuth',
            basefrequency: 'baseFrequency',
            baselineshift: 'baselineShift',
            'baseline-shift': 'baselineShift',
            baseprofile: 'baseProfile',
            bbox: 'bbox',
            begin: 'begin',
            bias: 'bias',
            by: 'by',
            calcmode: 'calcMode',
            capheight: 'capHeight',
            'cap-height': 'capHeight',
            clip: 'clip',
            clippath: 'clipPath',
            'clip-path': 'clipPath',
            clippathunits: 'clipPathUnits',
            cliprule: 'clipRule',
            'clip-rule': 'clipRule',
            color: 'color',
            colorinterpolation: 'colorInterpolation',
            'color-interpolation': 'colorInterpolation',
            colorinterpolationfilters: 'colorInterpolationFilters',
            'color-interpolation-filters': 'colorInterpolationFilters',
            colorprofile: 'colorProfile',
            'color-profile': 'colorProfile',
            colorrendering: 'colorRendering',
            'color-rendering': 'colorRendering',
            contentscripttype: 'contentScriptType',
            contentstyletype: 'contentStyleType',
            cursor: 'cursor',
            cx: 'cx',
            cy: 'cy',
            d: 'd',
            datatype: 'datatype',
            decelerate: 'decelerate',
            descent: 'descent',
            diffuseconstant: 'diffuseConstant',
            direction: 'direction',
            display: 'display',
            divisor: 'divisor',
            dominantbaseline: 'dominantBaseline',
            'dominant-baseline': 'dominantBaseline',
            dur: 'dur',
            dx: 'dx',
            dy: 'dy',
            edgemode: 'edgeMode',
            elevation: 'elevation',
            enablebackground: 'enableBackground',
            'enable-background': 'enableBackground',
            end: 'end',
            exponent: 'exponent',
            externalresourcesrequired: 'externalResourcesRequired',
            fill: 'fill',
            fillopacity: 'fillOpacity',
            'fill-opacity': 'fillOpacity',
            fillrule: 'fillRule',
            'fill-rule': 'fillRule',
            filter: 'filter',
            filterres: 'filterRes',
            filterunits: 'filterUnits',
            floodopacity: 'floodOpacity',
            'flood-opacity': 'floodOpacity',
            floodcolor: 'floodColor',
            'flood-color': 'floodColor',
            focusable: 'focusable',
            fontfamily: 'fontFamily',
            'font-family': 'fontFamily',
            fontsize: 'fontSize',
            'font-size': 'fontSize',
            fontsizeadjust: 'fontSizeAdjust',
            'font-size-adjust': 'fontSizeAdjust',
            fontstretch: 'fontStretch',
            'font-stretch': 'fontStretch',
            fontstyle: 'fontStyle',
            'font-style': 'fontStyle',
            fontvariant: 'fontVariant',
            'font-variant': 'fontVariant',
            fontweight: 'fontWeight',
            'font-weight': 'fontWeight',
            format: 'format',
            from: 'from',
            fx: 'fx',
            fy: 'fy',
            g1: 'g1',
            g2: 'g2',
            glyphname: 'glyphName',
            'glyph-name': 'glyphName',
            glyphorientationhorizontal: 'glyphOrientationHorizontal',
            'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
            glyphorientationvertical: 'glyphOrientationVertical',
            'glyph-orientation-vertical': 'glyphOrientationVertical',
            glyphref: 'glyphRef',
            gradienttransform: 'gradientTransform',
            gradientunits: 'gradientUnits',
            hanging: 'hanging',
            horizadvx: 'horizAdvX',
            'horiz-adv-x': 'horizAdvX',
            horizoriginx: 'horizOriginX',
            'horiz-origin-x': 'horizOriginX',
            ideographic: 'ideographic',
            imagerendering: 'imageRendering',
            'image-rendering': 'imageRendering',
            in2: 'in2',
            in: 'in',
            inlist: 'inlist',
            intercept: 'intercept',
            k1: 'k1',
            k2: 'k2',
            k3: 'k3',
            k4: 'k4',
            k: 'k',
            kernelmatrix: 'kernelMatrix',
            kernelunitlength: 'kernelUnitLength',
            kerning: 'kerning',
            keypoints: 'keyPoints',
            keysplines: 'keySplines',
            keytimes: 'keyTimes',
            lengthadjust: 'lengthAdjust',
            letterspacing: 'letterSpacing',
            'letter-spacing': 'letterSpacing',
            lightingcolor: 'lightingColor',
            'lighting-color': 'lightingColor',
            limitingconeangle: 'limitingConeAngle',
            local: 'local',
            markerend: 'markerEnd',
            'marker-end': 'markerEnd',
            markerheight: 'markerHeight',
            markermid: 'markerMid',
            'marker-mid': 'markerMid',
            markerstart: 'markerStart',
            'marker-start': 'markerStart',
            markerunits: 'markerUnits',
            markerwidth: 'markerWidth',
            mask: 'mask',
            maskcontentunits: 'maskContentUnits',
            maskunits: 'maskUnits',
            mathematical: 'mathematical',
            mode: 'mode',
            numoctaves: 'numOctaves',
            offset: 'offset',
            opacity: 'opacity',
            operator: 'operator',
            order: 'order',
            orient: 'orient',
            orientation: 'orientation',
            origin: 'origin',
            overflow: 'overflow',
            overlineposition: 'overlinePosition',
            'overline-position': 'overlinePosition',
            overlinethickness: 'overlineThickness',
            'overline-thickness': 'overlineThickness',
            paintorder: 'paintOrder',
            'paint-order': 'paintOrder',
            panose1: 'panose1',
            'panose-1': 'panose1',
            pathlength: 'pathLength',
            patterncontentunits: 'patternContentUnits',
            patterntransform: 'patternTransform',
            patternunits: 'patternUnits',
            pointerevents: 'pointerEvents',
            'pointer-events': 'pointerEvents',
            points: 'points',
            pointsatx: 'pointsAtX',
            pointsaty: 'pointsAtY',
            pointsatz: 'pointsAtZ',
            prefix: 'prefix',
            preservealpha: 'preserveAlpha',
            preserveaspectratio: 'preserveAspectRatio',
            primitiveunits: 'primitiveUnits',
            property: 'property',
            r: 'r',
            radius: 'radius',
            refx: 'refX',
            refy: 'refY',
            renderingintent: 'renderingIntent',
            'rendering-intent': 'renderingIntent',
            repeatcount: 'repeatCount',
            repeatdur: 'repeatDur',
            requiredextensions: 'requiredExtensions',
            requiredfeatures: 'requiredFeatures',
            resource: 'resource',
            restart: 'restart',
            result: 'result',
            results: 'results',
            rotate: 'rotate',
            rx: 'rx',
            ry: 'ry',
            scale: 'scale',
            security: 'security',
            seed: 'seed',
            shaperendering: 'shapeRendering',
            'shape-rendering': 'shapeRendering',
            slope: 'slope',
            spacing: 'spacing',
            specularconstant: 'specularConstant',
            specularexponent: 'specularExponent',
            speed: 'speed',
            spreadmethod: 'spreadMethod',
            startoffset: 'startOffset',
            stddeviation: 'stdDeviation',
            stemh: 'stemh',
            stemv: 'stemv',
            stitchtiles: 'stitchTiles',
            stopcolor: 'stopColor',
            'stop-color': 'stopColor',
            stopopacity: 'stopOpacity',
            'stop-opacity': 'stopOpacity',
            strikethroughposition: 'strikethroughPosition',
            'strikethrough-position': 'strikethroughPosition',
            strikethroughthickness: 'strikethroughThickness',
            'strikethrough-thickness': 'strikethroughThickness',
            string: 'string',
            stroke: 'stroke',
            strokedasharray: 'strokeDasharray',
            'stroke-dasharray': 'strokeDasharray',
            strokedashoffset: 'strokeDashoffset',
            'stroke-dashoffset': 'strokeDashoffset',
            strokelinecap: 'strokeLinecap',
            'stroke-linecap': 'strokeLinecap',
            strokelinejoin: 'strokeLinejoin',
            'stroke-linejoin': 'strokeLinejoin',
            strokemiterlimit: 'strokeMiterlimit',
            'stroke-miterlimit': 'strokeMiterlimit',
            strokewidth: 'strokeWidth',
            'stroke-width': 'strokeWidth',
            strokeopacity: 'strokeOpacity',
            'stroke-opacity': 'strokeOpacity',
            suppresscontenteditablewarning: 'suppressContentEditableWarning',
            suppresshydrationwarning: 'suppressHydrationWarning',
            surfacescale: 'surfaceScale',
            systemlanguage: 'systemLanguage',
            tablevalues: 'tableValues',
            targetx: 'targetX',
            targety: 'targetY',
            textanchor: 'textAnchor',
            'text-anchor': 'textAnchor',
            textdecoration: 'textDecoration',
            'text-decoration': 'textDecoration',
            textlength: 'textLength',
            textrendering: 'textRendering',
            'text-rendering': 'textRendering',
            to: 'to',
            transform: 'transform',
            transformorigin: 'transformOrigin',
            'transform-origin': 'transformOrigin',
            typeof: 'typeof',
            u1: 'u1',
            u2: 'u2',
            underlineposition: 'underlinePosition',
            'underline-position': 'underlinePosition',
            underlinethickness: 'underlineThickness',
            'underline-thickness': 'underlineThickness',
            unicode: 'unicode',
            unicodebidi: 'unicodeBidi',
            'unicode-bidi': 'unicodeBidi',
            unicoderange: 'unicodeRange',
            'unicode-range': 'unicodeRange',
            unitsperem: 'unitsPerEm',
            'units-per-em': 'unitsPerEm',
            unselectable: 'unselectable',
            valphabetic: 'vAlphabetic',
            'v-alphabetic': 'vAlphabetic',
            values: 'values',
            vectoreffect: 'vectorEffect',
            'vector-effect': 'vectorEffect',
            version: 'version',
            vertadvy: 'vertAdvY',
            'vert-adv-y': 'vertAdvY',
            vertoriginx: 'vertOriginX',
            'vert-origin-x': 'vertOriginX',
            vertoriginy: 'vertOriginY',
            'vert-origin-y': 'vertOriginY',
            vhanging: 'vHanging',
            'v-hanging': 'vHanging',
            videographic: 'vIdeographic',
            'v-ideographic': 'vIdeographic',
            viewbox: 'viewBox',
            viewtarget: 'viewTarget',
            visibility: 'visibility',
            vmathematical: 'vMathematical',
            'v-mathematical': 'vMathematical',
            vocab: 'vocab',
            widths: 'widths',
            wordspacing: 'wordSpacing',
            'word-spacing': 'wordSpacing',
            writingmode: 'writingMode',
            'writing-mode': 'writingMode',
            x1: 'x1',
            x2: 'x2',
            x: 'x',
            xchannelselector: 'xChannelSelector',
            xheight: 'xHeight',
            'x-height': 'xHeight',
            xlinkactuate: 'xlinkActuate',
            'xlink:actuate': 'xlinkActuate',
            xlinkarcrole: 'xlinkArcrole',
            'xlink:arcrole': 'xlinkArcrole',
            xlinkhref: 'xlinkHref',
            'xlink:href': 'xlinkHref',
            xlinkrole: 'xlinkRole',
            'xlink:role': 'xlinkRole',
            xlinkshow: 'xlinkShow',
            'xlink:show': 'xlinkShow',
            xlinktitle: 'xlinkTitle',
            'xlink:title': 'xlinkTitle',
            xlinktype: 'xlinkType',
            'xlink:type': 'xlinkType',
            xmlbase: 'xmlBase',
            'xml:base': 'xmlBase',
            xmllang: 'xmlLang',
            'xml:lang': 'xmlLang',
            xmlns: 'xmlns',
            'xml:space': 'xmlSpace',
            xmlnsxlink: 'xmlnsXlink',
            'xmlns:xlink': 'xmlnsXlink',
            xmlspace: 'xmlSpace',
            y1: 'y1',
            y2: 'y2',
            y: 'y',
            ychannelselector: 'yChannelSelector',
            z: 'z',
            zoomandpan: 'zoomAndPan'
        };
        var ariaProperties = {
            'aria-current': 0,
            // state
            'aria-description': 0,
            'aria-details': 0,
            'aria-disabled': 0,
            // state
            'aria-hidden': 0,
            // state
            'aria-invalid': 0,
            // state
            'aria-keyshortcuts': 0,
            'aria-label': 0,
            'aria-roledescription': 0,
            // Widget Attributes
            'aria-autocomplete': 0,
            'aria-checked': 0,
            'aria-expanded': 0,
            'aria-haspopup': 0,
            'aria-level': 0,
            'aria-modal': 0,
            'aria-multiline': 0,
            'aria-multiselectable': 0,
            'aria-orientation': 0,
            'aria-placeholder': 0,
            'aria-pressed': 0,
            'aria-readonly': 0,
            'aria-required': 0,
            'aria-selected': 0,
            'aria-sort': 0,
            'aria-valuemax': 0,
            'aria-valuemin': 0,
            'aria-valuenow': 0,
            'aria-valuetext': 0,
            // Live Region Attributes
            'aria-atomic': 0,
            'aria-busy': 0,
            'aria-live': 0,
            'aria-relevant': 0,
            // Drag-and-Drop Attributes
            'aria-dropeffect': 0,
            'aria-grabbed': 0,
            // Relationship Attributes
            'aria-activedescendant': 0,
            'aria-colcount': 0,
            'aria-colindex': 0,
            'aria-colspan': 0,
            'aria-controls': 0,
            'aria-describedby': 0,
            'aria-errormessage': 0,
            'aria-flowto': 0,
            'aria-labelledby': 0,
            'aria-owns': 0,
            'aria-posinset': 0,
            'aria-rowcount': 0,
            'aria-rowindex': 0,
            'aria-rowspan': 0,
            'aria-setsize': 0
        };
        var warnedProperties$1 = {};
        var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
        var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
        function validateProperty$1(tagName, name) {
            {
                if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
                    return true;
                }
                if (rARIACamel$1.test(name)) {
                    var ariaName = 'aria-' + name.slice(4).toLowerCase();
                    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM
                    // DOM properties, then it is an invalid aria-* attribute.
                    if (correctName == null) {
                        error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.', name);
                        warnedProperties$1[name] = true;
                        return true;
                    } // aria-* attributes should be lowercase; suggest the lowercase version.
                    if (name !== correctName) {
                        error('Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName);
                        warnedProperties$1[name] = true;
                        return true;
                    }
                }
                if (rARIA$1.test(name)) {
                    var lowerCasedName = name.toLowerCase();
                    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM
                    // DOM properties, then it is an invalid aria-* attribute.
                    if (standardName == null) {
                        warnedProperties$1[name] = true;
                        return false;
                    } // aria-* attributes should be lowercase; suggest the lowercase version.
                    if (name !== standardName) {
                        error('Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName);
                        warnedProperties$1[name] = true;
                        return true;
                    }
                }
            }
            return true;
        }
        function validateProperties$2(type, props) {
            {
                var invalidProps = [];
                for(var key in props){
                    var isValid = validateProperty$1(type, key);
                    if (!isValid) {
                        invalidProps.push(key);
                    }
                }
                var unknownPropString = invalidProps.map(function(prop) {
                    return '`' + prop + '`';
                }).join(', ');
                if (invalidProps.length === 1) {
                    error('Invalid aria prop %s on <%s> tag. ' + 'For details, see https://reactjs.org/link/invalid-aria-props', unknownPropString, type);
                } else if (invalidProps.length > 1) {
                    error('Invalid aria props %s on <%s> tag. ' + 'For details, see https://reactjs.org/link/invalid-aria-props', unknownPropString, type);
                }
            }
        }
        var didWarnValueNull = false;
        function validateProperties$1(type, props) {
            {
                if (type !== 'input' && type !== 'textarea' && type !== 'select') {
                    return;
                }
                if (props != null && props.value === null && !didWarnValueNull) {
                    didWarnValueNull = true;
                    if (type === 'select' && props.multiple) {
                        error('`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.', type);
                    } else {
                        error('`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.', type);
                    }
                }
            }
        }
        var warnedProperties = {};
        var EVENT_NAME_REGEX = /^on./;
        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
        var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
        var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
        function validateProperty(tagName, name, value, eventRegistry) {
            {
                if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
                    return true;
                }
                var lowerCasedName = name.toLowerCase();
                if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
                    error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');
                    warnedProperties[name] = true;
                    return true;
                }
                {
                    // Actions are special because unlike events they can have other value types.
                    if (typeof value === 'function') {
                        if (tagName === 'form' && name === 'action') {
                            return true;
                        }
                        if (tagName === 'input' && name === 'formAction') {
                            return true;
                        }
                        if (tagName === 'button' && name === 'formAction') {
                            return true;
                        }
                    }
                }
                if (eventRegistry != null) {
                    var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
                    if (registrationNameDependencies.hasOwnProperty(name)) {
                        return true;
                    }
                    var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
                    if (registrationName != null) {
                        error('Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName);
                        warnedProperties[name] = true;
                        return true;
                    }
                    if (EVENT_NAME_REGEX.test(name)) {
                        error('Unknown event handler property `%s`. It will be ignored.', name);
                        warnedProperties[name] = true;
                        return true;
                    }
                } else if (EVENT_NAME_REGEX.test(name)) {
                    // If no event plugins have been injected, we are in a server environment.
                    // So we can't tell if the event name is correct for sure, but we can filter
                    // out known bad ones like `onclick`. We can't suggest a specific replacement though.
                    if (INVALID_EVENT_NAME_REGEX.test(name)) {
                        error('Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.', name);
                    }
                    warnedProperties[name] = true;
                    return true;
                } // Let the ARIA attribute hook validate ARIA attributes
                if (rARIA.test(name) || rARIACamel.test(name)) {
                    return true;
                }
                if (lowerCasedName === 'innerhtml') {
                    error('Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');
                    warnedProperties[name] = true;
                    return true;
                }
                if (lowerCasedName === 'aria') {
                    error('The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');
                    warnedProperties[name] = true;
                    return true;
                }
                if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
                    error('Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.', typeof value);
                    warnedProperties[name] = true;
                    return true;
                }
                if (typeof value === 'number' && isNaN(value)) {
                    error('Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.', name);
                    warnedProperties[name] = true;
                    return true;
                } // Known attributes should match the casing specified in the property config.
                if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                    var standardName = possibleStandardNames[lowerCasedName];
                    if (standardName !== name) {
                        error('Invalid DOM property `%s`. Did you mean `%s`?', name, standardName);
                        warnedProperties[name] = true;
                        return true;
                    }
                } else if (name !== lowerCasedName) {
                    // Unknown attributes should have lowercase casing since that's how they
                    // will be cased anyway with server rendering.
                    error('React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.', name, lowerCasedName);
                    warnedProperties[name] = true;
                    return true;
                } // Now that we've validated casing, do not validate
                // data types for reserved props
                switch(name){
                    case 'dangerouslySetInnerHTML':
                    case 'children':
                    case 'style':
                    case 'suppressContentEditableWarning':
                    case 'suppressHydrationWarning':
                    case 'defaultValue':
                    case 'defaultChecked':
                    case 'innerHTML':
                    case 'ref':
                        {
                            return true;
                        }
                }
                switch(typeof value){
                    case 'boolean':
                        {
                            switch(name){
                                case 'autoFocus':
                                case 'checked':
                                case 'multiple':
                                case 'muted':
                                case 'selected':
                                case 'contentEditable':
                                case 'spellCheck':
                                case 'draggable':
                                case 'value':
                                case 'autoReverse':
                                case 'externalResourcesRequired':
                                case 'focusable':
                                case 'preserveAlpha':
                                case 'allowFullScreen':
                                case 'async':
                                case 'autoPlay':
                                case 'controls':
                                case 'default':
                                case 'defer':
                                case 'disabled':
                                case 'disablePictureInPicture':
                                case 'disableRemotePlayback':
                                case 'formNoValidate':
                                case 'hidden':
                                case 'loop':
                                case 'noModule':
                                case 'noValidate':
                                case 'open':
                                case 'playsInline':
                                case 'readOnly':
                                case 'required':
                                case 'reversed':
                                case 'scoped':
                                case 'seamless':
                                case 'itemScope':
                                case 'capture':
                                case 'download':
                                    {
                                        // Boolean properties can accept boolean values
                                        return true;
                                    }
                                default:
                                    {
                                        var prefix = name.toLowerCase().slice(0, 5);
                                        if (prefix === 'data-' || prefix === 'aria-') {
                                            return true;
                                        }
                                        if (value) {
                                            error('Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.', value, name, name, value, name);
                                        } else {
                                            error('Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
                                        }
                                        warnedProperties[name] = true;
                                        return true;
                                    }
                            }
                        }
                    case 'function':
                    case 'symbol':
                        // eslint-disable-line
                        // Warn when a known attribute is a bad type
                        warnedProperties[name] = true;
                        return false;
                    case 'string':
                        {
                            // Warn when passing the strings 'false' or 'true' into a boolean prop
                            if (value === 'false' || value === 'true') {
                                switch(name){
                                    case 'checked':
                                    case 'selected':
                                    case 'multiple':
                                    case 'muted':
                                    case 'allowFullScreen':
                                    case 'async':
                                    case 'autoPlay':
                                    case 'controls':
                                    case 'default':
                                    case 'defer':
                                    case 'disabled':
                                    case 'disablePictureInPicture':
                                    case 'disableRemotePlayback':
                                    case 'formNoValidate':
                                    case 'hidden':
                                    case 'loop':
                                    case 'noModule':
                                    case 'noValidate':
                                    case 'open':
                                    case 'playsInline':
                                    case 'readOnly':
                                    case 'required':
                                    case 'reversed':
                                    case 'scoped':
                                    case 'seamless':
                                    case 'itemScope':
                                        {
                                            break;
                                        }
                                    default:
                                        {
                                            return true;
                                        }
                                }
                                error('Received the string `%s` for the boolean attribute `%s`. ' + '%s ' + 'Did you mean %s={%s}?', value, name, value === 'false' ? 'The browser will interpret it as a truthy value.' : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
                                warnedProperties[name] = true;
                                return true;
                            }
                        }
                }
                return true;
            }
        }
        function warnUnknownProperties(type, props, eventRegistry) {
            {
                var unknownProps = [];
                for(var key in props){
                    var isValid = validateProperty(type, key, props[key], eventRegistry);
                    if (!isValid) {
                        unknownProps.push(key);
                    }
                }
                var unknownPropString = unknownProps.map(function(prop) {
                    return '`' + prop + '`';
                }).join(', ');
                if (unknownProps.length === 1) {
                    error('Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://reactjs.org/link/attribute-behavior ', unknownPropString, type);
                } else if (unknownProps.length > 1) {
                    error('Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://reactjs.org/link/attribute-behavior ', unknownPropString, type);
                }
            }
        }
        function validateProperties(type, props, eventRegistry) {
            if (isCustomElement(type) || typeof props.is === 'string') {
                return;
            }
            warnUnknownProperties(type, props, eventRegistry);
        }
        // and any newline or tab are filtered out as if they're not part of the URL.
        // https://url.spec.whatwg.org/#url-parsing
        // Tab or newline are defined as \r\n\t:
        // https://infra.spec.whatwg.org/#ascii-tab-or-newline
        // A C0 control is a code point in the range \u0000 NULL to \u001F
        // INFORMATION SEPARATOR ONE, inclusive:
        // https://infra.spec.whatwg.org/#c0-control-or-space
        /* eslint-disable max-len */ var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
            // We should never have symbols here because they get filtered out elsewhere.
            // eslint-disable-next-line react-internal/safe-string-coercion
            var stringifiedURL = '' + url;
            {
                if (!didWarn && isJavaScriptProtocol.test(stringifiedURL)) {
                    didWarn = true;
                    error('A future version of React will block javascript: URLs as a security precaution. ' + 'Use event handlers instead if you can. If you need to generate unsafe HTML try ' + 'using dangerouslySetInnerHTML instead. React was passed %s.', JSON.stringify(stringifiedURL));
                }
            }
            return url;
        }
        var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
        var IS_NON_DELEGATED = 1 << 1;
        var IS_CAPTURE_PHASE = 1 << 2;
        // set to LEGACY_FB_SUPPORT. LEGACY_FB_SUPPORT only gets set when
        // we call willDeferLaterForLegacyFBSupport, thus not bailing out
        // will result in endless cycles like an infinite loop.
        // We also don't want to defer during event replaying.
        var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
        // This exists to avoid circular dependency between ReactDOMEventReplaying
        // and DOMPluginEventSystem.
        var currentReplayingEvent = null;
        function setReplayingEvent(event) {
            {
                if (currentReplayingEvent !== null) {
                    error('Expected currently replaying event to be null. This error ' + 'is likely caused by a bug in React. Please file an issue.');
                }
            }
            currentReplayingEvent = event;
        }
        function resetReplayingEvent() {
            {
                if (currentReplayingEvent === null) {
                    error('Expected currently replaying event to not be null. This error ' + 'is likely caused by a bug in React. Please file an issue.');
                }
            }
            currentReplayingEvent = null;
        }
        function isReplayingEvent(event) {
            return event === currentReplayingEvent;
        }
        /**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */ function getEventTarget(nativeEvent) {
            // Fallback to nativeEvent.srcElement for IE9
            // https://github.com/facebook/react/issues/12506
            var target = nativeEvent.target || nativeEvent.srcElement || window; // Normalize SVG <use> element events #4963
            if (target.correspondingUseElement) {
                target = target.correspondingUseElement;
            } // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
            // @see http://www.quirksmode.org/js/events_properties.html
            return target.nodeType === TEXT_NODE ? target.parentNode : target;
        }
        var restoreTarget = null;
        var restoreQueue = null;
        function restoreStateOfTarget(target) {
            // We perform this translation at the end of the event loop so that we
            // always receive the correct fiber here
            var internalInstance = getInstanceFromNode(target);
            if (!internalInstance) {
                // Unmounted
                return;
            }
            var stateNode = internalInstance.stateNode; // Guard against Fiber being unmounted.
            if (stateNode) {
                var props = getFiberCurrentPropsFromNode(stateNode);
                restoreControlledState(internalInstance.stateNode, internalInstance.type, props);
            }
        }
        function enqueueStateRestore(target) {
            if (restoreTarget) {
                if (restoreQueue) {
                    restoreQueue.push(target);
                } else {
                    restoreQueue = [
                        target
                    ];
                }
            } else {
                restoreTarget = target;
            }
        }
        function needsStateRestore() {
            return restoreTarget !== null || restoreQueue !== null;
        }
        function restoreStateIfNeeded() {
            if (!restoreTarget) {
                return;
            }
            var target = restoreTarget;
            var queuedTargets = restoreQueue;
            restoreTarget = null;
            restoreQueue = null;
            restoreStateOfTarget(target);
            if (queuedTargets) {
                for(var i = 0; i < queuedTargets.length; i++){
                    restoreStateOfTarget(queuedTargets[i]);
                }
            }
        }
        /**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */ function get(key) {
            return key._reactInternals;
        }
        function has(key) {
            return key._reactInternals !== undefined;
        }
        function set(key, value) {
            key._reactInternals = value;
        }
        var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
        function getNearestMountedFiber(fiber) {
            var node = fiber;
            var nearestMounted = fiber;
            if (!fiber.alternate) {
                // If there is no alternate, this might be a new tree that isn't inserted
                // yet. If it is, then it will have a pending insertion effect on it.
                var nextNode = node;
                do {
                    node = nextNode;
                    if ((node.flags & (Placement | Hydrating)) !== NoFlags$1) {
                        // This is an insertion or in-progress hydration. The nearest possible
                        // mounted fiber is the parent but we need to continue to figure out
                        // if that one is still mounted.
                        nearestMounted = node.return;
                    } // $FlowFixMe[incompatible-type] we bail out when we get a null
                    nextNode = node.return;
                }while (nextNode)
            } else {
                while(node.return){
                    node = node.return;
                }
            }
            if (node.tag === HostRoot) {
                // TODO: Check if this was a nested HostRoot when used with
                // renderContainerIntoSubtree.
                return nearestMounted;
            } // If we didn't hit the root, that means that we're in an disconnected tree
            // that has been unmounted.
            return null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
            if (fiber.tag === SuspenseComponent) {
                var suspenseState = fiber.memoizedState;
                if (suspenseState === null) {
                    var current = fiber.alternate;
                    if (current !== null) {
                        suspenseState = current.memoizedState;
                    }
                }
                if (suspenseState !== null) {
                    return suspenseState.dehydrated;
                }
            }
            return null;
        }
        function getContainerFromFiber(fiber) {
            return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
        }
        function isFiberMounted(fiber) {
            return getNearestMountedFiber(fiber) === fiber;
        }
        function isMounted(component) {
            {
                var owner = ReactCurrentOwner$3.current;
                if (owner !== null && owner.tag === ClassComponent) {
                    var ownerFiber = owner;
                    var instance = ownerFiber.stateNode;
                    if (!instance._warnedAboutRefsInRender) {
                        error('%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentNameFromFiber(ownerFiber) || 'A component');
                    }
                    instance._warnedAboutRefsInRender = true;
                }
            }
            var fiber = get(component);
            if (!fiber) {
                return false;
            }
            return getNearestMountedFiber(fiber) === fiber;
        }
        function assertIsMounted(fiber) {
            if (getNearestMountedFiber(fiber) !== fiber) {
                throw new Error('Unable to find node on an unmounted component.');
            }
        }
        function findCurrentFiberUsingSlowPath(fiber) {
            var alternate = fiber.alternate;
            if (!alternate) {
                // If there is no alternate, then we only need to check if it is mounted.
                var nearestMounted = getNearestMountedFiber(fiber);
                if (nearestMounted === null) {
                    throw new Error('Unable to find node on an unmounted component.');
                }
                if (nearestMounted !== fiber) {
                    return null;
                }
                return fiber;
            } // If we have two possible branches, we'll walk backwards up to the root
            // to see what path the root points to. On the way we may hit one of the
            // special cases and we'll deal with them.
            var a = fiber;
            var b = alternate;
            while(true){
                var parentA = a.return;
                if (parentA === null) {
                    break;
                }
                var parentB = parentA.alternate;
                if (parentB === null) {
                    // There is no alternate. This is an unusual case. Currently, it only
                    // happens when a Suspense component is hidden. An extra fragment fiber
                    // is inserted in between the Suspense fiber and its children. Skip
                    // over this extra fragment fiber and proceed to the next parent.
                    var nextParent = parentA.return;
                    if (nextParent !== null) {
                        a = b = nextParent;
                        continue;
                    } // If there's no parent, we're at the root.
                    break;
                } // If both copies of the parent fiber point to the same child, we can
                // assume that the child is current. This happens when we bailout on low
                // priority: the bailed out fiber's child reuses the current child.
                if (parentA.child === parentB.child) {
                    var child = parentA.child;
                    while(child){
                        if (child === a) {
                            // We've determined that A is the current branch.
                            assertIsMounted(parentA);
                            return fiber;
                        }
                        if (child === b) {
                            // We've determined that B is the current branch.
                            assertIsMounted(parentA);
                            return alternate;
                        }
                        child = child.sibling;
                    } // We should never have an alternate for any mounting node. So the only
                    // way this could possibly happen is if this was unmounted, if at all.
                    throw new Error('Unable to find node on an unmounted component.');
                }
                if (a.return !== b.return) {
                    // The return pointer of A and the return pointer of B point to different
                    // fibers. We assume that return pointers never criss-cross, so A must
                    // belong to the child set of A.return, and B must belong to the child
                    // set of B.return.
                    a = parentA;
                    b = parentB;
                } else {
                    // The return pointers point to the same fiber. We'll have to use the
                    // default, slow path: scan the child sets of each parent alternate to see
                    // which child belongs to which set.
                    //
                    // Search parent A's child set
                    var didFindChild = false;
                    var _child = parentA.child;
                    while(_child){
                        if (_child === a) {
                            didFindChild = true;
                            a = parentA;
                            b = parentB;
                            break;
                        }
                        if (_child === b) {
                            didFindChild = true;
                            b = parentA;
                            a = parentB;
                            break;
                        }
                        _child = _child.sibling;
                    }
                    if (!didFindChild) {
                        // Search parent B's child set
                        _child = parentB.child;
                        while(_child){
                            if (_child === a) {
                                didFindChild = true;
                                a = parentB;
                                b = parentA;
                                break;
                            }
                            if (_child === b) {
                                didFindChild = true;
                                b = parentB;
                                a = parentA;
                                break;
                            }
                            _child = _child.sibling;
                        }
                        if (!didFindChild) {
                            throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');
                        }
                    }
                }
                if (a.alternate !== b) {
                    throw new Error("Return fibers should always be each others' alternates. " + 'This error is likely caused by a bug in React. Please file an issue.');
                }
            } // If the root is not a host container, we're in a disconnected tree. I.e.
            // unmounted.
            if (a.tag !== HostRoot) {
                throw new Error('Unable to find node on an unmounted component.');
            }
            if (a.stateNode.current === a) {
                // We've determined that A is the current branch.
                return fiber;
            } // Otherwise B has to be current branch.
            return alternate;
        }
        function findCurrentHostFiber(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
        }
        function findCurrentHostFiberImpl(node) {
            // Next we'll drill down this component to find the first HostComponent/Text.
            var tag = node.tag;
            if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton || tag === HostText) {
                return node;
            }
            var child = node.child;
            while(child !== null){
                var match = findCurrentHostFiberImpl(child);
                if (match !== null) {
                    return match;
                }
                child = child.sibling;
            }
            return null;
        }
        function findCurrentHostFiberWithNoPortals(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
        }
        function findCurrentHostFiberWithNoPortalsImpl(node) {
            // Next we'll drill down this component to find the first HostComponent/Text.
            var tag = node.tag;
            if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton || tag === HostText) {
                return node;
            }
            var child = node.child;
            while(child !== null){
                if (child.tag !== HostPortal) {
                    var match = findCurrentHostFiberWithNoPortalsImpl(child);
                    if (match !== null) {
                        return match;
                    }
                }
                child = child.sibling;
            }
            return null;
        }
        var warnedAboutMissingGetChildContext;
        {
            warnedAboutMissingGetChildContext = {};
        }
        var emptyContextObject = {};
        {
            Object.freeze(emptyContextObject);
        }
        var contextStackCursor = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.
        var didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.
        // We use this to get access to the parent context after we have already
        // pushed the next context provider, and now need to merge their contexts.
        var previousContext = emptyContextObject;
        function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {
            {
                if (didPushOwnContextIfProvider && isContextProvider(Component)) {
                    // If the fiber is a context provider itself, when we read its context
                    // we may have already pushed its own child context on the stack. A context
                    // provider should not "see" its own child context. Therefore we read the
                    // previous (parent) context instead for a context provider.
                    return previousContext;
                }
                return contextStackCursor.current;
            }
        }
        function cacheContext(workInProgress, unmaskedContext, maskedContext) {
            {
                var instance = workInProgress.stateNode;
                instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
                instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
            }
        }
        function getMaskedContext(workInProgress, unmaskedContext) {
            {
                var type = workInProgress.type;
                var contextTypes = type.contextTypes;
                if (!contextTypes) {
                    return emptyContextObject;
                } // Avoid recreating masked context unless unmasked context has changed.
                // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
                // This may trigger infinite loops if componentWillReceiveProps calls setState.
                var instance = workInProgress.stateNode;
                if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
                    return instance.__reactInternalMemoizedMaskedChildContext;
                }
                var context = {};
                for(var key in contextTypes){
                    context[key] = unmaskedContext[key];
                } // Cache unmasked context so we can avoid recreating masked context unless necessary.
                // Context is created before the class component is instantiated so check for instance.
                if (instance) {
                    cacheContext(workInProgress, unmaskedContext, context);
                }
                return context;
            }
        }
        function hasContextChanged() {
            {
                return didPerformWorkStackCursor.current;
            }
        }
        function isContextProvider(type) {
            {
                var childContextTypes = type.childContextTypes;
                return childContextTypes !== null && childContextTypes !== undefined;
            }
        }
        function popContext(fiber) {
            {
                pop(didPerformWorkStackCursor, fiber);
                pop(contextStackCursor, fiber);
            }
        }
        function popTopLevelContextObject(fiber) {
            {
                pop(didPerformWorkStackCursor, fiber);
                pop(contextStackCursor, fiber);
            }
        }
        function pushTopLevelContextObject(fiber, context, didChange) {
            {
                if (contextStackCursor.current !== emptyContextObject) {
                    throw new Error('Unexpected context found on stack. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                }
                push(contextStackCursor, context, fiber);
                push(didPerformWorkStackCursor, didChange, fiber);
            }
        }
        function processChildContext(fiber, type, parentContext) {
            {
                var instance = fiber.stateNode;
                var childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.
                // It has only been added in Fiber to match the (unintentional) behavior in Stack.
                if (typeof instance.getChildContext !== 'function') {
                    {
                        var componentName = getComponentNameFromFiber(fiber) || 'Unknown';
                        if (!warnedAboutMissingGetChildContext[componentName]) {
                            warnedAboutMissingGetChildContext[componentName] = true;
                            error('%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);
                        }
                    }
                    return parentContext;
                }
                var childContext = instance.getChildContext();
                for(var contextKey in childContext){
                    if (!(contextKey in childContextTypes)) {
                        throw new Error((getComponentNameFromFiber(fiber) || 'Unknown') + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes.");
                    }
                }
                return assign({}, parentContext, childContext);
            }
        }
        function pushContextProvider(workInProgress) {
            {
                var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.
                // If the instance does not exist yet, we will push null at first,
                // and replace it on the stack later when invalidating the context.
                var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; // Remember the parent context so we can merge with it later.
                // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
                previousContext = contextStackCursor.current;
                push(contextStackCursor, memoizedMergedChildContext, workInProgress);
                push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);
                return true;
            }
        }
        function invalidateContextProvider(workInProgress, type, didChange) {
            {
                var instance = workInProgress.stateNode;
                if (!instance) {
                    throw new Error('Expected to have an instance by this point. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                }
                if (didChange) {
                    // Merge parent and own context.
                    // Skip this if we're not updating due to sCU.
                    // This avoids unnecessarily recomputing memoized values.
                    var mergedContext = processChildContext(workInProgress, type, previousContext);
                    instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.
                    // It is important to unwind the context in the reverse order.
                    pop(didPerformWorkStackCursor, workInProgress);
                    pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.
                    push(contextStackCursor, mergedContext, workInProgress);
                    push(didPerformWorkStackCursor, didChange, workInProgress);
                } else {
                    pop(didPerformWorkStackCursor, workInProgress);
                    push(didPerformWorkStackCursor, didChange, workInProgress);
                }
            }
        }
        function findCurrentUnmaskedContext(fiber) {
            {
                // Currently this is only used with renderSubtreeIntoContainer; not sure if it
                // makes sense elsewhere
                if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
                    throw new Error('Expected subtree parent to be a mounted class component. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                }
                var node = fiber;
                do {
                    switch(node.tag){
                        case HostRoot:
                            return node.stateNode.context;
                        case ClassComponent:
                            {
                                var Component = node.type;
                                if (isContextProvider(Component)) {
                                    return node.stateNode.__reactInternalMemoizedMergedChildContext;
                                }
                                break;
                            }
                    } // $FlowFixMe[incompatible-type] we bail out when we get a null
                    node = node.return;
                }while (node !== null)
                throw new Error('Found unexpected detached subtree parent. ' + 'This error is likely caused by a bug in React. Please file an issue.');
            }
        }
        var LegacyRoot = 0;
        var ConcurrentRoot = 1;
        // We use the existence of the state object as an indicator that the component
        // is hidden.
        var OffscreenVisible = /*                     */ 1;
        var OffscreenDetached = /*                    */ 2;
        var OffscreenPassiveEffectsConnected = /*     */ 4;
        function isOffscreenManual(offscreenFiber) {
            return offscreenFiber.memoizedProps !== null && offscreenFiber.memoizedProps.mode === 'manual';
        }
        /**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */ function is(x, y) {
            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
            ;
        }
        var objectIs = typeof Object.is === 'function' ? Object.is : is;
        // This is imported by the event replaying implementation in React DOM. It's
        // in a separate file to break a circular dependency between the renderer and
        // the reconciler.
        function isRootDehydrated(root) {
            var currentState = root.current.memoizedState;
            return currentState.isDehydrated;
        }
        // Intentionally not using it yet to derisk the initial implementation, because
        // the way we push/pop these values is a bit unusual. If there's a mistake, I'd
        // rather the ids be wrong than crash the whole reconciler.
        var forkStack = [];
        var forkStackIndex = 0;
        var treeForkProvider = null;
        var treeForkCount = 0;
        var idStack = [];
        var idStackIndex = 0;
        var treeContextProvider = null;
        var treeContextId = 1;
        var treeContextOverflow = '';
        function isForkedChild(workInProgress) {
            warnIfNotHydrating();
            return (workInProgress.flags & Forked) !== NoFlags$1;
        }
        function getForksAtLevel(workInProgress) {
            warnIfNotHydrating();
            return treeForkCount;
        }
        function getTreeId() {
            var overflow = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
            return id.toString(32) + overflow;
        }
        function pushTreeFork(workInProgress, totalChildren) {
            // This is called right after we reconcile an array (or iterator) of child
            // fibers, because that's the only place where we know how many children in
            // the whole set without doing extra work later, or storing addtional
            // information on the fiber.
            //
            // That's why this function is separate from pushTreeId — it's called during
            // the render phase of the fork parent, not the child, which is where we push
            // the other context values.
            //
            // In the Fizz implementation this is much simpler because the child is
            // rendered in the same callstack as the parent.
            //
            // It might be better to just add a `forks` field to the Fiber type. It would
            // make this module simpler.
            warnIfNotHydrating();
            forkStack[forkStackIndex++] = treeForkCount;
            forkStack[forkStackIndex++] = treeForkProvider;
            treeForkProvider = workInProgress;
            treeForkCount = totalChildren;
        }
        function pushTreeId(workInProgress, totalChildren, index) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextProvider = workInProgress;
            var baseIdWithLeadingBit = treeContextId;
            var baseOverflow = treeContextOverflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part
            // of the id; we use it to account for leading 0s.
            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
            var slot = index + 1;
            var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into
            // consideration the leading 1 we use to mark the end of the sequence.
            if (length > 30) {
                // We overflowed the bitwise-safe range. Fall back to slower algorithm.
                // This branch assumes the length of the base id is greater than 5; it won't
                // work for smaller ids, because you need 5 bits per character.
                //
                // We encode the id in multiple steps: first the base id, then the
                // remaining digits.
                //
                // Each 5 bit sequence corresponds to a single base 32 character. So for
                // example, if the current id is 23 bits long, we can convert 20 of those
                // bits into a string of 4 characters, with 3 bits left over.
                //
                // First calculate how many bits in the base id represent a complete
                // sequence of characters.
                var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.
                var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.
                var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.
                var restOfBaseId = baseId >> numberOfOverflowBits;
                var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because
                // we made more room, this time it won't overflow.
                var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
                var restOfNewBits = slot << restOfBaseLength;
                var id = restOfNewBits | restOfBaseId;
                var overflow = newOverflow + baseOverflow;
                treeContextId = 1 << restOfLength | id;
                treeContextOverflow = overflow;
            } else {
                // Normal path
                var newBits = slot << baseLength;
                var _id = newBits | baseId;
                var _overflow = baseOverflow;
                treeContextId = 1 << length | _id;
                treeContextOverflow = _overflow;
            }
        }
        function pushMaterializedTreeId(workInProgress) {
            warnIfNotHydrating(); // This component materialized an id. This will affect any ids that appear
            // in its children.
            var returnFiber = workInProgress.return;
            if (returnFiber !== null) {
                var numberOfForks = 1;
                var slotIndex = 0;
                pushTreeFork(workInProgress, numberOfForks);
                pushTreeId(workInProgress, numberOfForks, slotIndex);
            }
        }
        function getBitLength(number) {
            return 32 - clz32(number);
        }
        function getLeadingBit(id) {
            return 1 << getBitLength(id) - 1;
        }
        function popTreeContext(workInProgress) {
            // Restore the previous values.
            // This is a bit more complicated than other context-like modules in Fiber
            // because the same Fiber may appear on the stack multiple times and for
            // different reasons. We have to keep popping until the work-in-progress is
            // no longer at the top of the stack.
            while(workInProgress === treeForkProvider){
                treeForkProvider = forkStack[--forkStackIndex];
                forkStack[forkStackIndex] = null;
                treeForkCount = forkStack[--forkStackIndex];
                forkStack[forkStackIndex] = null;
            }
            while(workInProgress === treeContextProvider){
                treeContextProvider = idStack[--idStackIndex];
                idStack[idStackIndex] = null;
                treeContextOverflow = idStack[--idStackIndex];
                idStack[idStackIndex] = null;
                treeContextId = idStack[--idStackIndex];
                idStack[idStackIndex] = null;
            }
        }
        function getSuspendedTreeContext() {
            warnIfNotHydrating();
            if (treeContextProvider !== null) {
                return {
                    id: treeContextId,
                    overflow: treeContextOverflow
                };
            } else {
                return null;
            }
        }
        function restoreSuspendedTreeContext(workInProgress, suspendedContext) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextId = suspendedContext.id;
            treeContextOverflow = suspendedContext.overflow;
            treeContextProvider = workInProgress;
        }
        function warnIfNotHydrating() {
            {
                if (!getIsHydrating()) {
                    error('Expected to be hydrating. This is a bug in React. Please file ' + 'an issue.');
                }
            }
        }
        // This may have been an insertion or a hydration.
        var hydrationParentFiber = null;
        var nextHydratableInstance = null;
        var isHydrating = false; // This flag allows for warning supression when we expect there to be mismatches
        // due to earlier mismatches or a suspended fiber.
        var didSuspendOrErrorDEV = false; // Hydration errors that were thrown inside this boundary
        var hydrationErrors = null;
        var rootOrSingletonContext = false;
        function warnIfHydrating() {
            {
                if (isHydrating) {
                    error('We should not be hydrating here. This is a bug in React. Please file a bug.');
                }
            }
        }
        function markDidThrowWhileHydratingDEV() {
            {
                didSuspendOrErrorDEV = true;
            }
        }
        function didSuspendOrErrorWhileHydratingDEV() {
            {
                return didSuspendOrErrorDEV;
            }
        }
        function enterHydrationState(fiber) {
            var parentInstance = fiber.stateNode.containerInfo;
            nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            hydrationErrors = null;
            didSuspendOrErrorDEV = false;
            rootOrSingletonContext = true;
            return true;
        }
        function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
            nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            hydrationErrors = null;
            didSuspendOrErrorDEV = false;
            rootOrSingletonContext = false;
            if (treeContext !== null) {
                restoreSuspendedTreeContext(fiber, treeContext);
            }
            return true;
        }
        function warnUnhydratedInstance(returnFiber, instance) {
            {
                switch(returnFiber.tag){
                    case HostRoot:
                        {
                            didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
                            break;
                        }
                    case HostSingleton:
                    case HostComponent:
                        {
                            var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                            didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance, isConcurrentMode);
                            break;
                        }
                    case SuspenseComponent:
                        {
                            var suspenseState = returnFiber.memoizedState;
                            if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
                            break;
                        }
                }
            }
        }
        function deleteHydratableInstance(returnFiber, instance) {
            var childToDelete = createFiberFromHostInstanceForDeletion();
            childToDelete.stateNode = instance;
            childToDelete.return = returnFiber;
            var deletions = returnFiber.deletions;
            if (deletions === null) {
                returnFiber.deletions = [
                    childToDelete
                ];
                returnFiber.flags |= ChildDeletion;
            } else {
                deletions.push(childToDelete);
            }
        }
        function warnNonHydratedInstance(returnFiber, fiber) {
            {
                if (didSuspendOrErrorDEV) {
                    // Inside a boundary that already suspended. We're currently rendering the
                    // siblings of a suspended node. The mismatch may be due to the missing
                    // data, so it's probably a false positive.
                    return;
                }
                switch(returnFiber.tag){
                    case HostRoot:
                        {
                            var parentContainer = returnFiber.stateNode.containerInfo;
                            switch(fiber.tag){
                                case HostSingleton:
                                case HostComponent:
                                    var type = fiber.type;
                                    didNotFindHydratableInstanceWithinContainer(parentContainer, type);
                                    break;
                                case HostText:
                                    var text = fiber.pendingProps;
                                    didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);
                                    break;
                            }
                            break;
                        }
                    case HostSingleton:
                    case HostComponent:
                        {
                            var parentType = returnFiber.type;
                            var parentProps = returnFiber.memoizedProps;
                            var parentInstance = returnFiber.stateNode;
                            switch(fiber.tag){
                                case HostSingleton:
                                case HostComponent:
                                    {
                                        var _type = fiber.type;
                                        var _props = fiber.pendingProps;
                                        var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                                        didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props, isConcurrentMode);
                                        break;
                                    }
                                case HostText:
                                    {
                                        var _text = fiber.pendingProps;
                                        var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                                        didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text, _isConcurrentMode);
                                        break;
                                    }
                            }
                            break;
                        }
                    case SuspenseComponent:
                        {
                            var suspenseState = returnFiber.memoizedState;
                            var _parentInstance = suspenseState.dehydrated;
                            if (_parentInstance !== null) switch(fiber.tag){
                                case HostSingleton:
                                case HostComponent:
                                    var _type2 = fiber.type;
                                    didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                                    break;
                                case HostText:
                                    var _text2 = fiber.pendingProps;
                                    didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                                    break;
                            }
                            break;
                        }
                    default:
                        return;
                }
            }
        }
        function insertNonHydratedInstance(returnFiber, fiber) {
            fiber.flags = fiber.flags & ~Hydrating | Placement;
        }
        function tryHydrateInstance(fiber, nextInstance) {
            // fiber is a HostComponent Fiber
            var instance = canHydrateInstance(nextInstance, fiber.type, fiber.pendingProps, rootOrSingletonContext);
            if (instance !== null) {
                fiber.stateNode = instance;
                hydrationParentFiber = fiber;
                nextHydratableInstance = getFirstHydratableChild(instance);
                rootOrSingletonContext = false;
                return true;
            }
            return false;
        }
        function tryHydrateText(fiber, nextInstance) {
            // fiber is a HostText Fiber
            var text = fiber.pendingProps;
            var textInstance = canHydrateTextInstance(nextInstance, text, rootOrSingletonContext);
            if (textInstance !== null) {
                fiber.stateNode = textInstance;
                hydrationParentFiber = fiber; // Text Instances don't have children so there's nothing to hydrate.
                nextHydratableInstance = null;
                return true;
            }
            return false;
        }
        function tryHydrateSuspense(fiber, nextInstance) {
            // fiber is a SuspenseComponent Fiber
            var suspenseInstance = canHydrateSuspenseInstance(nextInstance, rootOrSingletonContext);
            if (suspenseInstance !== null) {
                var suspenseState = {
                    dehydrated: suspenseInstance,
                    treeContext: getSuspendedTreeContext(),
                    retryLane: OffscreenLane
                };
                fiber.memoizedState = suspenseState; // Store the dehydrated fragment as a child fiber.
                // This simplifies the code for getHostSibling and deleting nodes,
                // since it doesn't have to consider all Suspense boundaries and
                // check if they're dehydrated ones or not.
                var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
                dehydratedFragment.return = fiber;
                fiber.child = dehydratedFragment;
                hydrationParentFiber = fiber; // While a Suspense Instance does have children, we won't step into
                // it during the first pass. Instead, we'll reenter it later.
                nextHydratableInstance = null;
                return true;
            }
            return false;
        }
        function shouldClientRenderOnMismatch(fiber) {
            return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags$1;
        }
        function throwOnHydrationMismatch(fiber) {
            throw new Error('Hydration failed because the initial UI does not match what was ' + 'rendered on the server.');
        }
        function claimHydratableSingleton(fiber) {
            {
                if (!isHydrating) {
                    return;
                }
                var currentRootContainer = getRootHostContainer();
                var currentHostContext = getHostContext();
                var instance = fiber.stateNode = resolveSingletonInstance(fiber.type, fiber.pendingProps, currentRootContainer, currentHostContext, false);
                hydrationParentFiber = fiber;
                rootOrSingletonContext = true;
                nextHydratableInstance = getFirstHydratableChild(instance);
            }
        }
        function tryToClaimNextHydratableInstance(fiber) {
            if (!isHydrating) {
                return;
            } // Validate that this is ok to render here before any mismatches.
            var currentHostContext = getHostContext();
            var shouldKeepWarning = validateHydratableInstance(fiber.type, fiber.pendingProps, currentHostContext);
            var initialInstance = nextHydratableInstance;
            var nextInstance = nextHydratableInstance;
            if (!nextInstance) {
                if (shouldClientRenderOnMismatch(fiber)) {
                    if (shouldKeepWarning) {
                        warnNonHydratedInstance(hydrationParentFiber, fiber);
                    }
                    throwOnHydrationMismatch();
                } // Nothing to hydrate. Make it an insertion.
                insertNonHydratedInstance(hydrationParentFiber, fiber);
                if (shouldKeepWarning) {
                    warnNonHydratedInstance(hydrationParentFiber, fiber);
                }
                isHydrating = false;
                hydrationParentFiber = fiber;
                nextHydratableInstance = initialInstance;
                return;
            }
            var firstAttemptedInstance = nextInstance;
            if (!tryHydrateInstance(fiber, nextInstance)) {
                if (shouldClientRenderOnMismatch(fiber)) {
                    if (shouldKeepWarning) {
                        warnNonHydratedInstance(hydrationParentFiber, fiber);
                    }
                    throwOnHydrationMismatch();
                } // If we can't hydrate this instance let's try the next one.
                // We use this as a heuristic. It's based on intuition and not data so it
                // might be flawed or unnecessary.
                nextHydratableInstance = getNextHydratableSibling(nextInstance);
                var prevHydrationParentFiber = hydrationParentFiber;
                if (!nextHydratableInstance || !tryHydrateInstance(fiber, nextHydratableInstance)) {
                    // Nothing to hydrate. Make it an insertion.
                    insertNonHydratedInstance(hydrationParentFiber, fiber);
                    if (shouldKeepWarning) {
                        warnNonHydratedInstance(hydrationParentFiber, fiber);
                    }
                    isHydrating = false;
                    hydrationParentFiber = fiber;
                    nextHydratableInstance = initialInstance;
                    return;
                } // We matched the next one, we'll now assume that the first one was
                // superfluous and we'll delete it. Since we can't eagerly delete it
                // we'll have to schedule a deletion. To do that, this node needs a dummy
                // fiber associated with it.
                if (shouldKeepWarning) {
                    warnUnhydratedInstance(prevHydrationParentFiber, firstAttemptedInstance);
                }
                deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
            }
        }
        function tryToClaimNextHydratableTextInstance(fiber) {
            if (!isHydrating) {
                return;
            }
            var text = fiber.pendingProps;
            var isHydratable = isHydratableText(text);
            var shouldKeepWarning = true;
            if (isHydratable) {
                // Validate that this is ok to render here before any mismatches.
                var currentHostContext = getHostContext();
                shouldKeepWarning = validateHydratableTextInstance(text, currentHostContext);
            }
            var initialInstance = nextHydratableInstance;
            var nextInstance = nextHydratableInstance;
            if (!nextInstance || !isHydratable) {
                // We exclude non hydrabable text because we know there are no matching hydratables.
                // We either throw or insert depending on the render mode.
                if (shouldClientRenderOnMismatch(fiber)) {
                    if (shouldKeepWarning) {
                        warnNonHydratedInstance(hydrationParentFiber, fiber);
                    }
                    throwOnHydrationMismatch();
                } // Nothing to hydrate. Make it an insertion.
                insertNonHydratedInstance(hydrationParentFiber, fiber);
                if (shouldKeepWarning) {
                    warnNonHydratedInstance(hydrationParentFiber, fiber);
                }
                isHydrating = false;
                hydrationParentFiber = fiber;
                nextHydratableInstance = initialInstance;
                return;
            }
            var firstAttemptedInstance = nextInstance;
            if (!tryHydrateText(fiber, nextInstance)) {
                if (shouldClientRenderOnMismatch(fiber)) {
                    if (shouldKeepWarning) {
                        warnNonHydratedInstance(hydrationParentFiber, fiber);
                    }
                    throwOnHydrationMismatch();
                } // If we can't hydrate this instance let's try the next one.
                // We use this as a heuristic. It's based on intuition and not data so it
                // might be flawed or unnecessary.
                nextHydratableInstance = getNextHydratableSibling(nextInstance);
                var prevHydrationParentFiber = hydrationParentFiber;
                if (!nextHydratableInstance || !tryHydrateText(fiber, nextHydratableInstance)) {
                    // Nothing to hydrate. Make it an insertion.
                    insertNonHydratedInstance(hydrationParentFiber, fiber);
                    if (shouldKeepWarning) {
                        warnNonHydratedInstance(hydrationParentFiber, fiber);
                    }
                    isHydrating = false;
                    hydrationParentFiber = fiber;
                    nextHydratableInstance = initialInstance;
                    return;
                } // We matched the next one, we'll now assume that the first one was
                // superfluous and we'll delete it. Since we can't eagerly delete it
                // we'll have to schedule a deletion. To do that, this node needs a dummy
                // fiber associated with it.
                if (shouldKeepWarning) {
                    warnUnhydratedInstance(prevHydrationParentFiber, firstAttemptedInstance);
                }
                deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
            }
        }
        function tryToClaimNextHydratableSuspenseInstance(fiber) {
            if (!isHydrating) {
                return;
            }
            var initialInstance = nextHydratableInstance;
            var nextInstance = nextHydratableInstance;
            if (!nextInstance) {
                if (shouldClientRenderOnMismatch(fiber)) {
                    warnNonHydratedInstance(hydrationParentFiber, fiber);
                    throwOnHydrationMismatch();
                } // Nothing to hydrate. Make it an insertion.
                insertNonHydratedInstance(hydrationParentFiber, fiber);
                warnNonHydratedInstance(hydrationParentFiber, fiber);
                isHydrating = false;
                hydrationParentFiber = fiber;
                nextHydratableInstance = initialInstance;
                return;
            }
            var firstAttemptedInstance = nextInstance;
            if (!tryHydrateSuspense(fiber, nextInstance)) {
                if (shouldClientRenderOnMismatch(fiber)) {
                    warnNonHydratedInstance(hydrationParentFiber, fiber);
                    throwOnHydrationMismatch();
                } // If we can't hydrate this instance let's try the next one.
                // We use this as a heuristic. It's based on intuition and not data so it
                // might be flawed or unnecessary.
                nextHydratableInstance = getNextHydratableSibling(nextInstance);
                var prevHydrationParentFiber = hydrationParentFiber;
                if (!nextHydratableInstance || !tryHydrateSuspense(fiber, nextHydratableInstance)) {
                    // Nothing to hydrate. Make it an insertion.
                    insertNonHydratedInstance(hydrationParentFiber, fiber);
                    warnNonHydratedInstance(hydrationParentFiber, fiber);
                    isHydrating = false;
                    hydrationParentFiber = fiber;
                    nextHydratableInstance = initialInstance;
                    return;
                } // We matched the next one, we'll now assume that the first one was
                // superfluous and we'll delete it. Since we can't eagerly delete it
                // we'll have to schedule a deletion. To do that, this node needs a dummy
                // fiber associated with it.
                warnUnhydratedInstance(prevHydrationParentFiber, firstAttemptedInstance);
                deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
            }
        }
        function tryToClaimNextHydratableFormMarkerInstance(fiber) {
            if (!isHydrating) {
                return false;
            }
            if (nextHydratableInstance) {
                var markerInstance = canHydrateFormStateMarker(nextHydratableInstance, rootOrSingletonContext);
                if (markerInstance) {
                    // Found the marker instance.
                    nextHydratableInstance = getNextHydratableSibling(markerInstance); // Return true if this marker instance should use the state passed
                    // to hydrateRoot.
                    // TODO: As an optimization, Fizz should only emit these markers if form
                    // state is passed at the root.
                    return isFormStateMarkerMatching(markerInstance);
                }
            } // Should have found a marker instance. Throw an error to trigger client
            // rendering. We don't bother to check if we're in a concurrent root because
            // useFormState is a new API, so backwards compat is not an issue.
            throwOnHydrationMismatch();
            return false;
        }
        function prepareToHydrateHostInstance(fiber, hostContext) {
            var instance = fiber.stateNode;
            var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
            hydrateInstance(instance, fiber.type, fiber.memoizedProps, hostContext, fiber, shouldWarnIfMismatchDev);
        }
        function prepareToHydrateHostTextInstance(fiber) {
            var textInstance = fiber.stateNode;
            var textContent = fiber.memoizedProps;
            var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
            var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
            if (shouldUpdate) {
                // We assume that prepareToHydrateHostTextInstance is called in a context where the
                // hydration parent is the parent host component of this host text.
                var returnFiber = hydrationParentFiber;
                if (returnFiber !== null) {
                    switch(returnFiber.tag){
                        case HostRoot:
                            {
                                var parentContainer = returnFiber.stateNode.containerInfo;
                                var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent, isConcurrentMode, shouldWarnIfMismatchDev);
                                if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
                                    // In concurrent mode we never update the mismatched text,
                                    // even if the error was ignored.
                                    return false;
                                }
                                break;
                            }
                        case HostSingleton:
                        case HostComponent:
                            {
                                var parentType = returnFiber.type;
                                var parentProps = returnFiber.memoizedProps;
                                var parentInstance = returnFiber.stateNode;
                                var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent, _isConcurrentMode2, shouldWarnIfMismatchDev);
                                if (_isConcurrentMode2 && enableClientRenderFallbackOnTextMismatch) {
                                    // In concurrent mode we never update the mismatched text,
                                    // even if the error was ignored.
                                    return false;
                                }
                                break;
                            }
                    }
                }
            }
            return shouldUpdate;
        }
        function prepareToHydrateHostSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
                throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');
            }
            hydrateSuspenseInstance(suspenseInstance, fiber);
        }
        function skipPastDehydratedSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
                throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');
            }
            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
        }
        function popToNextHostParent(fiber) {
            hydrationParentFiber = fiber.return;
            while(hydrationParentFiber){
                switch(hydrationParentFiber.tag){
                    case HostRoot:
                    case HostSingleton:
                        rootOrSingletonContext = true;
                        return;
                    case HostComponent:
                    case SuspenseComponent:
                        rootOrSingletonContext = false;
                        return;
                    default:
                        hydrationParentFiber = hydrationParentFiber.return;
                }
            }
        }
        function popHydrationState(fiber) {
            if (fiber !== hydrationParentFiber) {
                // We're deeper than the current hydration context, inside an inserted
                // tree.
                return false;
            }
            if (!isHydrating) {
                // If we're not currently hydrating but we're in a hydration context, then
                // we were an insertion and now need to pop up reenter hydration of our
                // siblings.
                popToNextHostParent(fiber);
                isHydrating = true;
                return false;
            }
            var shouldClear = false;
            {
                // With float we never clear the Root, or Singleton instances. We also do not clear Instances
                // that have singleton text content
                if (fiber.tag !== HostRoot && fiber.tag !== HostSingleton && !(fiber.tag === HostComponent && (!shouldDeleteUnhydratedTailInstances(fiber.type) || shouldSetTextContent(fiber.type, fiber.memoizedProps)))) {
                    shouldClear = true;
                }
            }
            if (shouldClear) {
                var nextInstance = nextHydratableInstance;
                if (nextInstance) {
                    if (shouldClientRenderOnMismatch(fiber)) {
                        warnIfUnhydratedTailNodes(fiber);
                        throwOnHydrationMismatch();
                    } else {
                        while(nextInstance){
                            warnUnhydratedInstance(fiber, nextInstance);
                            deleteHydratableInstance(fiber, nextInstance);
                            nextInstance = getNextHydratableSibling(nextInstance);
                        }
                    }
                }
            }
            popToNextHostParent(fiber);
            if (fiber.tag === SuspenseComponent) {
                nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
            } else {
                nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
            }
            return true;
        }
        function hasUnhydratedTailNodes() {
            return isHydrating && nextHydratableInstance !== null;
        }
        function warnIfUnhydratedTailNodes(fiber) {
            var nextInstance = nextHydratableInstance;
            while(nextInstance){
                warnUnhydratedInstance(fiber, nextInstance);
                nextInstance = getNextHydratableSibling(nextInstance);
            }
        }
        function resetHydrationState() {
            hydrationParentFiber = null;
            nextHydratableInstance = null;
            isHydrating = false;
            didSuspendOrErrorDEV = false;
        }
        function upgradeHydrationErrorsToRecoverable() {
            if (hydrationErrors !== null) {
                // Successfully completed a forced client render. The errors that occurred
                // during the hydration attempt are now recovered. We will log them in
                // commit phase, once the entire tree has finished.
                queueRecoverableErrors(hydrationErrors);
                hydrationErrors = null;
            }
        }
        function getIsHydrating() {
            return isHydrating;
        }
        function queueHydrationError(error) {
            if (hydrationErrors === null) {
                hydrationErrors = [
                    error
                ];
            } else {
                hydrationErrors.push(error);
            }
        }
        // we wait until the current render is over (either finished or interrupted)
        // before adding it to the fiber/hook queue. Push to this array so we can
        // access the queue, fiber, update, et al later.
        var concurrentQueues = [];
        var concurrentQueuesIndex = 0;
        var concurrentlyUpdatedLanes = NoLanes;
        function finishQueueingConcurrentUpdates() {
            var endIndex = concurrentQueuesIndex;
            concurrentQueuesIndex = 0;
            concurrentlyUpdatedLanes = NoLanes;
            var i = 0;
            while(i < endIndex){
                var fiber = concurrentQueues[i];
                concurrentQueues[i++] = null;
                var queue = concurrentQueues[i];
                concurrentQueues[i++] = null;
                var update = concurrentQueues[i];
                concurrentQueues[i++] = null;
                var lane = concurrentQueues[i];
                concurrentQueues[i++] = null;
                if (queue !== null && update !== null) {
                    var pending = queue.pending;
                    if (pending === null) {
                        // This is the first update. Create a circular list.
                        update.next = update;
                    } else {
                        update.next = pending.next;
                        pending.next = update;
                    }
                    queue.pending = update;
                }
                if (lane !== NoLane) {
                    markUpdateLaneFromFiberToRoot(fiber, update, lane);
                }
            }
        }
        function getConcurrentlyUpdatedLanes() {
            return concurrentlyUpdatedLanes;
        }
        function enqueueUpdate$1(fiber, queue, update, lane) {
            // Don't update the `childLanes` on the return path yet. If we already in
            // the middle of rendering, wait until after it has completed.
            concurrentQueues[concurrentQueuesIndex++] = fiber;
            concurrentQueues[concurrentQueuesIndex++] = queue;
            concurrentQueues[concurrentQueuesIndex++] = update;
            concurrentQueues[concurrentQueuesIndex++] = lane;
            concurrentlyUpdatedLanes = mergeLanes(concurrentlyUpdatedLanes, lane); // The fiber's `lane` field is used in some places to check if any work is
            // scheduled, to perform an eager bailout, so we need to update it immediately.
            // TODO: We should probably move this to the "shared" queue instead.
            fiber.lanes = mergeLanes(fiber.lanes, lane);
            var alternate = fiber.alternate;
            if (alternate !== null) {
                alternate.lanes = mergeLanes(alternate.lanes, lane);
            }
        }
        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
            var concurrentQueue = queue;
            var concurrentUpdate = update;
            enqueueUpdate$1(fiber, concurrentQueue, concurrentUpdate, lane);
            return getRootForUpdatedFiber(fiber);
        }
        function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update) {
            // This function is used to queue an update that doesn't need a rerender. The
            // only reason we queue it is in case there's a subsequent higher priority
            // update that causes it to be rebased.
            var lane = NoLane;
            var concurrentQueue = queue;
            var concurrentUpdate = update;
            enqueueUpdate$1(fiber, concurrentQueue, concurrentUpdate, lane); // Usually we can rely on the upcoming render phase to process the concurrent
            // queue. However, since this is a bail out, we're not scheduling any work
            // here. So the update we just queued will leak until something else happens
            // to schedule work (if ever).
            //
            // Check if we're currently in the middle of rendering a tree, and if not,
            // process the queue immediately to prevent a leak.
            var isConcurrentlyRendering = getWorkInProgressRoot() !== null;
            if (!isConcurrentlyRendering) {
                finishQueueingConcurrentUpdates();
            }
        }
        function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
            var concurrentQueue = queue;
            var concurrentUpdate = update;
            enqueueUpdate$1(fiber, concurrentQueue, concurrentUpdate, lane);
            return getRootForUpdatedFiber(fiber);
        }
        function enqueueConcurrentRenderForLane(fiber, lane) {
            enqueueUpdate$1(fiber, null, null, lane);
            return getRootForUpdatedFiber(fiber);
        } // Calling this function outside this module should only be done for backwards
        // compatibility and should always be accompanied by a warning.
        function unsafe_markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
            // NOTE: For Hyrum's Law reasons, if an infinite update loop is detected, it
            // should throw before `markUpdateLaneFromFiberToRoot` is called. But this is
            // undefined behavior and we can change it if we need to; it just so happens
            // that, at the time of this writing, there's an internal product test that
            // happens to rely on this.
            var root = getRootForUpdatedFiber(sourceFiber);
            markUpdateLaneFromFiberToRoot(sourceFiber, null, lane);
            return root;
        }
        function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
            // Update the source fiber's lanes
            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
            var alternate = sourceFiber.alternate;
            if (alternate !== null) {
                alternate.lanes = mergeLanes(alternate.lanes, lane);
            } // Walk the parent path to the root and update the child lanes.
            var isHidden = false;
            var parent = sourceFiber.return;
            var node = sourceFiber;
            while(parent !== null){
                parent.childLanes = mergeLanes(parent.childLanes, lane);
                alternate = parent.alternate;
                if (alternate !== null) {
                    alternate.childLanes = mergeLanes(alternate.childLanes, lane);
                }
                if (parent.tag === OffscreenComponent) {
                    // Check if this offscreen boundary is currently hidden.
                    //
                    // The instance may be null if the Offscreen parent was unmounted. Usually
                    // the parent wouldn't be reachable in that case because we disconnect
                    // fibers from the tree when they are deleted. However, there's a weird
                    // edge case where setState is called on a fiber that was interrupted
                    // before it ever mounted. Because it never mounts, it also never gets
                    // deleted. Because it never gets deleted, its return pointer never gets
                    // disconnected. Which means it may be attached to a deleted Offscreen
                    // parent node. (This discovery suggests it may be better for memory usage
                    // if we don't attach the `return` pointer until the commit phase, though
                    // in order to do that we'd need some other way to track the return
                    // pointer during the initial render, like on the stack.)
                    //
                    // This case is always accompanied by a warning, but we still need to
                    // account for it. (There may be other cases that we haven't discovered,
                    // too.)
                    var offscreenInstance = parent.stateNode;
                    if (offscreenInstance !== null && !(offscreenInstance._visibility & OffscreenVisible)) {
                        isHidden = true;
                    }
                }
                node = parent;
                parent = parent.return;
            }
            if (isHidden && update !== null && node.tag === HostRoot) {
                var root = node.stateNode;
                markHiddenUpdate(root, update, lane);
            }
        }
        function getRootForUpdatedFiber(sourceFiber) {
            // TODO: We will detect and infinite update loop and throw even if this fiber
            // has already unmounted. This isn't really necessary but it happens to be the
            // current behavior we've used for several release cycles. Consider not
            // performing this check if the updated fiber already unmounted, since it's
            // not possible for that to cause an infinite update loop.
            throwIfInfiniteUpdateLoopDetected(); // When a setState happens, we must ensure the root is scheduled. Because
            // update queues do not have a backpointer to the root, the only way to do
            // this currently is to walk up the return path. This used to not be a big
            // deal because we would have to walk up the return path to set
            // the `childLanes`, anyway, but now those two traversals happen at
            // different times.
            // TODO: Consider adding a `root` backpointer on the update queue.
            detectUpdateOnUnmountedFiber(sourceFiber, sourceFiber);
            var node = sourceFiber;
            var parent = node.return;
            while(parent !== null){
                detectUpdateOnUnmountedFiber(sourceFiber, node);
                node = parent;
                parent = node.return;
            }
            return node.tag === HostRoot ? node.stateNode : null;
        }
        function detectUpdateOnUnmountedFiber(sourceFiber, parent) {
            {
                var alternate = parent.alternate;
                if (alternate === null && (parent.flags & (Placement | Hydrating)) !== NoFlags$1) {
                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                }
            }
        }
        var ReactCurrentActQueue$3 = ReactSharedInternals.ReactCurrentActQueue; // A linked list of all the roots with pending work. In an idiomatic app,
        // there's only a single root, but we do support multi root apps, hence this
        // extra complexity. But this module is optimized for the single root case.
        var firstScheduledRoot = null;
        var lastScheduledRoot = null; // Used to prevent redundant mircotasks from being scheduled.
        var didScheduleMicrotask = false; // `act` "microtasks" are scheduled on the `act` queue instead of an actual
        // microtask, so we have to dedupe those separately. This wouldn't be an issue
        // if we required all `act` calls to be awaited, which we might in the future.
        var didScheduleMicrotask_act = false; // Used to quickly bail out of flushSync if there's no sync work to do.
        var mightHavePendingSyncWork = false;
        var isFlushingWork = false;
        var currentEventTransitionLane = NoLane;
        function ensureRootIsScheduled(root) {
            // This function is called whenever a root receives an update. It does two
            // things 1) it ensures the root is in the root schedule, and 2) it ensures
            // there's a pending microtask to process the root schedule.
            //
            // Most of the actual scheduling logic does not happen until
            // `scheduleTaskForRootDuringMicrotask` runs.
            // Add the root to the schedule
            if (root === lastScheduledRoot || root.next !== null) ;
            else {
                if (lastScheduledRoot === null) {
                    firstScheduledRoot = lastScheduledRoot = root;
                } else {
                    lastScheduledRoot.next = root;
                    lastScheduledRoot = root;
                }
            } // Any time a root received an update, we set this to true until the next time
            // we process the schedule. If it's false, then we can quickly exit flushSync
            // without consulting the schedule.
            mightHavePendingSyncWork = true; // At the end of the current event, go through each of the roots and ensure
            // there's a task scheduled for each one at the correct priority.
            if (ReactCurrentActQueue$3.current !== null) {
                // We're inside an `act` scope.
                if (!didScheduleMicrotask_act) {
                    didScheduleMicrotask_act = true;
                    scheduleImmediateTask(processRootScheduleInMicrotask);
                }
            } else {
                if (!didScheduleMicrotask) {
                    didScheduleMicrotask = true;
                    scheduleImmediateTask(processRootScheduleInMicrotask);
                }
            }
            if (ReactCurrentActQueue$3.isBatchingLegacy && root.tag === LegacyRoot) {
                // Special `act` case: Record whenever a legacy update is scheduled.
                ReactCurrentActQueue$3.didScheduleLegacyUpdate = true;
            }
        }
        function flushSyncWorkOnAllRoots() {
            // This is allowed to be called synchronously, but the caller should check
            // the execution context first.
            flushSyncWorkAcrossRoots_impl(false);
        }
        function flushSyncWorkOnLegacyRootsOnly() {
            // This is allowed to be called synchronously, but the caller should check
            // the execution context first.
            flushSyncWorkAcrossRoots_impl(true);
        }
        function flushSyncWorkAcrossRoots_impl(onlyLegacy) {
            if (isFlushingWork) {
                // Prevent reentrancy.
                // TODO: Is this overly defensive? The callers must check the execution
                // context first regardless.
                return;
            }
            if (!mightHavePendingSyncWork) {
                // Fast path. There's no sync work to do.
                return;
            } // There may or may not be synchronous work scheduled. Let's check.
            var didPerformSomeWork;
            var errors = null;
            isFlushingWork = true;
            do {
                didPerformSomeWork = false;
                var root = firstScheduledRoot;
                while(root !== null){
                    if (onlyLegacy && root.tag !== LegacyRoot) ;
                    else {
                        var workInProgressRoot = getWorkInProgressRoot();
                        var workInProgressRootRenderLanes = getWorkInProgressRootRenderLanes();
                        var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
                        if (includesSyncLane(nextLanes)) {
                            // This root has pending sync work. Flush it now.
                            try {
                                didPerformSomeWork = true;
                                performSyncWorkOnRoot(root, nextLanes);
                            } catch (error) {
                                // Collect errors so we can rethrow them at the end
                                if (errors === null) {
                                    errors = [
                                        error
                                    ];
                                } else {
                                    errors.push(error);
                                }
                            }
                        }
                    }
                    root = root.next;
                }
            }while (didPerformSomeWork)
            isFlushingWork = false; // If any errors were thrown, rethrow them right before exiting.
            // TODO: Consider returning these to the caller, to allow them to decide
            // how/when to rethrow.
            if (errors !== null) {
                if (errors.length > 1) {
                    if (typeof AggregateError === 'function') {
                        // eslint-disable-next-line no-undef
                        throw new AggregateError(errors);
                    } else {
                        for(var i = 1; i < errors.length; i++){
                            scheduleImmediateTask(throwError.bind(null, errors[i]));
                        }
                        var firstError = errors[0];
                        throw firstError;
                    }
                } else {
                    var error = errors[0];
                    throw error;
                }
            }
        }
        function throwError(error) {
            throw error;
        }
        function processRootScheduleInMicrotask() {
            // This function is always called inside a microtask. It should never be
            // called synchronously.
            didScheduleMicrotask = false;
            {
                didScheduleMicrotask_act = false;
            }
            mightHavePendingSyncWork = false;
            var currentTime = now$1();
            var prev = null;
            var root = firstScheduledRoot;
            while(root !== null){
                var next = root.next;
                if (currentEventTransitionLane !== NoLane && shouldAttemptEagerTransition()) {
                    // A transition was scheduled during an event, but we're going to try to
                    // render it synchronously anyway. We do this during a popstate event to
                    // preserve the scroll position of the previous page.
                    upgradePendingLaneToSync(root, currentEventTransitionLane);
                }
                var nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
                if (nextLanes === NoLane) {
                    // This root has no more pending work. Remove it from the schedule. To
                    // guard against subtle reentrancy bugs, this microtask is the only place
                    // we do this — you can add roots to the schedule whenever, but you can
                    // only remove them here.
                    // Null this out so we know it's been removed from the schedule.
                    root.next = null;
                    if (prev === null) {
                        // This is the new head of the list
                        firstScheduledRoot = next;
                    } else {
                        prev.next = next;
                    }
                    if (next === null) {
                        // This is the new tail of the list
                        lastScheduledRoot = prev;
                    }
                } else {
                    // This root still has work. Keep it in the list.
                    prev = root;
                    if (includesSyncLane(nextLanes)) {
                        mightHavePendingSyncWork = true;
                    }
                }
                root = next;
            }
            currentEventTransitionLane = NoLane; // At the end of the microtask, flush any pending synchronous work. This has
            // to come at the end, because it does actual rendering work that might throw.
            flushSyncWorkOnAllRoots();
        }
        function scheduleTaskForRootDuringMicrotask(root, currentTime) {
            // This function is always called inside a microtask, or at the very end of a
            // rendering task right before we yield to the main thread. It should never be
            // called synchronously.
            //
            // TODO: Unless enableDeferRootSchedulingToMicrotask is off. We need to land
            // that ASAP to unblock additional features we have planned.
            //
            // This function also never performs React work synchronously; it should
            // only schedule work to be performed later, in a separate task or microtask.
            // Check if any lanes are being starved by other work. If so, mark them as
            // expired so we know to work on those next.
            markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.
            var workInProgressRoot = getWorkInProgressRoot();
            var workInProgressRootRenderLanes = getWorkInProgressRootRenderLanes();
            var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            var existingCallbackNode = root.callbackNode;
            if (nextLanes === NoLanes || // If this root is currently suspended and waiting for data to resolve, don't
            // schedule a task to render it. We'll either wait for a ping, or wait to
            // receive an update.
            //
            // Suspended render phase
            root === workInProgressRoot && isWorkLoopSuspendedOnData() || // Suspended commit phase
            root.cancelPendingCommit !== null) {
                // Fast path: There's nothing to work on.
                if (existingCallbackNode !== null) {
                    cancelCallback(existingCallbackNode);
                }
                root.callbackNode = null;
                root.callbackPriority = NoLane;
                return NoLane;
            } // Schedule a new callback in the host environment.
            if (includesSyncLane(nextLanes)) {
                // Synchronous work is always flushed at the end of the microtask, so we
                // don't need to schedule an additional task.
                if (existingCallbackNode !== null) {
                    cancelCallback(existingCallbackNode);
                }
                root.callbackPriority = SyncLane;
                root.callbackNode = null;
                return SyncLane;
            } else {
                // We use the highest priority lane to represent the priority of the callback.
                var existingCallbackPriority = root.callbackPriority;
                var newCallbackPriority = getHighestPriorityLane(nextLanes);
                if (newCallbackPriority === existingCallbackPriority && // Special case related to `act`. If the currently scheduled task is a
                // Scheduler task, rather than an `act` task, cancel it and re-schedule
                // on the `act` queue.
                !(ReactCurrentActQueue$3.current !== null && existingCallbackNode !== fakeActCallbackNode$1)) {
                    // The priority hasn't changed. We can reuse the existing task.
                    return newCallbackPriority;
                } else {
                    // Cancel the existing callback. We'll schedule a new one below.
                    cancelCallback(existingCallbackNode);
                }
                var schedulerPriorityLevel;
                switch(lanesToEventPriority(nextLanes)){
                    case DiscreteEventPriority:
                        schedulerPriorityLevel = ImmediatePriority;
                        break;
                    case ContinuousEventPriority:
                        schedulerPriorityLevel = UserBlockingPriority;
                        break;
                    case DefaultEventPriority:
                        schedulerPriorityLevel = NormalPriority$1;
                        break;
                    case IdleEventPriority:
                        schedulerPriorityLevel = IdlePriority;
                        break;
                    default:
                        schedulerPriorityLevel = NormalPriority$1;
                        break;
                }
                var newCallbackNode = scheduleCallback$2(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));
                root.callbackPriority = newCallbackPriority;
                root.callbackNode = newCallbackNode;
                return newCallbackPriority;
            }
        }
        function getContinuationForRoot(root, originalCallbackNode) {
            // This is called at the end of `performConcurrentWorkOnRoot` to determine
            // if we need to schedule a continuation task.
            //
            // Usually `scheduleTaskForRootDuringMicrotask` only runs inside a microtask;
            // however, since most of the logic for determining if we need a continuation
            // versus a new task is the same, we cheat a bit and call it here. This is
            // only safe to do because we know we're at the end of the browser task.
            // So although it's not an actual microtask, it might as well be.
            scheduleTaskForRootDuringMicrotask(root, now$1());
            if (root.callbackNode === originalCallbackNode) {
                // The task node scheduled for this root is the same one that's
                // currently executed. Need to return a continuation.
                return performConcurrentWorkOnRoot.bind(null, root);
            }
            return null;
        }
        var fakeActCallbackNode$1 = {};
        function scheduleCallback$2(priorityLevel, callback) {
            if (ReactCurrentActQueue$3.current !== null) {
                // Special case: We're inside an `act` scope (a testing utility).
                // Instead of scheduling work in the host environment, add it to a
                // fake internal queue that's managed by the `act` implementation.
                ReactCurrentActQueue$3.current.push(callback);
                return fakeActCallbackNode$1;
            } else {
                return scheduleCallback$3(priorityLevel, callback);
            }
        }
        function cancelCallback(callbackNode) {
            if (callbackNode === fakeActCallbackNode$1) ;
            else if (callbackNode !== null) {
                cancelCallback$1(callbackNode);
            }
        }
        function scheduleImmediateTask(cb) {
            if (ReactCurrentActQueue$3.current !== null) {
                // Special case: Inside an `act` scope, we push microtasks to the fake `act`
                // callback queue. This is because we currently support calling `act`
                // without awaiting the result. The plan is to deprecate that, and require
                // that you always await the result so that the microtasks have a chance to
                // run. But it hasn't happened yet.
                ReactCurrentActQueue$3.current.push(function() {
                    cb();
                    return null;
                });
            } // TODO: Can we land supportsMicrotasks? Which environments don't support it?
            // Alternatively, can we move this check to the host config?
            {
                scheduleMicrotask(function() {
                    // In Safari, appending an iframe forces microtasks to run.
                    // https://github.com/facebook/react/issues/22459
                    // We don't support running callbacks in the middle of render
                    // or commit so we need to check against that.
                    var executionContext = getExecutionContext();
                    if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
                        // Note that this would still prematurely flush the callbacks
                        // if this happens outside render or commit phase (e.g. in an event).
                        // Intentionally using a macrotask instead of a microtask here. This is
                        // wrong semantically but it prevents an infinite loop. The bug is
                        // Safari's, not ours, so we just do our best to not crash even though
                        // the behavior isn't completely correct.
                        scheduleCallback$3(ImmediatePriority, cb);
                        return;
                    }
                    cb();
                });
            }
        }
        function requestTransitionLane(// check that it's inside a transition before calling this function.
        // TODO: Make this non-nullable. Requires a tweak to useOptimistic.
        transition) {
            // The algorithm for assigning an update to a lane should be stable for all
            // updates at the same priority within the same event. To do this, the
            // inputs to the algorithm must be the same.
            //
            // The trick we use is to cache the first of each of these inputs within an
            // event. Then reset the cached values once we can be sure the event is
            // over. Our heuristic for that is whenever we enter a concurrent work loop.
            if (currentEventTransitionLane === NoLane) {
                // All transitions within the same event are assigned the same lane.
                currentEventTransitionLane = claimNextTransitionLane();
            }
            return currentEventTransitionLane;
        }
        // transition updates that occur while the async action is still in progress
        // are treated as part of the action.
        //
        // The ideal behavior would be to treat each async function as an independent
        // action. However, without a mechanism like AsyncContext, we can't tell which
        // action an update corresponds to. So instead, we entangle them all into one.
        // The listeners to notify once the entangled scope completes.
        var currentEntangledListeners = null; // The number of pending async actions in the entangled scope.
        var currentEntangledPendingCount = 0; // The transition lane shared by all updates in the entangled scope.
        var currentEntangledLane = NoLane; // A thenable that resolves when the entangled scope completes. It does not
        // resolve to a particular value because it's only used for suspending the UI
        // until the async action scope has completed.
        var currentEntangledActionThenable = null;
        function entangleAsyncAction(transition, thenable) {
            // `thenable` is the return value of the async action scope function. Create
            // a combined thenable that resolves once every entangled scope function
            // has finished.
            if (currentEntangledListeners === null) {
                // There's no outer async action scope. Create a new one.
                var entangledListeners = currentEntangledListeners = [];
                currentEntangledPendingCount = 0;
                currentEntangledLane = requestTransitionLane();
                var entangledThenable = {
                    status: 'pending',
                    value: undefined,
                    then: function(resolve) {
                        entangledListeners.push(resolve);
                    }
                };
                currentEntangledActionThenable = entangledThenable;
            }
            currentEntangledPendingCount++;
            thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
            return thenable;
        }
        function pingEngtangledActionScope() {
            if (currentEntangledListeners !== null && --currentEntangledPendingCount === 0) {
                // All the actions have finished. Close the entangled async action scope
                // and notify all the listeners.
                if (currentEntangledActionThenable !== null) {
                    var fulfilledThenable = currentEntangledActionThenable;
                    fulfilledThenable.status = 'fulfilled';
                }
                var listeners = currentEntangledListeners;
                currentEntangledListeners = null;
                currentEntangledLane = NoLane;
                currentEntangledActionThenable = null;
                for(var i = 0; i < listeners.length; i++){
                    var listener = listeners[i];
                    listener();
                }
            }
        }
        function chainThenableValue(thenable, result) {
            // Equivalent to: Promise.resolve(thenable).then(() => result), except we can
            // cheat a bit since we know that that this thenable is only ever consumed
            // by React.
            //
            // We don't technically require promise support on the client yet, hence this
            // extra code.
            var listeners = [];
            var thenableWithOverride = {
                status: 'pending',
                value: null,
                reason: null,
                then: function(resolve) {
                    listeners.push(resolve);
                }
            };
            thenable.then(function(value) {
                var fulfilledThenable = thenableWithOverride;
                fulfilledThenable.status = 'fulfilled';
                fulfilledThenable.value = result;
                for(var i = 0; i < listeners.length; i++){
                    var listener = listeners[i];
                    listener(result);
                }
            }, function(error) {
                var rejectedThenable = thenableWithOverride;
                rejectedThenable.status = 'rejected';
                rejectedThenable.reason = error;
                for(var i = 0; i < listeners.length; i++){
                    var listener = listeners[i]; // This is a perf hack where we call the `onFulfill` ping function
                    // instead of `onReject`, because we know that React is the only
                    // consumer of these promises, and it passes the same listener to both.
                    // We also know that it will read the error directly off the
                    // `.reason` field.
                    listener(undefined);
                }
            });
            return thenableWithOverride;
        }
        function peekEntangledActionLane() {
            return currentEntangledLane;
        }
        function peekEntangledActionThenable() {
            return currentEntangledActionThenable;
        }
        var UpdateState = 0;
        var ReplaceState = 1;
        var ForceUpdate = 2;
        var CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.
        // It should only be read right after calling `processUpdateQueue`, via
        // `checkHasForceUpdateAfterProcessing`.
        var hasForceUpdate = false;
        var didWarnUpdateInsideUpdate;
        var currentlyProcessingQueue;
        {
            didWarnUpdateInsideUpdate = false;
            currentlyProcessingQueue = null;
        }
        function initializeUpdateQueue(fiber) {
            var queue = {
                baseState: fiber.memoizedState,
                firstBaseUpdate: null,
                lastBaseUpdate: null,
                shared: {
                    pending: null,
                    lanes: NoLanes,
                    hiddenCallbacks: null
                },
                callbacks: null
            };
            fiber.updateQueue = queue;
        }
        function cloneUpdateQueue(current, workInProgress) {
            // Clone the update queue from current. Unless it's already a clone.
            var queue = workInProgress.updateQueue;
            var currentQueue = current.updateQueue;
            if (queue === currentQueue) {
                var clone = {
                    baseState: currentQueue.baseState,
                    firstBaseUpdate: currentQueue.firstBaseUpdate,
                    lastBaseUpdate: currentQueue.lastBaseUpdate,
                    shared: currentQueue.shared,
                    callbacks: null
                };
                workInProgress.updateQueue = clone;
            }
        }
        function createUpdate(lane) {
            var update = {
                lane: lane,
                tag: UpdateState,
                payload: null,
                callback: null,
                next: null
            };
            return update;
        }
        function enqueueUpdate(fiber, update, lane) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
                // Only occurs if the fiber has been unmounted.
                return null;
            }
            var sharedQueue = updateQueue.shared;
            {
                if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
                    var componentName = getComponentNameFromFiber(fiber);
                    error('An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.\n\nPlease update the following component: %s', componentName);
                    didWarnUpdateInsideUpdate = true;
                }
            }
            if (isUnsafeClassRenderPhaseUpdate()) {
                // This is an unsafe render phase update. Add directly to the update
                // queue so we can process it immediately during the current render.
                var pending = sharedQueue.pending;
                if (pending === null) {
                    // This is the first update. Create a circular list.
                    update.next = update;
                } else {
                    update.next = pending.next;
                    pending.next = update;
                }
                sharedQueue.pending = update; // Update the childLanes even though we're most likely already rendering
                // this fiber. This is for backwards compatibility in the case where you
                // update a different component during render phase than the one that is
                // currently renderings (a pattern that is accompanied by a warning).
                return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
            } else {
                return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
            }
        }
        function entangleTransitions(root, fiber, lane) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
                // Only occurs if the fiber has been unmounted.
                return;
            }
            var sharedQueue = updateQueue.shared;
            if (isTransitionLane(lane)) {
                var queueLanes = sharedQueue.lanes; // If any entangled lanes are no longer pending on the root, then they must
                // have finished. We can remove them from the shared queue, which represents
                // a superset of the actually pending lanes. In some cases we may entangle
                // more than we need to, but that's OK. In fact it's worse if we *don't*
                // entangle when we should.
                queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.
                var newQueueLanes = mergeLanes(queueLanes, lane);
                sharedQueue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if
                // the lane finished since the last time we entangled it. So we need to
                // entangle it again, just to be sure.
                markRootEntangled(root, newQueueLanes);
            }
        }
        function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
            // Captured updates are updates that are thrown by a child during the render
            // phase. They should be discarded if the render is aborted. Therefore,
            // we should only put them on the work-in-progress queue, not the current one.
            var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.
            var current = workInProgress.alternate;
            if (current !== null) {
                var currentQueue = current.updateQueue;
                if (queue === currentQueue) {
                    // The work-in-progress queue is the same as current. This happens when
                    // we bail out on a parent fiber that then captures an error thrown by
                    // a child. Since we want to append the update only to the work-in
                    // -progress queue, we need to clone the updates. We usually clone during
                    // processUpdateQueue, but that didn't happen in this case because we
                    // skipped over the parent when we bailed out.
                    var newFirst = null;
                    var newLast = null;
                    var firstBaseUpdate = queue.firstBaseUpdate;
                    if (firstBaseUpdate !== null) {
                        // Loop through the updates and clone them.
                        var update = firstBaseUpdate;
                        do {
                            var clone = {
                                lane: update.lane,
                                tag: update.tag,
                                payload: update.payload,
                                // When this update is rebased, we should not fire its
                                // callback again.
                                callback: null,
                                next: null
                            };
                            if (newLast === null) {
                                newFirst = newLast = clone;
                            } else {
                                newLast.next = clone;
                                newLast = clone;
                            } // $FlowFixMe[incompatible-type] we bail out when we get a null
                            update = update.next;
                        }while (update !== null) // Append the captured update the end of the cloned list.
                        if (newLast === null) {
                            newFirst = newLast = capturedUpdate;
                        } else {
                            newLast.next = capturedUpdate;
                            newLast = capturedUpdate;
                        }
                    } else {
                        // There are no base updates.
                        newFirst = newLast = capturedUpdate;
                    }
                    queue = {
                        baseState: currentQueue.baseState,
                        firstBaseUpdate: newFirst,
                        lastBaseUpdate: newLast,
                        shared: currentQueue.shared,
                        callbacks: currentQueue.callbacks
                    };
                    workInProgress.updateQueue = queue;
                    return;
                }
            } // Append the update to the end of the list.
            var lastBaseUpdate = queue.lastBaseUpdate;
            if (lastBaseUpdate === null) {
                queue.firstBaseUpdate = capturedUpdate;
            } else {
                lastBaseUpdate.next = capturedUpdate;
            }
            queue.lastBaseUpdate = capturedUpdate;
        }
        function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
            switch(update.tag){
                case ReplaceState:
                    {
                        var payload = update.payload;
                        if (typeof payload === 'function') {
                            // Updater function
                            {
                                enterDisallowedContextReadInDEV();
                            }
                            var nextState = payload.call(instance, prevState, nextProps);
                            {
                                if (workInProgress.mode & StrictLegacyMode) {
                                    setIsStrictModeForDevtools(true);
                                    try {
                                        payload.call(instance, prevState, nextProps);
                                    } finally{
                                        setIsStrictModeForDevtools(false);
                                    }
                                }
                                exitDisallowedContextReadInDEV();
                            }
                            return nextState;
                        } // State object
                        return payload;
                    }
                case CaptureUpdate:
                    {
                        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;
                    }
                // Intentional fallthrough
                case UpdateState:
                    {
                        var _payload = update.payload;
                        var partialState;
                        if (typeof _payload === 'function') {
                            // Updater function
                            {
                                enterDisallowedContextReadInDEV();
                            }
                            partialState = _payload.call(instance, prevState, nextProps);
                            {
                                if (workInProgress.mode & StrictLegacyMode) {
                                    setIsStrictModeForDevtools(true);
                                    try {
                                        _payload.call(instance, prevState, nextProps);
                                    } finally{
                                        setIsStrictModeForDevtools(false);
                                    }
                                }
                                exitDisallowedContextReadInDEV();
                            }
                        } else {
                            // Partial state object
                            partialState = _payload;
                        }
                        if (partialState === null || partialState === undefined) {
                            // Null and undefined are treated as no-ops.
                            return prevState;
                        } // Merge the partial state and the previous state.
                        return assign({}, prevState, partialState);
                    }
                case ForceUpdate:
                    {
                        hasForceUpdate = true;
                        return prevState;
                    }
            }
            return prevState;
        }
        var didReadFromEntangledAsyncAction = false; // Each call to processUpdateQueue should be accompanied by a call to this. It's
        // only in a separate function because in updateHostRoot, it must happen after
        // all the context stacks have been pushed to, to prevent a stack mismatch. A
        // bit unfortunate.
        function suspendIfUpdateReadFromEntangledAsyncAction() {
            // Check if this update is part of a pending async action. If so, we'll
            // need to suspend until the action has finished, so that it's batched
            // together with future updates in the same action.
            // TODO: Once we support hooks inside useMemo (or an equivalent
            // memoization boundary like Forget), hoist this logic so that it only
            // suspends if the memo boundary produces a new value.
            if (didReadFromEntangledAsyncAction) {
                var entangledActionThenable = peekEntangledActionThenable();
                if (entangledActionThenable !== null) {
                    // TODO: Instead of the throwing the thenable directly, throw a
                    // special object like `use` does so we can detect if it's captured
                    // by userspace.
                    throw entangledActionThenable;
                }
            }
        }
        function processUpdateQueue(workInProgress, props, instance, renderLanes) {
            didReadFromEntangledAsyncAction = false; // This is always non-null on a ClassComponent or HostRoot
            var queue = workInProgress.updateQueue;
            hasForceUpdate = false;
            {
                currentlyProcessingQueue = queue.shared;
            }
            var firstBaseUpdate = queue.firstBaseUpdate;
            var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.
            var pendingQueue = queue.shared.pending;
            if (pendingQueue !== null) {
                queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first
                // and last so that it's non-circular.
                var lastPendingUpdate = pendingQueue;
                var firstPendingUpdate = lastPendingUpdate.next;
                lastPendingUpdate.next = null; // Append pending updates to base queue
                if (lastBaseUpdate === null) {
                    firstBaseUpdate = firstPendingUpdate;
                } else {
                    lastBaseUpdate.next = firstPendingUpdate;
                }
                lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then
                // we need to transfer the updates to that queue, too. Because the base
                // queue is a singly-linked list with no cycles, we can append to both
                // lists and take advantage of structural sharing.
                // TODO: Pass `current` as argument
                var current = workInProgress.alternate;
                if (current !== null) {
                    // This is always non-null on a ClassComponent or HostRoot
                    var currentQueue = current.updateQueue;
                    var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
                    if (currentLastBaseUpdate !== lastBaseUpdate) {
                        if (currentLastBaseUpdate === null) {
                            currentQueue.firstBaseUpdate = firstPendingUpdate;
                        } else {
                            currentLastBaseUpdate.next = firstPendingUpdate;
                        }
                        currentQueue.lastBaseUpdate = lastPendingUpdate;
                    }
                }
            } // These values may change as we process the queue.
            if (firstBaseUpdate !== null) {
                // Iterate through the list of updates to compute the result.
                var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes
                // from the original lanes.
                var newLanes = NoLanes;
                var newBaseState = null;
                var newFirstBaseUpdate = null;
                var newLastBaseUpdate = null;
                var update = firstBaseUpdate;
                do {
                    // An extra OffscreenLane bit is added to updates that were made to
                    // a hidden tree, so that we can distinguish them from updates that were
                    // already there when the tree was hidden.
                    var updateLane = removeLanes(update.lane, OffscreenLane);
                    var isHiddenUpdate = updateLane !== update.lane; // Check if this update was made while the tree was hidden. If so, then
                    // it's not a "base" update and we should disregard the extra base lanes
                    // that were added to renderLanes when we entered the Offscreen tree.
                    var shouldSkipUpdate = isHiddenUpdate ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane) : !isSubsetOfLanes(renderLanes, updateLane);
                    if (shouldSkipUpdate) {
                        // Priority is insufficient. Skip this update. If this is the first
                        // skipped update, the previous update/state is the new base
                        // update/state.
                        var clone = {
                            lane: updateLane,
                            tag: update.tag,
                            payload: update.payload,
                            callback: update.callback,
                            next: null
                        };
                        if (newLastBaseUpdate === null) {
                            newFirstBaseUpdate = newLastBaseUpdate = clone;
                            newBaseState = newState;
                        } else {
                            newLastBaseUpdate = newLastBaseUpdate.next = clone;
                        } // Update the remaining priority in the queue.
                        newLanes = mergeLanes(newLanes, updateLane);
                    } else {
                        // This update does have sufficient priority.
                        // Check if this update is part of a pending async action. If so,
                        // we'll need to suspend until the action has finished, so that it's
                        // batched together with future updates in the same action.
                        if (updateLane !== NoLane && updateLane === peekEntangledActionLane()) {
                            didReadFromEntangledAsyncAction = true;
                        }
                        if (newLastBaseUpdate !== null) {
                            var _clone = {
                                // This update is going to be committed so we never want uncommit
                                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                                // this will never be skipped by the check above.
                                lane: NoLane,
                                tag: update.tag,
                                payload: update.payload,
                                // When this update is rebased, we should not fire its
                                // callback again.
                                callback: null,
                                next: null
                            };
                            newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                        } // Process this update.
                        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);
                        var callback = update.callback;
                        if (callback !== null) {
                            workInProgress.flags |= Callback;
                            if (isHiddenUpdate) {
                                workInProgress.flags |= Visibility;
                            }
                            var callbacks = queue.callbacks;
                            if (callbacks === null) {
                                queue.callbacks = [
                                    callback
                                ];
                            } else {
                                callbacks.push(callback);
                            }
                        }
                    } // $FlowFixMe[incompatible-type] we bail out when we get a null
                    update = update.next;
                    if (update === null) {
                        pendingQueue = queue.shared.pending;
                        if (pendingQueue === null) {
                            break;
                        } else {
                            // An update was scheduled from inside a reducer. Add the new
                            // pending updates to the end of the list and keep processing.
                            var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we
                            // unravel them when transferring them to the base queue.
                            var _firstPendingUpdate = _lastPendingUpdate.next;
                            _lastPendingUpdate.next = null;
                            update = _firstPendingUpdate;
                            queue.lastBaseUpdate = _lastPendingUpdate;
                            queue.shared.pending = null;
                        }
                    }
                }while (true)
                if (newLastBaseUpdate === null) {
                    newBaseState = newState;
                }
                queue.baseState = newBaseState;
                queue.firstBaseUpdate = newFirstBaseUpdate;
                queue.lastBaseUpdate = newLastBaseUpdate;
                if (firstBaseUpdate === null) {
                    // `queue.lanes` is used for entangling transitions. We can set it back to
                    // zero once the queue is empty.
                    queue.shared.lanes = NoLanes;
                } // Set the remaining expiration time to be whatever is remaining in the queue.
                // This should be fine because the only two other things that contribute to
                // expiration time are props and context. We're already in the middle of the
                // begin phase by the time we start processing the queue, so we've already
                // dealt with the props. Context in components that specify
                // shouldComponentUpdate is tricky; but we'll have to account for
                // that regardless.
                markSkippedUpdateLanes(newLanes);
                workInProgress.lanes = newLanes;
                workInProgress.memoizedState = newState;
            }
            {
                currentlyProcessingQueue = null;
            }
        }
        function callCallback(callback, context) {
            if (typeof callback !== 'function') {
                throw new Error('Invalid argument passed as callback. Expected a function. Instead ' + ("received: " + callback));
            }
            callback.call(context);
        }
        function resetHasForceUpdateBeforeProcessing() {
            hasForceUpdate = false;
        }
        function checkHasForceUpdateAfterProcessing() {
            return hasForceUpdate;
        }
        function deferHiddenCallbacks(updateQueue) {
            // When an update finishes on a hidden component, its callback should not
            // be fired until/unless the component is made visible again. Stash the
            // callback on the shared queue object so it can be fired later.
            var newHiddenCallbacks = updateQueue.callbacks;
            if (newHiddenCallbacks !== null) {
                var existingHiddenCallbacks = updateQueue.shared.hiddenCallbacks;
                if (existingHiddenCallbacks === null) {
                    updateQueue.shared.hiddenCallbacks = newHiddenCallbacks;
                } else {
                    updateQueue.shared.hiddenCallbacks = existingHiddenCallbacks.concat(newHiddenCallbacks);
                }
            }
        }
        function commitHiddenCallbacks(updateQueue, context) {
            // This component is switching from hidden -> visible. Commit any callbacks
            // that were previously deferred.
            var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
            if (hiddenCallbacks !== null) {
                updateQueue.shared.hiddenCallbacks = null;
                for(var i = 0; i < hiddenCallbacks.length; i++){
                    var callback = hiddenCallbacks[i];
                    callCallback(callback, context);
                }
            }
        }
        function commitCallbacks(updateQueue, context) {
            var callbacks = updateQueue.callbacks;
            if (callbacks !== null) {
                updateQueue.callbacks = null;
                for(var i = 0; i < callbacks.length; i++){
                    var callback = callbacks[i];
                    callCallback(callback, context);
                }
            }
        }
        /**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */ function shallowEqual(objA, objB) {
            if (objectIs(objA, objB)) {
                return true;
            }
            if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
                return false;
            }
            var keysA = Object.keys(objA);
            var keysB = Object.keys(objB);
            if (keysA.length !== keysB.length) {
                return false;
            } // Test for A's keys different from B.
            for(var i = 0; i < keysA.length; i++){
                var currentKey = keysA[i];
                if (!hasOwnProperty.call(objB, currentKey) || // $FlowFixMe[incompatible-use] lost refinement of `objB`
                !objectIs(objA[currentKey], objB[currentKey])) {
                    return false;
                }
            }
            return true;
        }
        var ReactStrictModeWarnings = {
            recordUnsafeLifecycleWarnings: function(fiber, instance) {},
            flushPendingUnsafeLifecycleWarnings: function() {},
            recordLegacyContextWarning: function(fiber, instance) {},
            flushLegacyContextWarning: function() {},
            discardPendingWarnings: function() {}
        };
        {
            var findStrictRoot = function(fiber) {
                var maybeStrictRoot = null;
                var node = fiber;
                while(node !== null){
                    if (node.mode & StrictLegacyMode) {
                        maybeStrictRoot = node;
                    }
                    node = node.return;
                }
                return maybeStrictRoot;
            };
            var setToSortedString = function(set) {
                var array = [];
                set.forEach(function(value) {
                    array.push(value);
                });
                return array.sort().join(', ');
            };
            var pendingComponentWillMountWarnings = [];
            var pendingUNSAFE_ComponentWillMountWarnings = [];
            var pendingComponentWillReceivePropsWarnings = [];
            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            var pendingComponentWillUpdateWarnings = [];
            var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.
            var didWarnAboutUnsafeLifecycles = new Set();
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
                // Dedupe strategy: Warn once per component.
                if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
                    return;
                }
                if (typeof instance.componentWillMount === 'function' && // Don't warn about react-lifecycles-compat polyfilled components.
                instance.componentWillMount.__suppressDeprecationWarning !== true) {
                    pendingComponentWillMountWarnings.push(fiber);
                }
                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === 'function') {
                    pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
                }
                if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                    pendingComponentWillReceivePropsWarnings.push(fiber);
                }
                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
                    pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
                }
                if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                    pendingComponentWillUpdateWarnings.push(fiber);
                }
                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === 'function') {
                    pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
                }
            };
            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
                // We do an initial pass to gather component names
                var componentWillMountUniqueNames = new Set();
                if (pendingComponentWillMountWarnings.length > 0) {
                    pendingComponentWillMountWarnings.forEach(function(fiber) {
                        componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                        didWarnAboutUnsafeLifecycles.add(fiber.type);
                    });
                    pendingComponentWillMountWarnings = [];
                }
                var UNSAFE_componentWillMountUniqueNames = new Set();
                if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
                    pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                        UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                        didWarnAboutUnsafeLifecycles.add(fiber.type);
                    });
                    pendingUNSAFE_ComponentWillMountWarnings = [];
                }
                var componentWillReceivePropsUniqueNames = new Set();
                if (pendingComponentWillReceivePropsWarnings.length > 0) {
                    pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                        componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                        didWarnAboutUnsafeLifecycles.add(fiber.type);
                    });
                    pendingComponentWillReceivePropsWarnings = [];
                }
                var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
                if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
                    pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                        didWarnAboutUnsafeLifecycles.add(fiber.type);
                    });
                    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
                }
                var componentWillUpdateUniqueNames = new Set();
                if (pendingComponentWillUpdateWarnings.length > 0) {
                    pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                        componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                        didWarnAboutUnsafeLifecycles.add(fiber.type);
                    });
                    pendingComponentWillUpdateWarnings = [];
                }
                var UNSAFE_componentWillUpdateUniqueNames = new Set();
                if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
                    pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                        UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                        didWarnAboutUnsafeLifecycles.add(fiber.type);
                    });
                    pendingUNSAFE_ComponentWillUpdateWarnings = [];
                } // Finally, we flush all the warnings
                // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'
                if (UNSAFE_componentWillMountUniqueNames.size > 0) {
                    var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
                    error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\n' + '\nPlease update the following components: %s', sortedNames);
                }
                if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
                    var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
                    error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + "* If you're updating state whenever props change, " + 'refactor your code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n' + '\nPlease update the following components: %s', _sortedNames);
                }
                if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
                    var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
                    error('Using UNSAFE_componentWillUpdate in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + '\nPlease update the following components: %s', _sortedNames2);
                }
                if (componentWillMountUniqueNames.size > 0) {
                    var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
                    warn('componentWillMount has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\n' + '* Rename componentWillMount to UNSAFE_componentWillMount to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames3);
                }
                if (componentWillReceivePropsUniqueNames.size > 0) {
                    var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
                    warn('componentWillReceiveProps has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + "* If you're updating state whenever props change, refactor your " + 'code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n' + '* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames4);
                }
                if (componentWillUpdateUniqueNames.size > 0) {
                    var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
                    warn('componentWillUpdate has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + '* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames5);
                }
            };
            var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.
            var didWarnAboutLegacyContext = new Set();
            ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
                var strictRoot = findStrictRoot(fiber);
                if (strictRoot === null) {
                    error('Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                    return;
                } // Dedup strategy: Warn once per component.
                if (didWarnAboutLegacyContext.has(fiber.type)) {
                    return;
                }
                var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
                if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {
                    if (warningsForRoot === undefined) {
                        warningsForRoot = [];
                        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
                    }
                    warningsForRoot.push(fiber);
                }
            };
            ReactStrictModeWarnings.flushLegacyContextWarning = function() {
                pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
                    if (fiberArray.length === 0) {
                        return;
                    }
                    var firstFiber = fiberArray[0];
                    var uniqueNames = new Set();
                    fiberArray.forEach(function(fiber) {
                        uniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');
                        didWarnAboutLegacyContext.add(fiber.type);
                    });
                    var sortedNames = setToSortedString(uniqueNames);
                    try {
                        setCurrentFiber(firstFiber);
                        error('Legacy context API has been detected within a strict-mode tree.' + '\n\nThe old API will be supported in all 16.x releases, but applications ' + 'using it should migrate to the new version.' + '\n\nPlease update the following components: %s' + '\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context', sortedNames);
                    } finally{
                        resetCurrentFiber();
                    }
                });
            };
            ReactStrictModeWarnings.discardPendingWarnings = function() {
                pendingComponentWillMountWarnings = [];
                pendingUNSAFE_ComponentWillMountWarnings = [];
                pendingComponentWillReceivePropsWarnings = [];
                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
                pendingComponentWillUpdateWarnings = [];
                pendingUNSAFE_ComponentWillUpdateWarnings = [];
                pendingLegacyContextWarning = new Map();
            };
        }
        var ReactCurrentActQueue$2 = ReactSharedInternals.ReactCurrentActQueue;
        function getThenablesFromState(state) {
            {
                var devState = state;
                return devState.thenables;
            }
        } // An error that is thrown (e.g. by `use`) to trigger Suspense. If we
        // detect this is caught by userspace, we'll log a warning in development.
        var SuspenseException = new Error("Suspense Exception: This is not a real error! It's an implementation " + 'detail of `use` to interrupt the current render. You must either ' + 'rethrow it immediately, or move the `use` call outside of the ' + '`try/catch` block. Capturing without rethrowing will lead to ' + 'unexpected behavior.\n\n' + 'To handle async errors, wrap your component in an error boundary, or ' + "call the promise's `.catch` method and pass the result to `use`");
        var SuspenseyCommitException = new Error('Suspense Exception: This is not a real error, and should not leak into ' + "userspace. If you're seeing this, it's likely a bug in React."); // This is a noop thenable that we use to trigger a fallback in throwException.
        // TODO: It would be better to refactor throwException into multiple functions
        // so we can trigger a fallback directly without having to check the type. But
        // for now this will do.
        var noopSuspenseyCommitThenable = {
            then: function() {
                {
                    error('Internal React error: A listener was unexpectedly attached to a ' + '"noop" thenable. This is a bug in React. Please file an issue.');
                }
            }
        };
        function createThenableState() {
            // The ThenableState is created the first time a component suspends. If it
            // suspends again, we'll reuse the same state.
            {
                return {
                    didWarnAboutUncachedPromise: false,
                    thenables: []
                };
            }
        }
        function isThenableResolved(thenable) {
            var status = thenable.status;
            return status === 'fulfilled' || status === 'rejected';
        }
        function noop$2() {}
        function trackUsedThenable(thenableState, thenable, index) {
            if (ReactCurrentActQueue$2.current !== null) {
                ReactCurrentActQueue$2.didUsePromise = true;
            }
            var trackedThenables = getThenablesFromState(thenableState);
            var previous = trackedThenables[index];
            if (previous === undefined) {
                trackedThenables.push(thenable);
            } else {
                if (previous !== thenable) {
                    // Reuse the previous thenable, and drop the new one. We can assume
                    // they represent the same value, because components are idempotent.
                    {
                        var thenableStateDev = thenableState;
                        if (!thenableStateDev.didWarnAboutUncachedPromise) {
                            // We should only warn the first time an uncached thenable is
                            // discovered per component, because if there are multiple, the
                            // subsequent ones are likely derived from the first.
                            //
                            // We track this on the thenableState instead of deduping using the
                            // component name like we usually do, because in the case of a
                            // promise-as-React-node, the owner component is likely different from
                            // the parent that's currently being reconciled. We'd have to track
                            // the owner using state, which we're trying to move away from. Though
                            // since this is dev-only, maybe that'd be OK.
                            //
                            // However, another benefit of doing it this way is we might
                            // eventually have a thenableState per memo/Forget boundary instead
                            // of per component, so this would allow us to have more
                            // granular warnings.
                            thenableStateDev.didWarnAboutUncachedPromise = true; // TODO: This warning should link to a corresponding docs page.
                            error('A component was suspended by an uncached promise. Creating ' + 'promises inside a Client Component or hook is not yet ' + 'supported, except via a Suspense-compatible library or framework.');
                        }
                    }
                    // intentionally ignore.
                    thenable.then(noop$2, noop$2);
                    thenable = previous;
                }
            } // We use an expando to track the status and result of a thenable so that we
            // can synchronously unwrap the value. Think of this as an extension of the
            // Promise API, or a custom interface that is a superset of Thenable.
            //
            // If the thenable doesn't have a status, set it to "pending" and attach
            // a listener that will update its status and result when it resolves.
            switch(thenable.status){
                case 'fulfilled':
                    {
                        var fulfilledValue = thenable.value;
                        return fulfilledValue;
                    }
                case 'rejected':
                    {
                        var rejectedError = thenable.reason;
                        checkIfUseWrappedInAsyncCatch(rejectedError);
                        throw rejectedError;
                    }
                default:
                    {
                        if (typeof thenable.status === 'string') {
                            // Only instrument the thenable if the status if not defined. If
                            // it's defined, but an unknown value, assume it's been instrumented by
                            // some custom userspace implementation. We treat it as "pending".
                            // Attach a dummy listener, to ensure that any lazy initialization can
                            // happen. Flight lazily parses JSON when the value is actually awaited.
                            thenable.then(noop$2, noop$2);
                        } else {
                            // This is an uncached thenable that we haven't seen before.
                            // Detect infinite ping loops caused by uncached promises.
                            var root = getWorkInProgressRoot();
                            if (root !== null && root.shellSuspendCounter > 100) {
                                // This root has suspended repeatedly in the shell without making any
                                // progress (i.e. committing something). This is highly suggestive of
                                // an infinite ping loop, often caused by an accidental Async Client
                                // Component.
                                //
                                // During a transition, we can suspend the work loop until the promise
                                // to resolve, but this is a sync render, so that's not an option. We
                                // also can't show a fallback, because none was provided. So our last
                                // resort is to throw an error.
                                //
                                // TODO: Remove this error in a future release. Other ways of handling
                                // this case include forcing a concurrent render, or putting the whole
                                // root into offscreen mode.
                                throw new Error('async/await is not yet supported in Client Components, only ' + 'Server Components. This error is often caused by accidentally ' + "adding `'use client'` to a module that was originally written " + 'for the server.');
                            }
                            var pendingThenable = thenable;
                            pendingThenable.status = 'pending';
                            pendingThenable.then(function(fulfilledValue) {
                                if (thenable.status === 'pending') {
                                    var fulfilledThenable = thenable;
                                    fulfilledThenable.status = 'fulfilled';
                                    fulfilledThenable.value = fulfilledValue;
                                }
                            }, function(error) {
                                if (thenable.status === 'pending') {
                                    var rejectedThenable = thenable;
                                    rejectedThenable.status = 'rejected';
                                    rejectedThenable.reason = error;
                                }
                            });
                        } // Check one more time in case the thenable resolved synchronously.
                        switch(thenable.status){
                            case 'fulfilled':
                                {
                                    var fulfilledThenable = thenable;
                                    return fulfilledThenable.value;
                                }
                            case 'rejected':
                                {
                                    var rejectedThenable = thenable;
                                    var _rejectedError = rejectedThenable.reason;
                                    checkIfUseWrappedInAsyncCatch(_rejectedError);
                                    throw _rejectedError;
                                }
                        } // Suspend.
                        //
                        // Throwing here is an implementation detail that allows us to unwind the
                        // call stack. But we shouldn't allow it to leak into userspace. Throw an
                        // opaque placeholder value instead of the actual thenable. If it doesn't
                        // get captured by the work loop, log a warning, because that means
                        // something in userspace must have caught it.
                        suspendedThenable = thenable;
                        {
                            needsToResetSuspendedThenableDEV = true;
                        }
                        throw SuspenseException;
                    }
            }
        }
        function suspendCommit() {
            // This extra indirection only exists so it can handle passing
            // noopSuspenseyCommitThenable through to throwException.
            // TODO: Factor the thenable check out of throwException
            suspendedThenable = noopSuspenseyCommitThenable;
            throw SuspenseyCommitException;
        } // This is used to track the actual thenable that suspended so it can be
        // passed to the rest of the Suspense implementation — which, for historical
        // reasons, expects to receive a thenable.
        var suspendedThenable = null;
        var needsToResetSuspendedThenableDEV = false;
        function getSuspendedThenable() {
            // This is called right after `use` suspends by throwing an exception. `use`
            // throws an opaque value instead of the thenable itself so that it can't be
            // caught in userspace. Then the work loop accesses the actual thenable using
            // this function.
            if (suspendedThenable === null) {
                throw new Error('Expected a suspended thenable. This is a bug in React. Please file ' + 'an issue.');
            }
            var thenable = suspendedThenable;
            suspendedThenable = null;
            {
                needsToResetSuspendedThenableDEV = false;
            }
            return thenable;
        }
        function checkIfUseWrappedInTryCatch() {
            {
                // This was set right before SuspenseException was thrown, and it should
                // have been cleared when the exception was handled. If it wasn't,
                // it must have been caught by userspace.
                if (needsToResetSuspendedThenableDEV) {
                    needsToResetSuspendedThenableDEV = false;
                    return true;
                }
            }
            return false;
        }
        function checkIfUseWrappedInAsyncCatch(rejectedReason) {
            // This check runs in prod, too, because it prevents a more confusing
            // downstream error, where SuspenseException is caught by a promise and
            // thrown asynchronously.
            // TODO: Another way to prevent SuspenseException from leaking into an async
            // execution context is to check the dispatcher every time `use` is called,
            // or some equivalent. That might be preferable for other reasons, too, since
            // it matches how we prevent similar mistakes for other hooks.
            if (rejectedReason === SuspenseException) {
                throw new Error('Hooks are not supported inside an async component. This ' + "error is often caused by accidentally adding `'use client'` " + 'to a module that was originally written for the server.');
            }
        }
        var thenableState$1 = null;
        var thenableIndexCounter$1 = 0;
        function mergeDebugInfo(outer, inner) {
            if (inner == null) {
                return outer;
            } else if (outer === null) {
                return inner;
            } else {
                // If we have two debugInfo, we need to create a new one. This makes the array no longer
                // live so we'll miss any future updates if we received more so ideally we should always
                // do this after both have fully resolved/unsuspended.
                return outer.concat(inner);
            }
        }
        var didWarnAboutMaps;
        var didWarnAboutGenerators;
        var didWarnAboutStringRefs;
        var ownerHasKeyUseWarning;
        var ownerHasFunctionTypeWarning;
        var ownerHasSymbolTypeWarning;
        var warnForMissingKey = function(child, returnFiber) {};
        {
            didWarnAboutMaps = false;
            didWarnAboutGenerators = false;
            didWarnAboutStringRefs = {};
            /**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */ ownerHasKeyUseWarning = {};
            ownerHasFunctionTypeWarning = {};
            ownerHasSymbolTypeWarning = {};
            warnForMissingKey = function(child, returnFiber) {
                if (child === null || typeof child !== 'object') {
                    return;
                }
                if (!child._store || child._store.validated || child.key != null) {
                    return;
                }
                if (typeof child._store !== 'object') {
                    throw new Error('React Component in warnForMissingKey should have a _store. ' + 'This error is likely caused by a bug in React. Please file an issue.');
                } // $FlowFixMe[cannot-write] unable to narrow type from mixed to writable object
                child._store.validated = true;
                var componentName = getComponentNameFromFiber(returnFiber) || 'Component';
                if (ownerHasKeyUseWarning[componentName]) {
                    return;
                }
                ownerHasKeyUseWarning[componentName] = true;
                error('Each child in a list should have a unique ' + '"key" prop. See https://reactjs.org/link/warning-keys for ' + 'more information.');
            };
        }
        function isReactClass(type) {
            return type.prototype && type.prototype.isReactComponent;
        }
        function unwrapThenable(thenable) {
            var index = thenableIndexCounter$1;
            thenableIndexCounter$1 += 1;
            if (thenableState$1 === null) {
                thenableState$1 = createThenableState();
            }
            return trackUsedThenable(thenableState$1, thenable, index);
        }
        function convertStringRefToCallbackRef(returnFiber, current, element, mixedRef) {
            var owner = element._owner;
            if (!owner) {
                if (typeof mixedRef !== 'string') {
                    throw new Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');
                }
                throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of" + ' the following reasons:\n' + '1. You may be adding a ref to a function component\n' + "2. You may be adding a ref to a component that was not created inside a component's render method\n" + '3. You have multiple copies of React loaded\n' + 'See https://reactjs.org/link/refs-must-have-owner for more information.');
            }
            if (owner.tag !== ClassComponent) {
                throw new Error('Function components cannot have string refs. ' + 'We recommend using useRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref');
            } // At this point, we know the ref isn't an object or function but it could
            // be a number. Coerce it to a string.
            {
                checkPropStringCoercion(mixedRef, 'ref');
            }
            var stringRef = '' + mixedRef;
            {
                if (!(typeof element.type === 'function' && !isReactClass(element.type))) {
                    var componentName = getComponentNameFromFiber(returnFiber) || 'Component';
                    if (!didWarnAboutStringRefs[componentName]) {
                        error('Component "%s" contains the string ref "%s". Support for string refs ' + 'will be removed in a future major release. We recommend using ' + 'useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, stringRef);
                        didWarnAboutStringRefs[componentName] = true;
                    }
                }
            }
            var inst = owner.stateNode;
            if (!inst) {
                throw new Error("Missing owner for string ref " + stringRef + ". This error is likely caused by a " + 'bug in React. Please file an issue.');
            } // Check if previous string ref matches new string ref
            if (current !== null && current.ref !== null && typeof current.ref === 'function' && current.ref._stringRef === stringRef) {
                // Reuse the existing string ref
                var currentRef = current.ref;
                return currentRef;
            } // Create a new string ref
            var ref = function(value) {
                var refs = inst.refs;
                if (value === null) {
                    delete refs[stringRef];
                } else {
                    refs[stringRef] = value;
                }
            };
            ref._stringRef = stringRef;
            return ref;
        }
        function coerceRef(returnFiber, current, workInProgress, element) {
            var mixedRef;
            {
                // Old behavior.
                mixedRef = element.ref;
            }
            var coercedRef;
            if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {
                // Assume this is a string ref. If it's not, then this will throw an error
                // to the user.
                coercedRef = convertStringRefToCallbackRef(returnFiber, current, element, mixedRef);
            } else {
                coercedRef = mixedRef;
            } // TODO: If enableRefAsProp is on, we shouldn't use the `ref` field. We
            // should always read the ref from the prop.
            workInProgress.ref = coercedRef;
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
            // $FlowFixMe[method-unbinding]
            var childString = Object.prototype.toString.call(newChild);
            throw new Error("Objects are not valid as a React child (found: " + (childString === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : childString) + "). " + 'If you meant to render a collection of children, use an array ' + 'instead.');
        }
        function warnOnFunctionType(returnFiber, invalidChild) {
            {
                var parentName = getComponentNameFromFiber(returnFiber) || 'Component';
                if (ownerHasFunctionTypeWarning[parentName]) {
                    return;
                }
                ownerHasFunctionTypeWarning[parentName] = true;
                var name = invalidChild.displayName || invalidChild.name || 'Component';
                if (returnFiber.tag === HostRoot) {
                    error('Functions are not valid as a React child. This may happen if ' + 'you return %s instead of <%s /> from render. ' + 'Or maybe you meant to call this function rather than return it.\n' + '  root.render(%s)', name, name, name);
                } else {
                    error('Functions are not valid as a React child. This may happen if ' + 'you return %s instead of <%s /> from render. ' + 'Or maybe you meant to call this function rather than return it.\n' + '  <%s>{%s}</%s>', name, name, parentName, name, parentName);
                }
            }
        }
        function warnOnSymbolType(returnFiber, invalidChild) {
            {
                var parentName = getComponentNameFromFiber(returnFiber) || 'Component';
                if (ownerHasSymbolTypeWarning[parentName]) {
                    return;
                }
                ownerHasSymbolTypeWarning[parentName] = true; // eslint-disable-next-line react-internal/safe-string-coercion
                var name = String(invalidChild);
                if (returnFiber.tag === HostRoot) {
                    error('Symbols are not valid as a React child.\n' + '  root.render(%s)', name);
                } else {
                    error('Symbols are not valid as a React child.\n' + '  <%s>%s</%s>', parentName, name, parentName);
                }
            }
        }
        function resolveLazy(lazyType) {
            var payload = lazyType._payload;
            var init = lazyType._init;
            return init(payload);
        } // This wrapper function exists because I expect to clone the code in each path
        // to be able to optimize each path individually by branching early. This needs
        // a compiler or we can do it manually. Helpers that don't need this branching
        // live outside of this function.
        function createChildReconciler(shouldTrackSideEffects) {
            function deleteChild(returnFiber, childToDelete) {
                if (!shouldTrackSideEffects) {
                    // Noop.
                    return;
                }
                var deletions = returnFiber.deletions;
                if (deletions === null) {
                    returnFiber.deletions = [
                        childToDelete
                    ];
                    returnFiber.flags |= ChildDeletion;
                } else {
                    deletions.push(childToDelete);
                }
            }
            function deleteRemainingChildren(returnFiber, currentFirstChild) {
                if (!shouldTrackSideEffects) {
                    // Noop.
                    return null;
                } // TODO: For the shouldClone case, this could be micro-optimized a bit by
                // assuming that after the first child we've already added everything.
                var childToDelete = currentFirstChild;
                while(childToDelete !== null){
                    deleteChild(returnFiber, childToDelete);
                    childToDelete = childToDelete.sibling;
                }
                return null;
            }
            function mapRemainingChildren(returnFiber, currentFirstChild) {
                // Add the remaining children to a temporary map so that we can find them by
                // keys quickly. Implicit (null) keys get added to this set with their index
                // instead.
                var existingChildren = new Map();
                var existingChild = currentFirstChild;
                while(existingChild !== null){
                    if (existingChild.key !== null) {
                        existingChildren.set(existingChild.key, existingChild);
                    } else {
                        existingChildren.set(existingChild.index, existingChild);
                    }
                    existingChild = existingChild.sibling;
                }
                return existingChildren;
            }
            function useFiber(fiber, pendingProps) {
                // We currently set sibling to null and index to 0 here because it is easy
                // to forget to do before returning it. E.g. for the single child case.
                var clone = createWorkInProgress(fiber, pendingProps);
                clone.index = 0;
                clone.sibling = null;
                return clone;
            }
            function placeChild(newFiber, lastPlacedIndex, newIndex) {
                newFiber.index = newIndex;
                if (!shouldTrackSideEffects) {
                    // During hydration, the useId algorithm needs to know which fibers are
                    // part of a list of children (arrays, iterators).
                    newFiber.flags |= Forked;
                    return lastPlacedIndex;
                }
                var current = newFiber.alternate;
                if (current !== null) {
                    var oldIndex = current.index;
                    if (oldIndex < lastPlacedIndex) {
                        // This is a move.
                        newFiber.flags |= Placement | PlacementDEV;
                        return lastPlacedIndex;
                    } else {
                        // This item can stay in place.
                        return oldIndex;
                    }
                } else {
                    // This is an insertion.
                    newFiber.flags |= Placement | PlacementDEV;
                    return lastPlacedIndex;
                }
            }
            function placeSingleChild(newFiber) {
                // This is simpler for the single child case. We only need to do a
                // placement for inserting new children.
                if (shouldTrackSideEffects && newFiber.alternate === null) {
                    newFiber.flags |= Placement | PlacementDEV;
                }
                return newFiber;
            }
            function updateTextNode(returnFiber, current, textContent, lanes, debugInfo) {
                if (current === null || current.tag !== HostText) {
                    // Insert
                    var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                    created.return = returnFiber;
                    {
                        created._debugInfo = debugInfo;
                    }
                    return created;
                } else {
                    // Update
                    var existing = useFiber(current, textContent);
                    existing.return = returnFiber;
                    {
                        existing._debugInfo = debugInfo;
                    }
                    return existing;
                }
            }
            function updateElement(returnFiber, current, element, lanes, debugInfo) {
                var elementType = element.type;
                if (elementType === REACT_FRAGMENT_TYPE) {
                    return updateFragment(returnFiber, current, element.props.children, lanes, element.key, debugInfo);
                }
                if (current !== null) {
                    if (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || // Lazy types should reconcile their resolved type.
                    // We need to do this after the Hot Reloading check above,
                    // because hot reloading has different semantics than prod because
                    // it doesn't resuspend. So we can't let the call below suspend.
                    typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type) {
                        // Move based on index
                        var existing = useFiber(current, element.props);
                        coerceRef(returnFiber, current, existing, element);
                        existing.return = returnFiber;
                        {
                            existing._debugOwner = element._owner;
                            existing._debugInfo = debugInfo;
                        }
                        return existing;
                    }
                } // Insert
                var created = createFiberFromElement(element, returnFiber.mode, lanes);
                coerceRef(returnFiber, current, created, element);
                created.return = returnFiber;
                {
                    created._debugInfo = debugInfo;
                }
                return created;
            }
            function updatePortal(returnFiber, current, portal, lanes, debugInfo) {
                if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
                    // Insert
                    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                    created.return = returnFiber;
                    {
                        created._debugInfo = debugInfo;
                    }
                    return created;
                } else {
                    // Update
                    var existing = useFiber(current, portal.children || []);
                    existing.return = returnFiber;
                    {
                        existing._debugInfo = debugInfo;
                    }
                    return existing;
                }
            }
            function updateFragment(returnFiber, current, fragment, lanes, key, debugInfo) {
                if (current === null || current.tag !== Fragment) {
                    // Insert
                    var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
                    created.return = returnFiber;
                    {
                        created._debugInfo = debugInfo;
                    }
                    return created;
                } else {
                    // Update
                    var existing = useFiber(current, fragment);
                    existing.return = returnFiber;
                    {
                        existing._debugInfo = debugInfo;
                    }
                    return existing;
                }
            }
            function createChild(returnFiber, newChild, lanes, debugInfo) {
                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {
                    // Text nodes don't have keys. If the previous node is implicitly keyed
                    // we can continue to replace it without aborting even if it is not a text
                    // node.
                    var created = createFiberFromText('' + newChild, returnFiber.mode, lanes);
                    created.return = returnFiber;
                    {
                        created._debugInfo = debugInfo;
                    }
                    return created;
                }
                if (typeof newChild === 'object' && newChild !== null) {
                    switch(newChild.$$typeof){
                        case REACT_ELEMENT_TYPE:
                            {
                                var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                                coerceRef(returnFiber, null, _created, newChild);
                                _created.return = returnFiber;
                                {
                                    _created._debugInfo = mergeDebugInfo(debugInfo, newChild._debugInfo);
                                }
                                return _created;
                            }
                        case REACT_PORTAL_TYPE:
                            {
                                var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                                _created2.return = returnFiber;
                                {
                                    _created2._debugInfo = debugInfo;
                                }
                                return _created2;
                            }
                        case REACT_LAZY_TYPE:
                            {
                                var payload = newChild._payload;
                                var init = newChild._init;
                                return createChild(returnFiber, init(payload), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo) // call merge after init
                                );
                            }
                    }
                    if (isArray(newChild) || getIteratorFn(newChild)) {
                        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                        _created3.return = returnFiber;
                        {
                            _created3._debugInfo = mergeDebugInfo(debugInfo, newChild._debugInfo);
                        }
                        return _created3;
                    } // Usable node types
                    //
                    // Unwrap the inner value and recursively call this function again.
                    if (typeof newChild.then === 'function') {
                        var thenable = newChild;
                        return createChild(returnFiber, unwrapThenable(thenable), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));
                    }
                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {
                        var context = newChild;
                        return createChild(returnFiber, readContextDuringReconcilation(returnFiber, context, lanes), lanes, debugInfo);
                    }
                    throwOnInvalidObjectType(returnFiber, newChild);
                }
                {
                    if (typeof newChild === 'function') {
                        warnOnFunctionType(returnFiber, newChild);
                    }
                    if (typeof newChild === 'symbol') {
                        warnOnSymbolType(returnFiber, newChild);
                    }
                }
                return null;
            }
            function updateSlot(returnFiber, oldFiber, newChild, lanes, debugInfo) {
                // Update the fiber if the keys match, otherwise return null.
                var key = oldFiber !== null ? oldFiber.key : null;
                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {
                    // Text nodes don't have keys. If the previous node is implicitly keyed
                    // we can continue to replace it without aborting even if it is not a text
                    // node.
                    if (key !== null) {
                        return null;
                    }
                    return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes, debugInfo);
                }
                if (typeof newChild === 'object' && newChild !== null) {
                    switch(newChild.$$typeof){
                        case REACT_ELEMENT_TYPE:
                            {
                                if (newChild.key === key) {
                                    return updateElement(returnFiber, oldFiber, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));
                                } else {
                                    return null;
                                }
                            }
                        case REACT_PORTAL_TYPE:
                            {
                                if (newChild.key === key) {
                                    return updatePortal(returnFiber, oldFiber, newChild, lanes, debugInfo);
                                } else {
                                    return null;
                                }
                            }
                        case REACT_LAZY_TYPE:
                            {
                                var payload = newChild._payload;
                                var init = newChild._init;
                                return updateSlot(returnFiber, oldFiber, init(payload), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));
                            }
                    }
                    if (isArray(newChild) || getIteratorFn(newChild)) {
                        if (key !== null) {
                            return null;
                        }
                        return updateFragment(returnFiber, oldFiber, newChild, lanes, null, mergeDebugInfo(debugInfo, newChild._debugInfo));
                    } // Usable node types
                    //
                    // Unwrap the inner value and recursively call this function again.
                    if (typeof newChild.then === 'function') {
                        var thenable = newChild;
                        return updateSlot(returnFiber, oldFiber, unwrapThenable(thenable), lanes, debugInfo);
                    }
                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {
                        var context = newChild;
                        return updateSlot(returnFiber, oldFiber, readContextDuringReconcilation(returnFiber, context, lanes), lanes, debugInfo);
                    }
                    throwOnInvalidObjectType(returnFiber, newChild);
                }
                {
                    if (typeof newChild === 'function') {
                        warnOnFunctionType(returnFiber, newChild);
                    }
                    if (typeof newChild === 'symbol') {
                        warnOnSymbolType(returnFiber, newChild);
                    }
                }
                return null;
            }
            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes, debugInfo) {
                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {
                    // Text nodes don't have keys, so we neither have to check the old nor
                    // new node for the key. If both are text nodes, they match.
                    var matchedFiber = existingChildren.get(newIdx) || null;
                    return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes, debugInfo);
                }
                if (typeof newChild === 'object' && newChild !== null) {
                    switch(newChild.$$typeof){
                        case REACT_ELEMENT_TYPE:
                            {
                                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                                return updateElement(returnFiber, _matchedFiber, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));
                            }
                        case REACT_PORTAL_TYPE:
                            {
                                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                                return updatePortal(returnFiber, _matchedFiber2, newChild, lanes, debugInfo);
                            }
                        case REACT_LAZY_TYPE:
                            var payload = newChild._payload;
                            var init = newChild._init;
                            return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));
                    }
                    if (isArray(newChild) || getIteratorFn(newChild)) {
                        var _matchedFiber3 = existingChildren.get(newIdx) || null;
                        return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null, mergeDebugInfo(debugInfo, newChild._debugInfo));
                    } // Usable node types
                    //
                    // Unwrap the inner value and recursively call this function again.
                    if (typeof newChild.then === 'function') {
                        var thenable = newChild;
                        return updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(thenable), lanes, debugInfo);
                    }
                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {
                        var context = newChild;
                        return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconcilation(returnFiber, context, lanes), lanes, debugInfo);
                    }
                    throwOnInvalidObjectType(returnFiber, newChild);
                }
                {
                    if (typeof newChild === 'function') {
                        warnOnFunctionType(returnFiber, newChild);
                    }
                    if (typeof newChild === 'symbol') {
                        warnOnSymbolType(returnFiber, newChild);
                    }
                }
                return null;
            }
            /**
   * Warns if there is a duplicate or missing key
   */ function warnOnInvalidKey(child, knownKeys, returnFiber) {
                {
                    if (typeof child !== 'object' || child === null) {
                        return knownKeys;
                    }
                    switch(child.$$typeof){
                        case REACT_ELEMENT_TYPE:
                        case REACT_PORTAL_TYPE:
                            warnForMissingKey(child, returnFiber);
                            var key = child.key;
                            if (typeof key !== 'string') {
                                break;
                            }
                            if (knownKeys === null) {
                                knownKeys = new Set();
                                knownKeys.add(key);
                                break;
                            }
                            if (!knownKeys.has(key)) {
                                knownKeys.add(key);
                                break;
                            }
                            error('Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.', key);
                            break;
                        case REACT_LAZY_TYPE:
                            var payload = child._payload;
                            var init = child._init;
                            warnOnInvalidKey(init(payload), knownKeys, returnFiber);
                            break;
                    }
                }
                return knownKeys;
            }
            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes, debugInfo) {
                // This algorithm can't optimize by searching from both ends since we
                // don't have backpointers on fibers. I'm trying to see how far we can get
                // with that model. If it ends up not being worth the tradeoffs, we can
                // add it later.
                // Even with a two ended optimization, we'd want to optimize for the case
                // where there are few changes and brute force the comparison instead of
                // going for the Map. It'd like to explore hitting that path first in
                // forward-only mode and only go for the Map once we notice that we need
                // lots of look ahead. This doesn't handle reversal as well as two ended
                // search but that's unusual. Besides, for the two ended optimization to
                // work on Iterables, we'd need to copy the whole set.
                // In this first iteration, we'll just live with hitting the bad case
                // (adding everything to a Map) in for every insert/move.
                // If you change this code, also update reconcileChildrenIterator() which
                // uses the same algorithm.
                {
                    // First, validate keys.
                    var knownKeys = null;
                    for(var i = 0; i < newChildren.length; i++){
                        var child = newChildren[i];
                        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                    }
                }
                var resultingFirstChild = null;
                var previousNewFiber = null;
                var oldFiber = currentFirstChild;
                var lastPlacedIndex = 0;
                var newIdx = 0;
                var nextOldFiber = null;
                for(; oldFiber !== null && newIdx < newChildren.length; newIdx++){
                    if (oldFiber.index > newIdx) {
                        nextOldFiber = oldFiber;
                        oldFiber = null;
                    } else {
                        nextOldFiber = oldFiber.sibling;
                    }
                    var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes, debugInfo);
                    if (newFiber === null) {
                        // TODO: This breaks on empty slots like null children. That's
                        // unfortunate because it triggers the slow path all the time. We need
                        // a better way to communicate whether this was a miss or null,
                        // boolean, undefined, etc.
                        if (oldFiber === null) {
                            oldFiber = nextOldFiber;
                        }
                        break;
                    }
                    if (shouldTrackSideEffects) {
                        if (oldFiber && newFiber.alternate === null) {
                            // We matched the slot, but we didn't reuse the existing fiber, so we
                            // need to delete the existing child.
                            deleteChild(returnFiber, oldFiber);
                        }
                    }
                    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                    if (previousNewFiber === null) {
                        // TODO: Move out of the loop. This only happens for the first run.
                        resultingFirstChild = newFiber;
                    } else {
                        // TODO: Defer siblings if we're not at the right index for this slot.
                        // I.e. if we had null values before, then we want to defer this
                        // for each null value. However, we also don't want to call updateSlot
                        // with the previous one.
                        previousNewFiber.sibling = newFiber;
                    }
                    previousNewFiber = newFiber;
                    oldFiber = nextOldFiber;
                }
                if (newIdx === newChildren.length) {
                    // We've reached the end of the new children. We can delete the rest.
                    deleteRemainingChildren(returnFiber, oldFiber);
                    if (getIsHydrating()) {
                        var numberOfForks = newIdx;
                        pushTreeFork(returnFiber, numberOfForks);
                    }
                    return resultingFirstChild;
                }
                if (oldFiber === null) {
                    // If we don't have any more existing children we can choose a fast path
                    // since the rest will all be insertions.
                    for(; newIdx < newChildren.length; newIdx++){
                        var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes, debugInfo);
                        if (_newFiber === null) {
                            continue;
                        }
                        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                        if (previousNewFiber === null) {
                            // TODO: Move out of the loop. This only happens for the first run.
                            resultingFirstChild = _newFiber;
                        } else {
                            previousNewFiber.sibling = _newFiber;
                        }
                        previousNewFiber = _newFiber;
                    }
                    if (getIsHydrating()) {
                        var _numberOfForks = newIdx;
                        pushTreeFork(returnFiber, _numberOfForks);
                    }
                    return resultingFirstChild;
                } // Add all children to a key map for quick lookups.
                var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.
                for(; newIdx < newChildren.length; newIdx++){
                    var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes, debugInfo);
                    if (_newFiber2 !== null) {
                        if (shouldTrackSideEffects) {
                            if (_newFiber2.alternate !== null) {
                                // The new fiber is a work in progress, but if there exists a
                                // current, that means that we reused the fiber. We need to delete
                                // it from the child list so that we don't add it to the deletion
                                // list.
                                existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                            }
                        }
                        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                        if (previousNewFiber === null) {
                            resultingFirstChild = _newFiber2;
                        } else {
                            previousNewFiber.sibling = _newFiber2;
                        }
                        previousNewFiber = _newFiber2;
                    }
                }
                if (shouldTrackSideEffects) {
                    // Any existing children that weren't consumed above were deleted. We need
                    // to add them to the deletion list.
                    existingChildren.forEach(function(child) {
                        return deleteChild(returnFiber, child);
                    });
                }
                if (getIsHydrating()) {
                    var _numberOfForks2 = newIdx;
                    pushTreeFork(returnFiber, _numberOfForks2);
                }
                return resultingFirstChild;
            }
            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes, debugInfo) {
                // This is the same implementation as reconcileChildrenArray(),
                // but using the iterator instead.
                var iteratorFn = getIteratorFn(newChildrenIterable);
                if (typeof iteratorFn !== 'function') {
                    throw new Error('An object is not an iterable. This error is likely caused by a bug in ' + 'React. Please file an issue.');
                }
                {
                    // We don't support rendering Generators because it's a mutation.
                    // See https://github.com/facebook/react/issues/12995
                    if (typeof Symbol === 'function' && // $FlowFixMe[prop-missing] Flow doesn't know about toStringTag
                    newChildrenIterable[Symbol.toStringTag] === 'Generator') {
                        if (!didWarnAboutGenerators) {
                            error('Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.');
                        }
                        didWarnAboutGenerators = true;
                    } // Warn about using Maps as children
                    if (newChildrenIterable.entries === iteratorFn) {
                        if (!didWarnAboutMaps) {
                            error('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
                        }
                        didWarnAboutMaps = true;
                    } // First, validate keys.
                    // We'll get a different iterator later for the main pass.
                    var _newChildren = iteratorFn.call(newChildrenIterable);
                    if (_newChildren) {
                        var knownKeys = null;
                        var _step = _newChildren.next();
                        for(; !_step.done; _step = _newChildren.next()){
                            var child = _step.value;
                            knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                        }
                    }
                }
                var newChildren = iteratorFn.call(newChildrenIterable);
                if (newChildren == null) {
                    throw new Error('An iterable object provided no iterator.');
                }
                var resultingFirstChild = null;
                var previousNewFiber = null;
                var oldFiber = currentFirstChild;
                var lastPlacedIndex = 0;
                var newIdx = 0;
                var nextOldFiber = null;
                var step = newChildren.next();
                for(; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()){
                    if (oldFiber.index > newIdx) {
                        nextOldFiber = oldFiber;
                        oldFiber = null;
                    } else {
                        nextOldFiber = oldFiber.sibling;
                    }
                    var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes, debugInfo);
                    if (newFiber === null) {
                        // TODO: This breaks on empty slots like null children. That's
                        // unfortunate because it triggers the slow path all the time. We need
                        // a better way to communicate whether this was a miss or null,
                        // boolean, undefined, etc.
                        if (oldFiber === null) {
                            oldFiber = nextOldFiber;
                        }
                        break;
                    }
                    if (shouldTrackSideEffects) {
                        if (oldFiber && newFiber.alternate === null) {
                            // We matched the slot, but we didn't reuse the existing fiber, so we
                            // need to delete the existing child.
                            deleteChild(returnFiber, oldFiber);
                        }
                    }
                    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                    if (previousNewFiber === null) {
                        // TODO: Move out of the loop. This only happens for the first run.
                        resultingFirstChild = newFiber;
                    } else {
                        // TODO: Defer siblings if we're not at the right index for this slot.
                        // I.e. if we had null values before, then we want to defer this
                        // for each null value. However, we also don't want to call updateSlot
                        // with the previous one.
                        previousNewFiber.sibling = newFiber;
                    }
                    previousNewFiber = newFiber;
                    oldFiber = nextOldFiber;
                }
                if (step.done) {
                    // We've reached the end of the new children. We can delete the rest.
                    deleteRemainingChildren(returnFiber, oldFiber);
                    if (getIsHydrating()) {
                        var numberOfForks = newIdx;
                        pushTreeFork(returnFiber, numberOfForks);
                    }
                    return resultingFirstChild;
                }
                if (oldFiber === null) {
                    // If we don't have any more existing children we can choose a fast path
                    // since the rest will all be insertions.
                    for(; !step.done; newIdx++, step = newChildren.next()){
                        var _newFiber3 = createChild(returnFiber, step.value, lanes, debugInfo);
                        if (_newFiber3 === null) {
                            continue;
                        }
                        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                        if (previousNewFiber === null) {
                            // TODO: Move out of the loop. This only happens for the first run.
                            resultingFirstChild = _newFiber3;
                        } else {
                            previousNewFiber.sibling = _newFiber3;
                        }
                        previousNewFiber = _newFiber3;
                    }
                    if (getIsHydrating()) {
                        var _numberOfForks3 = newIdx;
                        pushTreeFork(returnFiber, _numberOfForks3);
                    }
                    return resultingFirstChild;
                } // Add all children to a key map for quick lookups.
                var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.
                for(; !step.done; newIdx++, step = newChildren.next()){
                    var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes, debugInfo);
                    if (_newFiber4 !== null) {
                        if (shouldTrackSideEffects) {
                            if (_newFiber4.alternate !== null) {
                                // The new fiber is a work in progress, but if there exists a
                                // current, that means that we reused the fiber. We need to delete
                                // it from the child list so that we don't add it to the deletion
                                // list.
                                existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                            }
                        }
                        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                        if (previousNewFiber === null) {
                            resultingFirstChild = _newFiber4;
                        } else {
                            previousNewFiber.sibling = _newFiber4;
                        }
                        previousNewFiber = _newFiber4;
                    }
                }
                if (shouldTrackSideEffects) {
                    // Any existing children that weren't consumed above were deleted. We need
                    // to add them to the deletion list.
                    existingChildren.forEach(function(child) {
                        return deleteChild(returnFiber, child);
                    });
                }
                if (getIsHydrating()) {
                    var _numberOfForks4 = newIdx;
                    pushTreeFork(returnFiber, _numberOfForks4);
                }
                return resultingFirstChild;
            }
            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
                // There's no need to check for keys on text nodes since we don't have a
                // way to define them.
                if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
                    // We already have an existing node so let's just update it and delete
                    // the rest.
                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                    var existing = useFiber(currentFirstChild, textContent);
                    existing.return = returnFiber;
                    return existing;
                } // The existing first child is not a text node so we need to create one
                // and delete the existing ones.
                deleteRemainingChildren(returnFiber, currentFirstChild);
                var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
            }
            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes, debugInfo) {
                var key = element.key;
                var child = currentFirstChild;
                while(child !== null){
                    // TODO: If key === null and child.key === null, then this only applies to
                    // the first item in the list.
                    if (child.key === key) {
                        var elementType = element.type;
                        if (elementType === REACT_FRAGMENT_TYPE) {
                            if (child.tag === Fragment) {
                                deleteRemainingChildren(returnFiber, child.sibling);
                                var existing = useFiber(child, element.props.children);
                                existing.return = returnFiber;
                                {
                                    existing._debugOwner = element._owner;
                                    existing._debugInfo = debugInfo;
                                }
                                return existing;
                            }
                        } else {
                            if (child.elementType === elementType || isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.
                            // We need to do this after the Hot Reloading check above,
                            // because hot reloading has different semantics than prod because
                            // it doesn't resuspend. So we can't let the call below suspend.
                            typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                                deleteRemainingChildren(returnFiber, child.sibling);
                                var _existing = useFiber(child, element.props);
                                coerceRef(returnFiber, child, _existing, element);
                                _existing.return = returnFiber;
                                {
                                    _existing._debugOwner = element._owner;
                                    _existing._debugInfo = debugInfo;
                                }
                                return _existing;
                            }
                        } // Didn't match.
                        deleteRemainingChildren(returnFiber, child);
                        break;
                    } else {
                        deleteChild(returnFiber, child);
                    }
                    child = child.sibling;
                }
                if (element.type === REACT_FRAGMENT_TYPE) {
                    var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
                    created.return = returnFiber;
                    {
                        created._debugInfo = debugInfo;
                    }
                    return created;
                } else {
                    var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
                    coerceRef(returnFiber, currentFirstChild, _created4, element);
                    _created4.return = returnFiber;
                    {
                        _created4._debugInfo = debugInfo;
                    }
                    return _created4;
                }
            }
            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes, debugInfo) {
                var key = portal.key;
                var child = currentFirstChild;
                while(child !== null){
                    // TODO: If key === null and child.key === null, then this only applies to
                    // the first item in the list.
                    if (child.key === key) {
                        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                            deleteRemainingChildren(returnFiber, child.sibling);
                            var existing = useFiber(child, portal.children || []);
                            existing.return = returnFiber;
                            return existing;
                        } else {
                            deleteRemainingChildren(returnFiber, child);
                            break;
                        }
                    } else {
                        deleteChild(returnFiber, child);
                    }
                    child = child.sibling;
                }
                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
            } // This API will tag the children with the side-effect of the reconciliation
            // itself. They will be added to the side-effect list as we pass through the
            // children and the parent.
            function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes, debugInfo) {
                // This function is not recursive.
                // If the top level item is an array, we treat it as a set of children,
                // not as a fragment. Nested arrays on the other hand will be treated as
                // fragment nodes. Recursion happens at the normal flow.
                // Handle top level unkeyed fragments as if they were arrays.
                // This leads to an ambiguity between <>{[...]}</> and <>...</>.
                // We treat the ambiguous cases above the same.
                // TODO: Let's use recursion like we do for Usable nodes?
                var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
                if (isUnkeyedTopLevelFragment) {
                    newChild = newChild.props.children;
                } // Handle object types
                if (typeof newChild === 'object' && newChild !== null) {
                    switch(newChild.$$typeof){
                        case REACT_ELEMENT_TYPE:
                            return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo)));
                        case REACT_PORTAL_TYPE:
                            return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                        case REACT_LAZY_TYPE:
                            var payload = newChild._payload;
                            var init = newChild._init;
                            return reconcileChildFibersImpl(returnFiber, currentFirstChild, init(payload), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));
                    }
                    if (isArray(newChild)) {
                        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));
                    }
                    if (getIteratorFn(newChild)) {
                        return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));
                    } // Usables are a valid React node type. When React encounters a Usable in
                    // a child position, it unwraps it using the same algorithm as `use`. For
                    // example, for promises, React will throw an exception to unwind the
                    // stack, then replay the component once the promise resolves.
                    //
                    // A difference from `use` is that React will keep unwrapping the value
                    // until it reaches a non-Usable type.
                    //
                    // e.g. Usable<Usable<Usable<T>>> should resolve to T
                    //
                    // The structure is a bit unfortunate. Ideally, we shouldn't need to
                    // replay the entire begin phase of the parent fiber in order to reconcile
                    // the children again. This would require a somewhat significant refactor,
                    // because reconcilation happens deep within the begin phase, and
                    // depending on the type of work, not always at the end. We should
                    // consider as an future improvement.
                    if (typeof newChild.then === 'function') {
                        var thenable = newChild;
                        return reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(thenable), lanes, mergeDebugInfo(debugInfo, thenable._debugInfo));
                    }
                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {
                        var context = newChild;
                        return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconcilation(returnFiber, context, lanes), lanes, debugInfo);
                    }
                    throwOnInvalidObjectType(returnFiber, newChild);
                }
                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {
                    return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));
                }
                {
                    if (typeof newChild === 'function') {
                        warnOnFunctionType(returnFiber, newChild);
                    }
                    if (typeof newChild === 'symbol') {
                        warnOnSymbolType(returnFiber, newChild);
                    }
                }
                return deleteRemainingChildren(returnFiber, currentFirstChild);
            }
            function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {
                // This indirection only exists so we can reset `thenableState` at the end.
                // It should get inlined by Closure.
                thenableIndexCounter$1 = 0;
                var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes, null // debugInfo
                );
                thenableState$1 = null; // Don't bother to reset `thenableIndexCounter` to 0 because it always gets
                // set at the beginning.
                return firstChildFiber;
            }
            return reconcileChildFibers;
        }
        var reconcileChildFibers = createChildReconciler(true);
        var mountChildFibers = createChildReconciler(false);
        function resetChildReconcilerOnUnwind() {
            // On unwind, clear any pending thenables that were used.
            thenableState$1 = null;
            thenableIndexCounter$1 = 0;
        }
        function cloneChildFibers(current, workInProgress) {
            if (current !== null && workInProgress.child !== current.child) {
                throw new Error('Resuming work not yet implemented.');
            }
            if (workInProgress.child === null) {
                return;
            }
            var currentChild = workInProgress.child;
            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
            workInProgress.child = newChild;
            newChild.return = workInProgress;
            while(currentChild.sibling !== null){
                currentChild = currentChild.sibling;
                newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
                newChild.return = workInProgress;
            }
            newChild.sibling = null;
        } // Reset a workInProgress child set to prepare it for a second pass.
        function resetChildFibers(workInProgress, lanes) {
            var child = workInProgress.child;
            while(child !== null){
                resetWorkInProgress(child, lanes);
                child = child.sibling;
            }
        }
        // TODO: This isn't being used yet, but it's intended to replace the
        // InvisibleParentContext that is currently managed by SuspenseContext.
        var currentTreeHiddenStackCursor = createCursor(null);
        var prevEntangledRenderLanesCursor = createCursor(NoLanes);
        function pushHiddenContext(fiber, context) {
            var prevEntangledRenderLanes = getEntangledRenderLanes();
            push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
            push(currentTreeHiddenStackCursor, context, fiber); // When rendering a subtree that's currently hidden, we must include all
            // lanes that would have rendered if the hidden subtree hadn't been deferred.
            // That is, in order to reveal content from hidden -> visible, we must commit
            // all the updates that we skipped when we originally hid the tree.
            setEntangledRenderLanes(mergeLanes(prevEntangledRenderLanes, context.baseLanes));
        }
        function reuseHiddenContextOnStack(fiber) {
            // This subtree is not currently hidden, so we don't need to add any lanes
            // to the render lanes. But we still need to push something to avoid a
            // context mismatch. Reuse the existing context on the stack.
            push(prevEntangledRenderLanesCursor, getEntangledRenderLanes(), fiber);
            push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);
        }
        function popHiddenContext(fiber) {
            // Restore the previous render lanes from the stack
            setEntangledRenderLanes(prevEntangledRenderLanesCursor.current);
            pop(currentTreeHiddenStackCursor, fiber);
            pop(prevEntangledRenderLanesCursor, fiber);
        }
        function isCurrentTreeHidden() {
            return currentTreeHiddenStackCursor.current !== null;
        }
        // suspends, i.e. it's the nearest `catch` block on the stack.
        var suspenseHandlerStackCursor = createCursor(null); // Represents the outermost boundary that is not visible in the current tree.
        // Everything above this is the "shell". When this is null, it means we're
        // rendering in the shell of the app. If it's non-null, it means we're rendering
        // deeper than the shell, inside a new tree that wasn't already visible.
        //
        // The main way we use this concept is to determine whether showing a fallback
        // would result in a desirable or undesirable loading state. Activing a fallback
        // in the shell is considered an undersirable loading state, because it would
        // mean hiding visible (albeit stale) content in the current tree — we prefer to
        // show the stale content, rather than switch to a fallback. But showing a
        // fallback in a new tree is fine, because there's no stale content to
        // prefer instead.
        var shellBoundary = null;
        function getShellBoundary() {
            return shellBoundary;
        }
        function pushPrimaryTreeSuspenseHandler(handler) {
            // TODO: Pass as argument
            var current = handler.alternate;
            // propagated a single level. For example, when ForceSuspenseFallback is set,
            // it should only force the nearest Suspense boundary into fallback mode.
            pushSuspenseListContext(handler, setDefaultShallowSuspenseListContext(suspenseStackCursor.current)); // Experimental feature: Some Suspense boundaries are marked as having an
            // to push a nested Suspense handler, because it will get replaced by the
            // outer fallback, anyway. Consider this as a future optimization.
            push(suspenseHandlerStackCursor, handler, handler);
            if (shellBoundary === null) {
                if (current === null || isCurrentTreeHidden()) {
                    // This boundary is not visible in the current UI.
                    shellBoundary = handler;
                } else {
                    var prevState = current.memoizedState;
                    if (prevState !== null) {
                        // This boundary is showing a fallback in the current UI.
                        shellBoundary = handler;
                    }
                }
            }
        }
        function pushFallbackTreeSuspenseHandler(fiber) {
            // We're about to render the fallback. If something in the fallback suspends,
            // it's akin to throwing inside of a `catch` block. This boundary should not
            // capture. Reuse the existing handler on the stack.
            reuseSuspenseHandlerOnStack(fiber);
        }
        function pushOffscreenSuspenseHandler(fiber) {
            if (fiber.tag === OffscreenComponent) {
                // A SuspenseList context is only pushed here to avoid a push/pop mismatch.
                // Reuse the current value on the stack.
                // TODO: We can avoid needing to push here by by forking popSuspenseHandler
                // into separate functions for Suspense and Offscreen.
                pushSuspenseListContext(fiber, suspenseStackCursor.current);
                push(suspenseHandlerStackCursor, fiber, fiber);
                if (shellBoundary !== null) ;
                else {
                    var current = fiber.alternate;
                    if (current !== null) {
                        var prevState = current.memoizedState;
                        if (prevState !== null) {
                            // This is the first boundary in the stack that's already showing
                            // a fallback. So everything outside is considered the shell.
                            shellBoundary = fiber;
                        }
                    }
                }
            } else {
                // This is a LegacyHidden component.
                reuseSuspenseHandlerOnStack(fiber);
            }
        }
        function reuseSuspenseHandlerOnStack(fiber) {
            pushSuspenseListContext(fiber, suspenseStackCursor.current);
            push(suspenseHandlerStackCursor, getSuspenseHandler(), fiber);
        }
        function getSuspenseHandler() {
            return suspenseHandlerStackCursor.current;
        }
        function popSuspenseHandler(fiber) {
            pop(suspenseHandlerStackCursor, fiber);
            if (shellBoundary === fiber) {
                // Popping back into the shell.
                shellBoundary = null;
            }
            popSuspenseListContext(fiber);
        } // SuspenseList context
        // TODO: Move to a separate module? We may change the SuspenseList
        // implementation to hide/show in the commit phase, anyway.
        var DefaultSuspenseContext = 0;
        var SubtreeSuspenseContextMask = 1; // ForceSuspenseFallback can be used by SuspenseList to force newly added
        // items into their fallback state during one of the render passes.
        var ForceSuspenseFallback = 2;
        var suspenseStackCursor = createCursor(DefaultSuspenseContext);
        function hasSuspenseListContext(parentContext, flag) {
            return (parentContext & flag) !== 0;
        }
        function setDefaultShallowSuspenseListContext(parentContext) {
            return parentContext & SubtreeSuspenseContextMask;
        }
        function setShallowSuspenseListContext(parentContext, shallowContext) {
            return parentContext & SubtreeSuspenseContextMask | shallowContext;
        }
        function pushSuspenseListContext(fiber, newContext) {
            push(suspenseStackCursor, newContext, fiber);
        }
        function popSuspenseListContext(fiber) {
            pop(suspenseStackCursor, fiber);
        }
        // A non-null SuspenseState means that it is blocked for one reason or another.
        // - A non-null dehydrated field means it's blocked pending hydration.
        //   - A non-null dehydrated field can use isSuspenseInstancePending or
        //     isSuspenseInstanceFallback to query the reason for being dehydrated.
        // - A null dehydrated field means it's blocked by something suspending and
        //   we're currently showing a fallback instead.
        function findFirstSuspended(row) {
            var node = row;
            while(node !== null){
                if (node.tag === SuspenseComponent) {
                    var state = node.memoizedState;
                    if (state !== null) {
                        var dehydrated = state.dehydrated;
                        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                            return node;
                        }
                    }
                } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
                // keep track of whether it suspended or not.
                node.memoizedProps.revealOrder !== undefined) {
                    var didSuspend = (node.flags & DidCapture) !== NoFlags$1;
                    if (didSuspend) {
                        return node;
                    }
                } else if (node.child !== null) {
                    node.child.return = node;
                    node = node.child;
                    continue;
                }
                if (node === row) {
                    return null;
                }
                while(node.sibling === null){
                    if (node.return === null || node.return === row) {
                        return null;
                    }
                    node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
            }
            return null;
        }
        var NoFlags = /*   */ 0; // Represents whether effect should fire.
        var HasEffect = /* */ 1; // Represents the phase in which the effect (not the clean-up) fires.
        var Insertion = /* */ 2;
        var Layout = /*    */ 4;
        var Passive = /*   */ 8;
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig;
        var didWarnAboutMismatchedHooksForComponent;
        var didWarnUncachedGetSnapshot;
        var didWarnAboutUseWrappedInTryCatch;
        var didWarnAboutAsyncClientComponent;
        {
            didWarnAboutMismatchedHooksForComponent = new Set();
            didWarnAboutUseWrappedInTryCatch = new Set();
            didWarnAboutAsyncClientComponent = new Set();
        }
        // lifetime of an effect. In Rust terms, a RefCell. We use it to store the
        // "destroy" function that is returned from an effect, because that is stateful.
        // The field is `undefined` if the effect is unmounted, or if the effect ran
        // but is not stateful. We don't explicitly track whether the effect is mounted
        // or unmounted because that can be inferred by the hiddenness of the fiber in
        // the tree, i.e. whether there is a hidden Offscreen fiber above it.
        //
        // It's unfortunate that this is stored on a separate object, because it adds
        // more memory per effect instance, but it's conceptually sound. I think there's
        // likely a better data structure we could use for effects; perhaps just one
        // array of effect instances per fiber. But I think this is OK for now despite
        // the additional memory and we can follow up with performance
        // optimizations later.
        // These are set right before calling the component.
        var renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from
        // the work-in-progress hook.
        var currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The
        // current hook list is the list that belongs to the current fiber. The
        // work-in-progress hook list is a new list that will be added to the
        // work-in-progress fiber.
        var currentHook = null;
        var workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This
        // does not get reset if we do another render pass; only when we're completely
        // finished evaluating this component. This is an optimization so we know
        // whether we need to clear render phase updates after a throw.
        var didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This
        // gets reset after each attempt.
        // TODO: Maybe there's some way to consolidate this with
        // `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.
        var didScheduleRenderPhaseUpdateDuringThisPass = false;
        var shouldDoubleInvokeUserFnsInHooksDEV = false; // Counts the number of useId hooks in this component.
        var localIdCounter = 0; // Counts number of `use`-d thenables
        var thenableIndexCounter = 0;
        var thenableState = null; // Used for ids that are generated completely client-side (i.e. not during
        // hydration). This counter is global, so client ids are not stable across
        // render attempts.
        var globalClientIdCounter = 0;
        var RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook
        var currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.
        // The list stores the order of hooks used during the initial render (mount).
        // Subsequent renders (updates) reference this list.
        var hookTypesDev = null;
        var hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore
        // the dependencies for Hooks that need them (e.g. useEffect or useMemo).
        // When true, such Hooks will always be "remounted". Only used during hot reload.
        var ignorePreviousDependencies = false;
        function mountHookTypesDev() {
            {
                var hookName = currentHookNameInDev;
                if (hookTypesDev === null) {
                    hookTypesDev = [
                        hookName
                    ];
                } else {
                    hookTypesDev.push(hookName);
                }
            }
        }
        function updateHookTypesDev() {
            {
                var hookName = currentHookNameInDev;
                if (hookTypesDev !== null) {
                    hookTypesUpdateIndexDev++;
                    if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                        warnOnHookMismatchInDev(hookName);
                    }
                }
            }
        }
        function checkDepsAreArrayDev(deps) {
            {
                if (deps !== undefined && deps !== null && !isArray(deps)) {
                    // Verify deps, but only on mount to avoid extra checks.
                    // It's unlikely their type would change as usually you define them inline.
                    error('%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps);
                }
            }
        }
        function warnOnHookMismatchInDev(currentHookName) {
            {
                var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
                if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
                    didWarnAboutMismatchedHooksForComponent.add(componentName);
                    if (hookTypesDev !== null) {
                        var table = '';
                        var secondColumnStart = 30;
                        for(var i = 0; i <= hookTypesUpdateIndexDev; i++){
                            var oldHookName = hookTypesDev[i];
                            var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                            var row = i + 1 + ". " + oldHookName; // Extra space so second column lines up
                            // lol @ IE not supporting String#repeat
                            while(row.length < secondColumnStart){
                                row += ' ';
                            }
                            row += newHookName + '\n';
                            table += row;
                        }
                        error('React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n' + '   Previous render            Next render\n' + '   ------------------------------------------------------\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n', componentName, table);
                    }
                }
            }
        }
        function warnIfAsyncClientComponent(Component) {
            {
                // This dev-only check only works for detecting native async functions,
                // not transpiled ones. There's also a prod check that we use to prevent
                // async client components from crashing the app; the prod one works even
                // for transpiled async functions. Neither mechanism is completely
                // bulletproof but together they cover the most common cases.
                var isAsyncFunction = Object.prototype.toString.call(Component) === '[object AsyncFunction]';
                if (isAsyncFunction) {
                    // Encountered an async Client Component. This is not yet supported.
                    var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
                    if (!didWarnAboutAsyncClientComponent.has(componentName)) {
                        didWarnAboutAsyncClientComponent.add(componentName);
                        error('async/await is not yet supported in Client Components, only ' + 'Server Components. This error is often caused by accidentally ' + "adding `'use client'` to a module that was originally written " + 'for the server.');
                    }
                }
            }
        }
        function throwInvalidHookError() {
            throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' + '2. You might be breaking the Rules of Hooks\n' + '3. You might have more than one copy of React in the same app\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
            {
                if (ignorePreviousDependencies) {
                    // Only true when this component is being hot reloaded.
                    return false;
                }
            }
            if (prevDeps === null) {
                {
                    error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);
                }
                return false;
            }
            {
                // Don't bother comparing lengths in prod because these arrays should be
                // passed inline.
                if (nextDeps.length !== prevDeps.length) {
                    error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\n\n' + 'Previous: %s\n' + 'Incoming: %s', currentHookNameInDev, "[" + prevDeps.join(', ') + "]", "[" + nextDeps.join(', ') + "]");
                }
            }
            for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){
                // $FlowFixMe[incompatible-use] found when upgrading Flow
                if (objectIs(nextDeps[i], prevDeps[i])) {
                    continue;
                }
                return false;
            }
            return true;
        }
        function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {
            renderLanes = nextRenderLanes;
            currentlyRenderingFiber$1 = workInProgress;
            {
                hookTypesDev = current !== null ? current._debugHookTypes : null;
                hookTypesUpdateIndexDev = -1; // Used for hot reloading:
                ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;
                warnIfAsyncClientComponent(Component);
            }
            workInProgress.memoizedState = null;
            workInProgress.updateQueue = null;
            workInProgress.lanes = NoLanes; // The following should have already been reset
            // currentHook = null;
            // workInProgressHook = null;
            // didScheduleRenderPhaseUpdate = false;
            // localIdCounter = 0;
            // thenableIndexCounter = 0;
            // thenableState = null;
            // TODO Warn if no hooks are used at all during mount, then some are used during update.
            // Currently we will identify the update render as a mount because memoizedState === null.
            // This is tricky because it's valid for certain types of components (e.g. React.lazy)
            // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.
            // Non-stateful hooks (e.g. context) don't get added to memoizedState,
            // so memoizedState would be null during updates and mounts.
            {
                if (current !== null && current.memoizedState !== null) {
                    ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
                } else if (hookTypesDev !== null) {
                    // This dispatcher handles an edge case where a component is updating,
                    // but no stateful hooks have been used.
                    // We want to match the production code behavior (which will use HooksDispatcherOnMount),
                    // but with the extra DEV validation to ensure hooks ordering hasn't changed.
                    // This dispatcher does that.
                    ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
                } else {
                    ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
                }
            }
            // help detect side effects. The logic for how this is implemented for in
            // hook components is a bit complex so let's break it down.
            //
            // We will invoke the entire component function twice. However, during the
            // second invocation of the component, the hook state from the first
            // invocation will be reused. That means things like `useMemo` functions won't
            // run again, because the deps will match and the memoized result will
            // be reused.
            //
            // We want memoized functions to run twice, too, so account for this, user
            // functions are double invoked during the *first* invocation of the component
            // function, and are *not* double invoked during the second incovation:
            //
            // - First execution of component function: user functions are double invoked
            // - Second execution of component function (in Strict Mode, during
            //   development): user functions are not double invoked.
            //
            // This is intentional for a few reasons; most importantly, it's because of
            // how `use` works when something suspends: it reuses the promise that was
            // passed during the first attempt. This is itself a form of memoization.
            // We need to be able to memoize the reactive inputs to the `use` call using
            // a hook (i.e. `useMemo`), which means, the reactive inputs to `use` must
            // come from the same component invocation as the output.
            //
            // There are plenty of tests to ensure this behavior is correct.
            var shouldDoubleRenderDEV = (workInProgress.mode & StrictLegacyMode) !== NoMode;
            shouldDoubleInvokeUserFnsInHooksDEV = shouldDoubleRenderDEV;
            var children = Component(props, secondArg);
            shouldDoubleInvokeUserFnsInHooksDEV = false; // Check if there was a render phase update
            if (didScheduleRenderPhaseUpdateDuringThisPass) {
                // Keep rendering until the component stabilizes (there are no more render
                // phase updates).
                children = renderWithHooksAgain(workInProgress, Component, props, secondArg);
            }
            if (shouldDoubleRenderDEV) {
                // In development, components are invoked twice to help detect side effects.
                setIsStrictModeForDevtools(true);
                try {
                    children = renderWithHooksAgain(workInProgress, Component, props, secondArg);
                } finally{
                    setIsStrictModeForDevtools(false);
                }
            }
            finishRenderingHooks(current, workInProgress);
            return children;
        }
        function finishRenderingHooks(current, workInProgress, Component) {
            {
                workInProgress._debugHookTypes = hookTypesDev;
            }
            // at the beginning of the render phase and there's no re-entrance.
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher; // This check uses currentHook so that it works the same in DEV and prod bundles.
            // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.
            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
                currentHookNameInDev = null;
                hookTypesDev = null;
                hookTypesUpdateIndexDev = -1; // Confirm that a static flag was not added or removed since the last
                // render. If this fires, it suggests that we incorrectly reset the static
                // flags in some other part of the codebase. This has happened before, for
                // example, in the SuspenseList implementation.
                if (current !== null && (current.flags & StaticMask) !== (workInProgress.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird
                // and creates false positives. To make this work in legacy mode, we'd
                // need to mark fibers that commit in an incomplete state, somehow. For
                // now I'll disable the warning that most of the bugs that would trigger
                // it are either exclusive to concurrent mode or exist in both.
                (current.mode & ConcurrentMode) !== NoMode) {
                    error('Internal React error: Expected static flag was missing. Please ' + 'notify the React team.');
                }
            }
            didScheduleRenderPhaseUpdate = false; // This is reset by checkDidRenderIdHook
            // localIdCounter = 0;
            thenableIndexCounter = 0;
            thenableState = null;
            if (didRenderTooFewHooks) {
                throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental ' + 'early return statement.');
            }
            {
                if (checkIfUseWrappedInTryCatch()) {
                    var componentName = getComponentNameFromFiber(workInProgress) || 'Unknown';
                    if (!didWarnAboutUseWrappedInTryCatch.has(componentName) && // This warning also fires if you suspend with `use` inside an
                    // async component. Since we warn for that above, we'll silence this
                    // second warning by checking here.
                    !didWarnAboutAsyncClientComponent.has(componentName)) {
                        didWarnAboutUseWrappedInTryCatch.add(componentName);
                        error('`use` was called from inside a try/catch block. This is not allowed ' + 'and can lead to unexpected behavior. To handle errors triggered ' + 'by `use`, wrap your component in a error boundary.');
                    }
                }
            }
        }
        function replaySuspendedComponentWithHooks(current, workInProgress, Component, props, secondArg) {
            // This function is used to replay a component that previously suspended,
            // after its data resolves.
            //
            // It's a simplified version of renderWithHooks, but it doesn't need to do
            // most of the set up work because they weren't reset when we suspended; they
            // only get reset when the component either completes (finishRenderingHooks)
            // or unwinds (resetHooksOnUnwind).
            {
                hookTypesUpdateIndexDev = -1; // Used for hot reloading:
                ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;
            }
            var children = renderWithHooksAgain(workInProgress, Component, props, secondArg);
            finishRenderingHooks(current, workInProgress);
            return children;
        }
        function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
            // This is used to perform another render pass. It's used when setState is
            // called during render, and for double invoking components in Strict Mode
            // during development.
            //
            // The state from the previous pass is reused whenever possible. So, state
            // updates that were already processed are not processed again, and memoized
            // functions (`useMemo`) are not invoked again.
            //
            // Keep rendering in a loop for as long as render phase updates continue to
            // be scheduled. Use a counter to prevent infinite loops.
            currentlyRenderingFiber$1 = workInProgress;
            var numberOfReRenders = 0;
            var children;
            do {
                if (didScheduleRenderPhaseUpdateDuringThisPass) {
                    // It's possible that a use() value depended on a state that was updated in
                    // this rerender, so we need to watch for different thenables this time.
                    thenableState = null;
                }
                thenableIndexCounter = 0;
                didScheduleRenderPhaseUpdateDuringThisPass = false;
                if (numberOfReRenders >= RE_RENDER_LIMIT) {
                    throw new Error('Too many re-renders. React limits the number of renders to prevent ' + 'an infinite loop.');
                }
                numberOfReRenders += 1;
                {
                    // Even when hot reloading, allow dependencies to stabilize
                    // after first render to prevent infinite render phase updates.
                    ignorePreviousDependencies = false;
                }
                currentHook = null;
                workInProgressHook = null;
                workInProgress.updateQueue = null;
                {
                    // Also validate hook order for cascading updates.
                    hookTypesUpdateIndexDev = -1;
                }
                ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
                children = Component(props, secondArg);
            }while (didScheduleRenderPhaseUpdateDuringThisPass)
            return children;
        }
        function renderTransitionAwareHostComponentWithHooks(current, workInProgress, lanes) {
            return renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, lanes);
        }
        function TransitionAwareHostComponent() {
            var dispatcher = ReactCurrentDispatcher$1.current;
            var _dispatcher$useState = dispatcher.useState(), maybeThenable = _dispatcher$useState[0];
            if (typeof maybeThenable.then === 'function') {
                var thenable = maybeThenable;
                return useThenable(thenable);
            } else {
                var status = maybeThenable;
                return status;
            }
        }
        function checkDidRenderIdHook() {
            // This should be called immediately after every renderWithHooks call.
            // Conceptually, it's part of the return value of renderWithHooks; it's only a
            // separate function to avoid using an array tuple.
            var didRenderIdHook = localIdCounter !== 0;
            localIdCounter = 0;
            return didRenderIdHook;
        }
        function bailoutHooks(current, workInProgress, lanes) {
            workInProgress.updateQueue = current.updateQueue; // TODO: Don't need to reset the flags here, because they're reset in the
            // complete phase (bubbleProperties).
            if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {
                workInProgress.flags &= ~(MountPassiveDev | MountLayoutDev | Passive$1 | Update);
            } else {
                workInProgress.flags &= ~(Passive$1 | Update);
            }
            current.lanes = removeLanes(current.lanes, lanes);
        }
        function resetHooksAfterThrow() {
            // This is called immediaetly after a throw. It shouldn't reset the entire
            // module state, because the work loop might decide to replay the component
            // again without rewinding.
            //
            // It should only reset things like the current dispatcher, to prevent hooks
            // from being called outside of a component.
            currentlyRenderingFiber$1 = null; // We can assume the previous dispatcher is always this one, since we set it
            // at the beginning of the render phase and there's no re-entrance.
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
        }
        function resetHooksOnUnwind(workInProgress) {
            if (didScheduleRenderPhaseUpdate) {
                // There were render phase updates. These are only valid for this render
                // phase, which we are now aborting. Remove the updates from the queues so
                // they do not persist to the next render. Do not remove updates from hooks
                // that weren't processed.
                //
                // Only reset the updates from the queue if it has a clone. If it does
                // not have a clone, that means it wasn't processed, and the updates were
                // scheduled before we entered the render phase.
                var hook = workInProgress.memoizedState;
                while(hook !== null){
                    var queue = hook.queue;
                    if (queue !== null) {
                        queue.pending = null;
                    }
                    hook = hook.next;
                }
                didScheduleRenderPhaseUpdate = false;
            }
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
                hookTypesDev = null;
                hookTypesUpdateIndexDev = -1;
                currentHookNameInDev = null;
            }
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            localIdCounter = 0;
            thenableIndexCounter = 0;
            thenableState = null;
        }
        function mountWorkInProgressHook() {
            var hook = {
                memoizedState: null,
                baseState: null,
                baseQueue: null,
                queue: null,
                next: null
            };
            if (workInProgressHook === null) {
                // This is the first hook in the list
                currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
            } else {
                // Append to the end of the list
                workInProgressHook = workInProgressHook.next = hook;
            }
            return workInProgressHook;
        }
        function updateWorkInProgressHook() {
            // This function is used both for updates and for re-renders triggered by a
            // render phase update. It assumes there is either a current hook we can
            // clone, or a work-in-progress hook from a previous render pass that we can
            // use as a base.
            var nextCurrentHook;
            if (currentHook === null) {
                var current = currentlyRenderingFiber$1.alternate;
                if (current !== null) {
                    nextCurrentHook = current.memoizedState;
                } else {
                    nextCurrentHook = null;
                }
            } else {
                nextCurrentHook = currentHook.next;
            }
            var nextWorkInProgressHook;
            if (workInProgressHook === null) {
                nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
            } else {
                nextWorkInProgressHook = workInProgressHook.next;
            }
            if (nextWorkInProgressHook !== null) {
                // There's already a work-in-progress. Reuse it.
                workInProgressHook = nextWorkInProgressHook;
                nextWorkInProgressHook = workInProgressHook.next;
                currentHook = nextCurrentHook;
            } else {
                // Clone from the current hook.
                if (nextCurrentHook === null) {
                    var currentFiber = currentlyRenderingFiber$1.alternate;
                    if (currentFiber === null) {
                        // This is the initial render. This branch is reached when the component
                        // suspends, resumes, then renders an additional hook.
                        // Should never be reached because we should switch to the mount dispatcher first.
                        throw new Error('Update hook called on initial render. This is likely a bug in React. Please file an issue.');
                    } else {
                        // This is an update. We should always have a current hook.
                        throw new Error('Rendered more hooks than during the previous render.');
                    }
                }
                currentHook = nextCurrentHook;
                var newHook = {
                    memoizedState: currentHook.memoizedState,
                    baseState: currentHook.baseState,
                    baseQueue: currentHook.baseQueue,
                    queue: currentHook.queue,
                    next: null
                };
                if (workInProgressHook === null) {
                    // This is the first hook in the list.
                    currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
                } else {
                    // Append to the end of the list.
                    workInProgressHook = workInProgressHook.next = newHook;
                }
            }
            return workInProgressHook;
        } // NOTE: defining two versions of this function to avoid size impact when this feature is disabled.
        // Previously this function was inlined, the additional `memoCache` property makes it not inlined.
        var createFunctionComponentUpdateQueue;
        {
            createFunctionComponentUpdateQueue = function() {
                return {
                    lastEffect: null,
                    events: null,
                    stores: null
                };
            };
        }
        function useThenable(thenable) {
            // Track the position of the thenable within this fiber.
            var index = thenableIndexCounter;
            thenableIndexCounter += 1;
            if (thenableState === null) {
                thenableState = createThenableState();
            }
            var result = trackUsedThenable(thenableState, thenable, index);
            if (currentlyRenderingFiber$1.alternate === null && (workInProgressHook === null ? currentlyRenderingFiber$1.memoizedState === null : workInProgressHook.next === null)) {
                // Initial render, and either this is the first time the component is
                // called, or there were no Hooks called after this use() the previous
                // time (perhaps because it threw). Subsequent Hook calls should use the
                // mount dispatcher.
                {
                    ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
                }
            }
            return result;
        }
        function use(usable) {
            if (usable !== null && typeof usable === 'object') {
                // $FlowFixMe[method-unbinding]
                if (typeof usable.then === 'function') {
                    // This is a thenable.
                    var thenable = usable;
                    return useThenable(thenable);
                } else if (usable.$$typeof === REACT_CONTEXT_TYPE) {
                    var context = usable;
                    return readContext(context);
                }
            } // eslint-disable-next-line react-internal/safe-string-coercion
            throw new Error('An unsupported type was passed to use(): ' + String(usable));
        }
        function basicStateReducer(state, action) {
            // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types
            return typeof action === 'function' ? action(state) : action;
        }
        function mountReducer(reducer, initialArg, init) {
            var hook = mountWorkInProgressHook();
            var initialState;
            if (init !== undefined) {
                initialState = init(initialArg);
                if (shouldDoubleInvokeUserFnsInHooksDEV) {
                    setIsStrictModeForDevtools(true);
                    init(initialArg);
                    setIsStrictModeForDevtools(false);
                }
            } else {
                initialState = initialArg;
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = {
                pending: null,
                lanes: NoLanes,
                dispatch: null,
                lastRenderedReducer: reducer,
                lastRenderedState: initialState
            };
            hook.queue = queue;
            var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
            return [
                hook.memoizedState,
                dispatch
            ];
        }
        function updateReducer(reducer, initialArg, init) {
            var hook = updateWorkInProgressHook();
            return updateReducerImpl(hook, currentHook, reducer);
        }
        function updateReducerImpl(hook, current, reducer) {
            var queue = hook.queue;
            if (queue === null) {
                throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');
            }
            queue.lastRenderedReducer = reducer; // The last rebase update that is NOT part of the base state.
            var baseQueue = hook.baseQueue; // The last pending update that hasn't been processed yet.
            var pendingQueue = queue.pending;
            if (pendingQueue !== null) {
                // We have new updates that haven't been processed yet.
                // We'll add them to the base queue.
                if (baseQueue !== null) {
                    // Merge the pending queue and the base queue.
                    var baseFirst = baseQueue.next;
                    var pendingFirst = pendingQueue.next;
                    baseQueue.next = pendingFirst;
                    pendingQueue.next = baseFirst;
                }
                {
                    if (current.baseQueue !== baseQueue) {
                        // Internal invariant that should never happen, but feasibly could in
                        // the future if we implement resuming, or some form of that.
                        error('Internal error: Expected work-in-progress queue to be a clone. ' + 'This is a bug in React.');
                    }
                }
                current.baseQueue = baseQueue = pendingQueue;
                queue.pending = null;
            }
            var baseState = hook.baseState;
            if (baseQueue === null) {
                // If there are no pending updates, then the memoized state should be the
                // same as the base state. Currently these only diverge in the case of
                // useOptimistic, because useOptimistic accepts a new baseState on
                // every render.
                hook.memoizedState = baseState; // We don't need to call markWorkInProgressReceivedUpdate because
            // baseState is derived from other reactive values.
            } else {
                // We have a queue to process.
                var first = baseQueue.next;
                var newState = baseState;
                var newBaseState = null;
                var newBaseQueueFirst = null;
                var newBaseQueueLast = null;
                var update = first;
                var didReadFromEntangledAsyncAction = false;
                do {
                    // An extra OffscreenLane bit is added to updates that were made to
                    // a hidden tree, so that we can distinguish them from updates that were
                    // already there when the tree was hidden.
                    var updateLane = removeLanes(update.lane, OffscreenLane);
                    var isHiddenUpdate = updateLane !== update.lane; // Check if this update was made while the tree was hidden. If so, then
                    // it's not a "base" update and we should disregard the extra base lanes
                    // that were added to renderLanes when we entered the Offscreen tree.
                    var shouldSkipUpdate = isHiddenUpdate ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane) : !isSubsetOfLanes(renderLanes, updateLane);
                    if (shouldSkipUpdate) {
                        // Priority is insufficient. Skip this update. If this is the first
                        // skipped update, the previous update/state is the new base
                        // update/state.
                        var clone = {
                            lane: updateLane,
                            revertLane: update.revertLane,
                            action: update.action,
                            hasEagerState: update.hasEagerState,
                            eagerState: update.eagerState,
                            next: null
                        };
                        if (newBaseQueueLast === null) {
                            newBaseQueueFirst = newBaseQueueLast = clone;
                            newBaseState = newState;
                        } else {
                            newBaseQueueLast = newBaseQueueLast.next = clone;
                        } // Update the remaining priority in the queue.
                        // TODO: Don't need to accumulate this. Instead, we can remove
                        // renderLanes from the original lanes.
                        currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                        markSkippedUpdateLanes(updateLane);
                    } else {
                        // This update does have sufficient priority.
                        // Check if this is an optimistic update.
                        var revertLane = update.revertLane;
                        if (revertLane === NoLane) {
                            // This is not an optimistic update, and we're going to apply it now.
                            // But, if there were earlier updates that were skipped, we need to
                            // leave this update in the queue so it can be rebased later.
                            if (newBaseQueueLast !== null) {
                                var _clone = {
                                    // This update is going to be committed so we never want uncommit
                                    // it. Using NoLane works because 0 is a subset of all bitmasks, so
                                    // this will never be skipped by the check above.
                                    lane: NoLane,
                                    revertLane: NoLane,
                                    action: update.action,
                                    hasEagerState: update.hasEagerState,
                                    eagerState: update.eagerState,
                                    next: null
                                };
                                newBaseQueueLast = newBaseQueueLast.next = _clone;
                            } // Check if this update is part of a pending async action. If so,
                            // we'll need to suspend until the action has finished, so that it's
                            // batched together with future updates in the same action.
                            if (updateLane === peekEntangledActionLane()) {
                                didReadFromEntangledAsyncAction = true;
                            }
                        } else {
                            // This is an optimistic update. If the "revert" priority is
                            // sufficient, don't apply the update. Otherwise, apply the update,
                            // but leave it in the queue so it can be either reverted or
                            // rebased in a subsequent render.
                            if (isSubsetOfLanes(renderLanes, revertLane)) {
                                // The transition that this optimistic update is associated with
                                // has finished. Pretend the update doesn't exist by skipping
                                // over it.
                                update = update.next; // Check if this update is part of a pending async action. If so,
                                // we'll need to suspend until the action has finished, so that it's
                                // batched together with future updates in the same action.
                                if (revertLane === peekEntangledActionLane()) {
                                    didReadFromEntangledAsyncAction = true;
                                }
                                continue;
                            } else {
                                var _clone2 = {
                                    // Once we commit an optimistic update, we shouldn't uncommit it
                                    // until the transition it is associated with has finished
                                    // (represented by revertLane). Using NoLane here works because 0
                                    // is a subset of all bitmasks, so this will never be skipped by
                                    // the check above.
                                    lane: NoLane,
                                    // Reuse the same revertLane so we know when the transition
                                    // has finished.
                                    revertLane: update.revertLane,
                                    action: update.action,
                                    hasEagerState: update.hasEagerState,
                                    eagerState: update.eagerState,
                                    next: null
                                };
                                if (newBaseQueueLast === null) {
                                    newBaseQueueFirst = newBaseQueueLast = _clone2;
                                    newBaseState = newState;
                                } else {
                                    newBaseQueueLast = newBaseQueueLast.next = _clone2;
                                } // Update the remaining priority in the queue.
                                // TODO: Don't need to accumulate this. Instead, we can remove
                                // renderLanes from the original lanes.
                                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, revertLane);
                                markSkippedUpdateLanes(revertLane);
                            }
                        } // Process this update.
                        var action = update.action;
                        if (shouldDoubleInvokeUserFnsInHooksDEV) {
                            reducer(newState, action);
                        }
                        if (update.hasEagerState) {
                            // If this update is a state update (not a reducer) and was processed eagerly,
                            // we can use the eagerly computed state
                            newState = update.eagerState;
                        } else {
                            newState = reducer(newState, action);
                        }
                    }
                    update = update.next;
                }while (update !== null && update !== first)
                if (newBaseQueueLast === null) {
                    newBaseState = newState;
                } else {
                    newBaseQueueLast.next = newBaseQueueFirst;
                } // Mark that the fiber performed work, but only if the new state is
                // different from the current state.
                if (!objectIs(newState, hook.memoizedState)) {
                    markWorkInProgressReceivedUpdate(); // Check if this update is part of a pending async action. If so, we'll
                    // need to suspend until the action has finished, so that it's batched
                    // together with future updates in the same action.
                    // TODO: Once we support hooks inside useMemo (or an equivalent
                    // memoization boundary like Forget), hoist this logic so that it only
                    // suspends if the memo boundary produces a new value.
                    if (didReadFromEntangledAsyncAction) {
                        var entangledActionThenable = peekEntangledActionThenable();
                        if (entangledActionThenable !== null) {
                            // TODO: Instead of the throwing the thenable directly, throw a
                            // special object like `use` does so we can detect if it's captured
                            // by userspace.
                            throw entangledActionThenable;
                        }
                    }
                }
                hook.memoizedState = newState;
                hook.baseState = newBaseState;
                hook.baseQueue = newBaseQueueLast;
                queue.lastRenderedState = newState;
            }
            if (baseQueue === null) {
                // `queue.lanes` is used for entangling transitions. We can set it back to
                // zero once the queue is empty.
                queue.lanes = NoLanes;
            }
            var dispatch = queue.dispatch;
            return [
                hook.memoizedState,
                dispatch
            ];
        }
        function rerenderReducer(reducer, initialArg, init) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (queue === null) {
                throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');
            }
            queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous
            // work-in-progress hook.
            var dispatch = queue.dispatch;
            var lastRenderPhaseUpdate = queue.pending;
            var newState = hook.memoizedState;
            if (lastRenderPhaseUpdate !== null) {
                // The queue doesn't persist past this render pass.
                queue.pending = null;
                var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
                var update = firstRenderPhaseUpdate;
                do {
                    // Process this render phase update. We don't have to check the
                    // priority because it will always be the same as the current
                    // render's.
                    var action = update.action;
                    newState = reducer(newState, action);
                    update = update.next;
                }while (update !== firstRenderPhaseUpdate) // Mark that the fiber performed work, but only if the new state is
                // different from the current state.
                if (!objectIs(newState, hook.memoizedState)) {
                    markWorkInProgressReceivedUpdate();
                }
                hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to
                // the base state unless the queue is empty.
                // TODO: Not sure if this is the desired semantics, but it's what we
                // do for gDSFP. I can't remember why.
                if (hook.baseQueue === null) {
                    hook.baseState = newState;
                }
                queue.lastRenderedState = newState;
            }
            return [
                newState,
                dispatch
            ];
        }
        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber$1;
            var hook = mountWorkInProgressHook();
            var nextSnapshot;
            var isHydrating = getIsHydrating();
            if (isHydrating) {
                if (getServerSnapshot === undefined) {
                    throw new Error('Missing getServerSnapshot, which is required for ' + 'server-rendered content. Will revert to client rendering.');
                }
                nextSnapshot = getServerSnapshot();
                {
                    if (!didWarnUncachedGetSnapshot) {
                        if (nextSnapshot !== getServerSnapshot()) {
                            error('The result of getServerSnapshot should be cached to avoid an infinite loop');
                            didWarnUncachedGetSnapshot = true;
                        }
                    }
                }
            } else {
                nextSnapshot = getSnapshot();
                {
                    if (!didWarnUncachedGetSnapshot) {
                        var cachedSnapshot = getSnapshot();
                        if (!objectIs(nextSnapshot, cachedSnapshot)) {
                            error('The result of getSnapshot should be cached to avoid an infinite loop');
                            didWarnUncachedGetSnapshot = true;
                        }
                    }
                }
                // Right before committing, we will walk the tree and check if any of the
                // stores were mutated.
                //
                // We won't do this if we're hydrating server-rendered content, because if
                // the content is stale, it's already visible anyway. Instead we'll patch
                // it up in a passive effect.
                var root = getWorkInProgressRoot();
                if (root === null) {
                    throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');
                }
                var rootRenderLanes = getWorkInProgressRootRenderLanes();
                if (!includesBlockingLane(root, rootRenderLanes)) {
                    pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
                }
            } // Read the current snapshot from the store on every render. This breaks the
            // normal rules of React, and only works because store updates are
            // always synchronous.
            hook.memoizedState = nextSnapshot;
            var inst = {
                value: nextSnapshot,
                getSnapshot: getSnapshot
            };
            hook.queue = inst; // Schedule an effect to subscribe to the store.
            mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
                subscribe
            ]); // Schedule an effect to update the mutable instance fields. We will update
            // this whenever subscribe, getSnapshot, or value changes. Because there's no
            // clean-up function, and we track the deps correctly, we can call pushEffect
            // directly, without storing any additional state. For the same reason, we
            // don't need to set a static flag, either.
            fiber.flags |= Passive$1;
            pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), createEffectInstance(), null);
            return nextSnapshot;
        }
        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber$1;
            var hook = updateWorkInProgressHook(); // Read the current snapshot from the store on every render. This breaks the
            // normal rules of React, and only works because store updates are
            // always synchronous.
            var nextSnapshot;
            var isHydrating = getIsHydrating();
            if (isHydrating) {
                // Needed for strict mode double render
                if (getServerSnapshot === undefined) {
                    throw new Error('Missing getServerSnapshot, which is required for ' + 'server-rendered content. Will revert to client rendering.');
                }
                nextSnapshot = getServerSnapshot();
            } else {
                nextSnapshot = getSnapshot();
                {
                    if (!didWarnUncachedGetSnapshot) {
                        var cachedSnapshot = getSnapshot();
                        if (!objectIs(nextSnapshot, cachedSnapshot)) {
                            error('The result of getSnapshot should be cached to avoid an infinite loop');
                            didWarnUncachedGetSnapshot = true;
                        }
                    }
                }
            }
            var prevSnapshot = (currentHook || hook).memoizedState;
            var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
            if (snapshotChanged) {
                hook.memoizedState = nextSnapshot;
                markWorkInProgressReceivedUpdate();
            }
            var inst = hook.queue;
            updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
                subscribe
            ]); // Whenever getSnapshot or subscribe changes, we need to check in the
            // commit phase if there was an interleaved mutation. In concurrent mode
            // this can happen all the time, but even in synchronous mode, an earlier
            // effect may have mutated the store.
            if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the subscribe function changed. We can save some memory by
            // checking whether we scheduled a subscription effect above.
            workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
                fiber.flags |= Passive$1;
                pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), createEffectInstance(), null); // Unless we're rendering a blocking lane, schedule a consistency check.
                // Right before committing, we will walk the tree and check if any of the
                // stores were mutated.
                var root = getWorkInProgressRoot();
                if (root === null) {
                    throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');
                }
                if (!isHydrating && !includesBlockingLane(root, renderLanes)) {
                    pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
                }
            }
            return nextSnapshot;
        }
        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
            fiber.flags |= StoreConsistency;
            var check = {
                getSnapshot: getSnapshot,
                value: renderedSnapshot
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
                componentUpdateQueue = createFunctionComponentUpdateQueue();
                currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
                componentUpdateQueue.stores = [
                    check
                ];
            } else {
                var stores = componentUpdateQueue.stores;
                if (stores === null) {
                    componentUpdateQueue.stores = [
                        check
                    ];
                } else {
                    stores.push(check);
                }
            }
        }
        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
            // These are updated in the passive phase
            inst.value = nextSnapshot;
            inst.getSnapshot = getSnapshot; // Something may have been mutated in between render and commit. This could
            // have been in an event that fired before the passive effects, or it could
            // have been in a layout effect. In that case, we would have used the old
            // snapsho and getSnapshot values to bail out. We need to check one more time.
            if (checkIfSnapshotChanged(inst)) {
                // Force a re-render.
                forceStoreRerender(fiber);
            }
        }
        function subscribeToStore(fiber, inst, subscribe) {
            var handleStoreChange = function() {
                // The store changed. Check if the snapshot changed since the last time we
                // read from the store.
                if (checkIfSnapshotChanged(inst)) {
                    // Force a re-render.
                    forceStoreRerender(fiber);
                }
            }; // Subscribe to the store and return a clean-up function.
            return subscribe(handleStoreChange);
        }
        function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            var prevValue = inst.value;
            try {
                var nextValue = latestGetSnapshot();
                return !objectIs(prevValue, nextValue);
            } catch (error) {
                return true;
            }
        }
        function forceStoreRerender(fiber) {
            var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root !== null) {
                scheduleUpdateOnFiber(root, fiber, SyncLane);
            }
        }
        function mountStateImpl(initialState) {
            var hook = mountWorkInProgressHook();
            if (typeof initialState === 'function') {
                var initialStateInitializer = initialState; // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types
                initialState = initialStateInitializer();
                if (shouldDoubleInvokeUserFnsInHooksDEV) {
                    setIsStrictModeForDevtools(true); // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types
                    initialStateInitializer();
                    setIsStrictModeForDevtools(false);
                }
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = {
                pending: null,
                lanes: NoLanes,
                dispatch: null,
                lastRenderedReducer: basicStateReducer,
                lastRenderedState: initialState
            };
            hook.queue = queue;
            return hook;
        }
        function mountState(initialState) {
            var hook = mountStateImpl(initialState);
            var queue = hook.queue;
            var dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
            queue.dispatch = dispatch;
            return [
                hook.memoizedState,
                dispatch
            ];
        }
        function updateState(initialState) {
            return updateReducer(basicStateReducer);
        }
        function rerenderState(initialState) {
            return rerenderReducer(basicStateReducer);
        }
        function mountOptimistic(passthrough, reducer) {
            var hook = mountWorkInProgressHook();
            hook.memoizedState = hook.baseState = passthrough;
            var queue = {
                pending: null,
                lanes: NoLanes,
                dispatch: null,
                // Optimistic state does not use the eager update optimization.
                lastRenderedReducer: null,
                lastRenderedState: null
            };
            hook.queue = queue; // This is different than the normal setState function.
            var dispatch = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, true, queue);
            queue.dispatch = dispatch;
            return [
                passthrough,
                dispatch
            ];
        }
        function updateOptimistic(passthrough, reducer) {
            var hook = updateWorkInProgressHook();
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        }
        function updateOptimisticImpl(hook, current, passthrough, reducer) {
            // Optimistic updates are always rebased on top of the latest value passed in
            // as an argument. It's called a passthrough because if there are no pending
            // updates, it will be returned as-is.
            //
            // Reset the base state to the passthrough. Future updates will be applied
            // on top of this.
            hook.baseState = passthrough; // If a reducer is not provided, default to the same one used by useState.
            var resolvedReducer = typeof reducer === 'function' ? reducer : basicStateReducer;
            return updateReducerImpl(hook, currentHook, resolvedReducer);
        }
        function rerenderOptimistic(passthrough, reducer) {
            // Unlike useState, useOptimistic doesn't support render phase updates.
            // Also unlike useState, we need to replay all pending updates again in case
            // the passthrough value changed.
            //
            // So instead of a forked re-render implementation that knows how to handle
            // render phase udpates, we can use the same implementation as during a
            // regular mount or update.
            var hook = updateWorkInProgressHook();
            if (currentHook !== null) {
                // This is an update. Process the update queue.
                return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
            } // This is a mount. No updates to process.
            // Reset the base state to the passthrough. Future updates will be applied
            // on top of this.
            hook.baseState = passthrough;
            var dispatch = hook.queue.dispatch;
            return [
                passthrough,
                dispatch
            ];
        } // useFormState actions run sequentially, because each action receives the
        // previous state as an argument. We store pending actions on a queue.
        function dispatchFormState(fiber, actionQueue, setState, payload) {
            if (isRenderPhaseUpdate(fiber)) {
                throw new Error('Cannot update form state while rendering.');
            }
            var last = actionQueue.pending;
            if (last === null) {
                // There are no pending actions; this is the first one. We can run
                // it immediately.
                var newLast = {
                    payload: payload,
                    next: null // circular
                };
                newLast.next = actionQueue.pending = newLast;
                runFormStateAction(actionQueue, setState, payload);
            } else {
                // There's already an action running. Add to the queue.
                var first = last.next;
                var _newLast = {
                    payload: payload,
                    next: first
                };
                actionQueue.pending = last.next = _newLast;
            }
        }
        function runFormStateAction(actionQueue, setState, payload) {
            var action = actionQueue.action;
            var prevState = actionQueue.state; // This is a fork of startTransition
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            var currentTransition = {
                _callbacks: new Set()
            };
            ReactCurrentBatchConfig$3.transition = currentTransition;
            {
                ReactCurrentBatchConfig$3.transition._updatedFibers = new Set();
            }
            try {
                var returnValue = action(prevState, payload);
                if (returnValue !== null && typeof returnValue === 'object' && // $FlowFixMe[method-unbinding]
                typeof returnValue.then === 'function') {
                    var thenable = returnValue;
                    notifyTransitionCallbacks(currentTransition, thenable); // Attach a listener to read the return state of the action. As soon as
                    // this resolves, we can run the next action in the sequence.
                    thenable.then(function(nextState) {
                        actionQueue.state = nextState;
                        finishRunningFormStateAction(actionQueue, setState);
                    }, function() {
                        return finishRunningFormStateAction(actionQueue, setState);
                    });
                    setState(thenable);
                } else {
                    setState(returnValue);
                    var nextState = returnValue;
                    actionQueue.state = nextState;
                    finishRunningFormStateAction(actionQueue, setState);
                }
            } catch (error) {
                // This is a trick to get the `useFormState` hook to rethrow the error.
                // When it unwraps the thenable with the `use` algorithm, the error
                // will be thrown.
                var rejectedThenable = {
                    then: function() {},
                    status: 'rejected',
                    reason: error // $FlowFixMe: Not sure why this doesn't work
                };
                setState(rejectedThenable);
                finishRunningFormStateAction(actionQueue, setState);
            } finally{
                ReactCurrentBatchConfig$3.transition = prevTransition;
                {
                    if (prevTransition === null && currentTransition._updatedFibers) {
                        var updatedFibersCount = currentTransition._updatedFibers.size;
                        currentTransition._updatedFibers.clear();
                        if (updatedFibersCount > 10) {
                            warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');
                        }
                    }
                }
            }
        }
        function finishRunningFormStateAction(actionQueue, setState) {
            // The action finished running. Pop it from the queue and run the next pending
            // action, if there are any.
            var last = actionQueue.pending;
            if (last !== null) {
                var first = last.next;
                if (first === last) {
                    // This was the last action in the queue.
                    actionQueue.pending = null;
                } else {
                    // Remove the first node from the circular queue.
                    var next = first.next;
                    last.next = next; // Run the next action.
                    runFormStateAction(actionQueue, setState, next.payload);
                }
            }
        }
        function formStateReducer(oldState, newState) {
            return newState;
        }
        function mountFormState(action, initialStateProp, permalink) {
            var initialState = initialStateProp;
            if (getIsHydrating()) {
                var root = getWorkInProgressRoot();
                var ssrFormState = root.formState; // If a formState option was passed to the root, there are form state
                // markers that we need to hydrate. These indicate whether the form state
                // matches this hook instance.
                if (ssrFormState !== null) {
                    var isMatching = tryToClaimNextHydratableFormMarkerInstance();
                    if (isMatching) {
                        initialState = ssrFormState[0];
                    }
                }
            } // State hook. The state is stored in a thenable which is then unwrapped by
            // the `use` algorithm during render.
            var stateHook = mountWorkInProgressHook();
            stateHook.memoizedState = stateHook.baseState = initialState; // TODO: Typing this "correctly" results in recursion limit errors
            // const stateQueue: UpdateQueue<S | Awaited<S>, S | Awaited<S>> = {
            var stateQueue = {
                pending: null,
                lanes: NoLanes,
                dispatch: null,
                lastRenderedReducer: formStateReducer,
                lastRenderedState: initialState
            };
            stateHook.queue = stateQueue;
            var setState = dispatchSetState.bind(null, currentlyRenderingFiber$1, stateQueue);
            stateQueue.dispatch = setState; // Action queue hook. This is used to queue pending actions. The queue is
            // shared between all instances of the hook. Similar to a regular state queue,
            // but different because the actions are run sequentially, and they run in
            // an event instead of during render.
            var actionQueueHook = mountWorkInProgressHook();
            var actionQueue = {
                state: initialState,
                dispatch: null,
                // circular
                action: action,
                pending: null
            };
            actionQueueHook.queue = actionQueue;
            var dispatch = dispatchFormState.bind(null, currentlyRenderingFiber$1, actionQueue, setState);
            actionQueue.dispatch = dispatch; // Stash the action function on the memoized state of the hook. We'll use this
            // to detect when the action function changes so we can update it in
            // an effect.
            actionQueueHook.memoizedState = action;
            return [
                initialState,
                dispatch
            ];
        }
        function updateFormState(action, initialState, permalink) {
            var stateHook = updateWorkInProgressHook();
            var currentStateHook = currentHook;
            return updateFormStateImpl(stateHook, currentStateHook, action);
        }
        function updateFormStateImpl(stateHook, currentStateHook, action, initialState, permalink) {
            var _updateReducerImpl = updateReducerImpl(stateHook, currentStateHook, formStateReducer), actionResult = _updateReducerImpl[0]; // This will suspend until the action finishes.
            var state = typeof actionResult === 'object' && actionResult !== null && // $FlowFixMe[method-unbinding]
            typeof actionResult.then === 'function' ? useThenable(actionResult) : actionResult;
            var actionQueueHook = updateWorkInProgressHook();
            var actionQueue = actionQueueHook.queue;
            var dispatch = actionQueue.dispatch; // Check if a new action was passed. If so, update it in an effect.
            var prevAction = actionQueueHook.memoizedState;
            if (action !== prevAction) {
                currentlyRenderingFiber$1.flags |= Passive$1;
                pushEffect(HasEffect | Passive, formStateActionEffect.bind(null, actionQueue, action), createEffectInstance(), null);
            }
            return [
                state,
                dispatch
            ];
        }
        function formStateActionEffect(actionQueue, action) {
            actionQueue.action = action;
        }
        function rerenderFormState(action, initialState, permalink) {
            // Unlike useState, useFormState doesn't support render phase updates.
            // Also unlike useState, we need to replay all pending updates again in case
            // the passthrough value changed.
            //
            // So instead of a forked re-render implementation that knows how to handle
            // render phase udpates, we can use the same implementation as during a
            // regular mount or update.
            var stateHook = updateWorkInProgressHook();
            var currentStateHook = currentHook;
            if (currentStateHook !== null) {
                // This is an update. Process the update queue.
                return updateFormStateImpl(stateHook, currentStateHook, action);
            } // This is a mount. No updates to process.
            var state = stateHook.memoizedState;
            var actionQueueHook = updateWorkInProgressHook();
            var actionQueue = actionQueueHook.queue;
            var dispatch = actionQueue.dispatch; // This may have changed during the rerender.
            actionQueueHook.memoizedState = action;
            return [
                state,
                dispatch
            ];
        }
        function pushEffect(tag, create, inst, deps) {
            var effect = {
                tag: tag,
                create: create,
                inst: inst,
                deps: deps,
                // Circular
                next: null
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
                componentUpdateQueue = createFunctionComponentUpdateQueue();
                currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
                componentUpdateQueue.lastEffect = effect.next = effect;
            } else {
                var lastEffect = componentUpdateQueue.lastEffect;
                if (lastEffect === null) {
                    componentUpdateQueue.lastEffect = effect.next = effect;
                } else {
                    var firstEffect = lastEffect.next;
                    lastEffect.next = effect;
                    effect.next = firstEffect;
                    componentUpdateQueue.lastEffect = effect;
                }
            }
            return effect;
        }
        function createEffectInstance() {
            return {
                destroy: undefined
            };
        }
        function mountRef(initialValue) {
            var hook = mountWorkInProgressHook();
            {
                var _ref2 = {
                    current: initialValue
                };
                hook.memoizedState = _ref2;
                return _ref2;
            }
        }
        function updateRef(initialValue) {
            var hook = updateWorkInProgressHook();
            return hook.memoizedState;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === undefined ? null : deps;
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, createEffectInstance(), nextDeps);
        }
        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === undefined ? null : deps;
            var effect = hook.memoizedState;
            var inst = effect.inst; // currentHook is null on initial mount when rerendering after a render phase
            // state update or for strict mode.
            if (currentHook !== null) {
                if (nextDeps !== null) {
                    var prevEffect = currentHook.memoizedState;
                    var prevDeps = prevEffect.deps;
                    if (areHookInputsEqual(nextDeps, prevDeps)) {
                        hook.memoizedState = pushEffect(hookFlags, create, inst, nextDeps);
                        return;
                    }
                }
            }
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, inst, nextDeps);
        }
        function mountEffect(create, deps) {
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (currentlyRenderingFiber$1.mode & NoStrictPassiveEffectsMode) === NoMode) {
                mountEffectImpl(MountPassiveDev | Passive$1 | PassiveStatic, Passive, create, deps);
            } else {
                mountEffectImpl(Passive$1 | PassiveStatic, Passive, create, deps);
            }
        }
        function updateEffect(create, deps) {
            updateEffectImpl(Passive$1, Passive, create, deps);
        }
        function mountInsertionEffect(create, deps) {
            mountEffectImpl(Update, Insertion, create, deps);
        }
        function updateInsertionEffect(create, deps) {
            return updateEffectImpl(Update, Insertion, create, deps);
        }
        function mountLayoutEffect(create, deps) {
            var fiberFlags = Update | LayoutStatic;
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
                fiberFlags |= MountLayoutDev;
            }
            return mountEffectImpl(fiberFlags, Layout, create, deps);
        }
        function updateLayoutEffect(create, deps) {
            return updateEffectImpl(Update, Layout, create, deps);
        }
        function imperativeHandleEffect(create, ref) {
            if (typeof ref === 'function') {
                var refCallback = ref;
                var inst = create();
                refCallback(inst);
                return function() {
                    refCallback(null);
                };
            } else if (ref !== null && ref !== undefined) {
                var refObject = ref;
                {
                    if (!refObject.hasOwnProperty('current')) {
                        error('Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');
                    }
                }
                var _inst = create();
                refObject.current = _inst;
                return function() {
                    refObject.current = null;
                };
            }
        }
        function mountImperativeHandle(ref, create, deps) {
            {
                if (typeof create !== 'function') {
                    error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');
                }
            }
            var effectDeps = deps !== null && deps !== undefined ? deps.concat([
                ref
            ]) : null;
            var fiberFlags = Update | LayoutStatic;
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
                fiberFlags |= MountLayoutDev;
            }
            mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
        }
        function updateImperativeHandle(ref, create, deps) {
            {
                if (typeof create !== 'function') {
                    error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');
                }
            }
            var effectDeps = deps !== null && deps !== undefined ? deps.concat([
                ref
            ]) : null;
            updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
        }
        function mountDebugValue(value, formatterFn) {
        // The react-debug-hooks package injects its own implementation
        // so that e.g. DevTools can display custom hook values.
        }
        var updateDebugValue = mountDebugValue;
        function mountCallback(callback, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === undefined ? null : deps;
            hook.memoizedState = [
                callback,
                nextDeps
            ];
            return callback;
        }
        function updateCallback(callback, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === undefined ? null : deps;
            var prevState = hook.memoizedState;
            if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                    return prevState[0];
                }
            }
            hook.memoizedState = [
                callback,
                nextDeps
            ];
            return callback;
        }
        function mountMemo(nextCreate, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === undefined ? null : deps;
            var nextValue = nextCreate();
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
                setIsStrictModeForDevtools(true);
                nextCreate();
                setIsStrictModeForDevtools(false);
            }
            hook.memoizedState = [
                nextValue,
                nextDeps
            ];
            return nextValue;
        }
        function updateMemo(nextCreate, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === undefined ? null : deps;
            var prevState = hook.memoizedState; // Assume these are defined. If they're not, areHookInputsEqual will warn.
            if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                    return prevState[0];
                }
            }
            var nextValue = nextCreate();
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
                setIsStrictModeForDevtools(true);
                nextCreate();
                setIsStrictModeForDevtools(false);
            }
            hook.memoizedState = [
                nextValue,
                nextDeps
            ];
            return nextValue;
        }
        function mountDeferredValue(value, initialValue) {
            var hook = mountWorkInProgressHook();
            return mountDeferredValueImpl(hook, value);
        }
        function updateDeferredValue(value, initialValue) {
            var hook = updateWorkInProgressHook();
            var resolvedCurrentHook = currentHook;
            var prevValue = resolvedCurrentHook.memoizedState;
            return updateDeferredValueImpl(hook, prevValue, value);
        }
        function rerenderDeferredValue(value, initialValue) {
            var hook = updateWorkInProgressHook();
            if (currentHook === null) {
                // This is a rerender during a mount.
                return mountDeferredValueImpl(hook, value);
            } else {
                // This is a rerender during an update.
                var prevValue = currentHook.memoizedState;
                return updateDeferredValueImpl(hook, prevValue, value);
            }
        }
        function mountDeferredValueImpl(hook, value, initialValue) {
            {
                hook.memoizedState = value;
                return value;
            }
        }
        function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
            if (objectIs(value, prevValue)) {
                // The incoming value is referentially identical to the currently rendered
                // value, so we can bail out quickly.
                return value;
            } else {
                // Received a new value that's different from the current value.
                // Check if we're inside a hidden tree
                if (isCurrentTreeHidden()) {
                    // Revealing a prerendered tree is considered the same as mounting new
                    // one, so we reuse the "mount" path in this case.
                    var resultValue = mountDeferredValueImpl(hook, value); // Unlike during an actual mount, we need to mark this as an update if
                    // the value changed.
                    if (!objectIs(resultValue, prevValue)) {
                        markWorkInProgressReceivedUpdate();
                    }
                    return resultValue;
                }
                var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
                if (shouldDeferValue) {
                    // This is an urgent update. Since the value has changed, keep using the
                    // previous value and spawn a deferred render to update it later.
                    // Schedule a deferred render
                    var deferredLane = requestDeferredLane();
                    currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
                    markSkippedUpdateLanes(deferredLane); // Reuse the previous value. We do not need to mark this as an update,
                    // because we did not render a new value.
                    return prevValue;
                } else {
                    // This is not an urgent update, so we can use the latest value regardless
                    // of what it is. No need to defer it.
                    // Mark this as an update to prevent the fiber from bailing out.
                    markWorkInProgressReceivedUpdate();
                    hook.memoizedState = value;
                    return value;
                }
            }
        }
        function startTransition(fiber, queue, pendingState, finishedState, callback, options) {
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            var currentTransition = {
                _callbacks: new Set()
            };
            {
                // We don't really need to use an optimistic update here, because we
                // schedule a second "revert" update below (which we use to suspend the
                // transition until the async action scope has finished). But we'll use an
                // optimistic update anyway to make it less likely the behavior accidentally
                // diverges; for example, both an optimistic update and this one should
                // share the same lane.
                ReactCurrentBatchConfig$3.transition = currentTransition;
                dispatchOptimisticSetState(fiber, false, queue, pendingState);
            }
            {
                ReactCurrentBatchConfig$3.transition._updatedFibers = new Set();
            }
            try {
                if ("TURBOPACK compile-time truthy", 1) {
                    var returnValue = callback(); // Check if we're inside an async action scope. If so, we'll entangle
                    // this new action with the existing scope.
                    //
                    // If we're not already inside an async action scope, and this action is
                    // async, then we'll create a new async scope.
                    //
                    // In the async case, the resulting render will suspend until the async
                    // action scope has finished.
                    if (returnValue !== null && typeof returnValue === 'object' && typeof returnValue.then === 'function') {
                        var thenable = returnValue;
                        notifyTransitionCallbacks(currentTransition, thenable); // Create a thenable that resolves to `finishedState` once the async
                        // action has completed.
                        var thenableForFinishedState = chainThenableValue(thenable, finishedState);
                        dispatchSetState(fiber, queue, thenableForFinishedState);
                    } else {
                        dispatchSetState(fiber, queue, finishedState);
                    }
                }
            } catch (error) {
                {
                    // This is a trick to get the `useTransition` hook to rethrow the error.
                    // When it unwraps the thenable with the `use` algorithm, the error
                    // will be thrown.
                    var rejectedThenable = {
                        then: function() {},
                        status: 'rejected',
                        reason: error
                    };
                    dispatchSetState(fiber, queue, rejectedThenable);
                }
            } finally{
                setCurrentUpdatePriority(previousPriority);
                ReactCurrentBatchConfig$3.transition = prevTransition;
                {
                    if (prevTransition === null && currentTransition._updatedFibers) {
                        var updatedFibersCount = currentTransition._updatedFibers.size;
                        currentTransition._updatedFibers.clear();
                        if (updatedFibersCount > 10) {
                            warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');
                        }
                    }
                }
            }
        }
        function startHostTransition(formFiber, pendingState, callback, formData) {
            if (formFiber.tag !== HostComponent) {
                throw new Error('Expected the form instance to be a HostComponent. This ' + 'is a bug in React.');
            }
            var queue;
            if (formFiber.memoizedState === null) {
                // Upgrade this host component fiber to be stateful. We're going to pretend
                // it was stateful all along so we can reuse most of the implementation
                // for function components and useTransition.
                //
                // Create the state hook used by TransitionAwareHostComponent. This is
                // essentially an inlined version of mountState.
                var newQueue = {
                    pending: null,
                    lanes: NoLanes,
                    // We're going to cheat and intentionally not create a bound dispatch
                    // method, because we can call it directly in startTransition.
                    dispatch: null,
                    lastRenderedReducer: basicStateReducer,
                    lastRenderedState: NotPendingTransition
                };
                queue = newQueue;
                var stateHook = {
                    memoizedState: NotPendingTransition,
                    baseState: NotPendingTransition,
                    baseQueue: null,
                    queue: newQueue,
                    next: null
                }; // Add the state hook to both fiber alternates. The idea is that the fiber
                // had this hook all along.
                formFiber.memoizedState = stateHook;
                var alternate = formFiber.alternate;
                if (alternate !== null) {
                    alternate.memoizedState = stateHook;
                }
            } else {
                // This fiber was already upgraded to be stateful.
                var _stateHook = formFiber.memoizedState;
                queue = _stateHook.queue;
            }
            startTransition(formFiber, queue, pendingState, NotPendingTransition, // once more of this function is implemented.
            function() {
                return callback(formData);
            });
        }
        function mountTransition() {
            var stateHook = mountStateImpl(false); // The `start` method never changes.
            var start = startTransition.bind(null, currentlyRenderingFiber$1, stateHook.queue, true, false);
            var hook = mountWorkInProgressHook();
            hook.memoizedState = start;
            return [
                false,
                start
            ];
        }
        function updateTransition() {
            var _updateState = updateState(), booleanOrThenable = _updateState[0];
            var hook = updateWorkInProgressHook();
            var start = hook.memoizedState;
            var isPending = typeof booleanOrThenable === 'boolean' ? booleanOrThenable : useThenable(booleanOrThenable);
            return [
                isPending,
                start
            ];
        }
        function rerenderTransition() {
            var _rerenderState = rerenderState(), booleanOrThenable = _rerenderState[0];
            var hook = updateWorkInProgressHook();
            var start = hook.memoizedState;
            var isPending = typeof booleanOrThenable === 'boolean' ? booleanOrThenable : useThenable(booleanOrThenable);
            return [
                isPending,
                start
            ];
        }
        function useHostTransitionStatus() {
            var status = readContext(HostTransitionContext);
            return status !== null ? status : NotPendingTransition;
        }
        function mountId() {
            var hook = mountWorkInProgressHook();
            var root = getWorkInProgressRoot(); // TODO: In Fizz, id generation is specific to each server config. Maybe we
            // should do this in Fiber, too? Deferring this decision for now because
            // there's no other place to store the prefix except for an internal field on
            // the public createRoot object, which the fiber tree does not currently have
            // a reference to.
            var identifierPrefix = root.identifierPrefix;
            var id;
            if (getIsHydrating()) {
                var treeId = getTreeId(); // Use a captial R prefix for server-generated ids.
                id = ':' + identifierPrefix + 'R' + treeId; // Unless this is the first id at this level, append a number at the end
                // that represents the position of this useId hook among all the useId
                // hooks for this fiber.
                var localId = localIdCounter++;
                if (localId > 0) {
                    id += 'H' + localId.toString(32);
                }
                id += ':';
            } else {
                // Use a lowercase r prefix for client-generated ids.
                var globalClientId = globalClientIdCounter++;
                id = ':' + identifierPrefix + 'r' + globalClientId.toString(32) + ':';
            }
            hook.memoizedState = id;
            return id;
        }
        function updateId() {
            var hook = updateWorkInProgressHook();
            var id = hook.memoizedState;
            return id;
        }
        function mountRefresh() {
            var hook = mountWorkInProgressHook();
            var refresh = hook.memoizedState = refreshCache.bind(null, currentlyRenderingFiber$1);
            return refresh;
        }
        function updateRefresh() {
            var hook = updateWorkInProgressHook();
            return hook.memoizedState;
        }
        function refreshCache(fiber, seedKey, seedValue) {
            // TODO: Consider warning if the refresh is at discrete priority, or if we
            // otherwise suspect that it wasn't batched properly.
            var provider = fiber.return;
            while(provider !== null){
                switch(provider.tag){
                    case CacheComponent:
                    case HostRoot:
                        {
                            // Schedule an update on the cache boundary to trigger a refresh.
                            var lane = requestUpdateLane(provider);
                            var refreshUpdate = createUpdate(lane);
                            var root = enqueueUpdate(provider, refreshUpdate, lane);
                            if (root !== null) {
                                scheduleUpdateOnFiber(root, provider, lane);
                                entangleTransitions(root, provider, lane);
                            } // TODO: If a refresh never commits, the new cache created here must be
                            // released. A simple case is start refreshing a cache boundary, but then
                            // unmount that boundary before the refresh completes.
                            var seededCache = createCache();
                            if (seedKey !== null && seedKey !== undefined && root !== null) {
                                {
                                    {
                                        error('The seed argument is not enabled outside experimental channels.');
                                    }
                                }
                            }
                            var payload = {
                                cache: seededCache
                            };
                            refreshUpdate.payload = payload;
                            return;
                        }
                }
                provider = provider.return;
            } // TODO: Warn if unmounted?
        }
        function dispatchReducerAction(fiber, queue, action) {
            {
                if (typeof arguments[3] === 'function') {
                    error("State updates from the useState() and useReducer() Hooks don't support the " + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');
                }
            }
            var lane = requestUpdateLane(fiber);
            var update = {
                lane: lane,
                revertLane: NoLane,
                action: action,
                hasEagerState: false,
                eagerState: null,
                next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
                enqueueRenderPhaseUpdate(queue, update);
            } else {
                var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
                if (root !== null) {
                    scheduleUpdateOnFiber(root, fiber, lane);
                    entangleTransitionUpdate(root, queue, lane);
                }
            }
            markUpdateInDevTools(fiber, lane);
        }
        function dispatchSetState(fiber, queue, action) {
            {
                if (typeof arguments[3] === 'function') {
                    error("State updates from the useState() and useReducer() Hooks don't support the " + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');
                }
            }
            var lane = requestUpdateLane(fiber);
            var update = {
                lane: lane,
                revertLane: NoLane,
                action: action,
                hasEagerState: false,
                eagerState: null,
                next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
                enqueueRenderPhaseUpdate(queue, update);
            } else {
                var alternate = fiber.alternate;
                if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
                    // The queue is currently empty, which means we can eagerly compute the
                    // next state before entering the render phase. If the new state is the
                    // same as the current state, we may be able to bail out entirely.
                    var lastRenderedReducer = queue.lastRenderedReducer;
                    if (lastRenderedReducer !== null) {
                        var prevDispatcher;
                        {
                            prevDispatcher = ReactCurrentDispatcher$1.current;
                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                        }
                        try {
                            var currentState = queue.lastRenderedState;
                            var eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute
                            // it, on the update object. If the reducer hasn't changed by the
                            // time we enter the render phase, then the eager state can be used
                            // without calling the reducer again.
                            update.hasEagerState = true;
                            update.eagerState = eagerState;
                            if (objectIs(eagerState, currentState)) {
                                // Fast path. We can bail out without scheduling React to re-render.
                                // It's still possible that we'll need to rebase this update later,
                                // if the component re-renders for a different reason and by that
                                // time the reducer has changed.
                                // TODO: Do we still need to entangle transitions in this case?
                                enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);
                                return;
                            }
                        } catch (error) {} finally{
                            {
                                ReactCurrentDispatcher$1.current = prevDispatcher;
                            }
                        }
                    }
                }
                var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
                if (root !== null) {
                    scheduleUpdateOnFiber(root, fiber, lane);
                    entangleTransitionUpdate(root, queue, lane);
                }
            }
            markUpdateInDevTools(fiber, lane);
        }
        function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
            var transition = requestCurrentTransition();
            {
                if (transition === null) {
                    // An optimistic update occurred, but startTransition is not on the stack.
                    // There are two likely scenarios.
                    // One possibility is that the optimistic update is triggered by a regular
                    // event handler (e.g. `onSubmit`) instead of an action. This is a mistake
                    // and we will warn.
                    // The other possibility is the optimistic update is inside an async
                    // action, but after an `await`. In this case, we can make it "just work"
                    // by associating the optimistic update with the pending async action.
                    // Technically it's possible that the optimistic update is unrelated to
                    // the pending action, but we don't have a way of knowing this for sure
                    // because browsers currently do not provide a way to track async scope.
                    // (The AsyncContext proposal, if it lands, will solve this in the
                    // future.) However, this is no different than the problem of unrelated
                    // transitions being grouped together — it's not wrong per se, but it's
                    // not ideal.
                    // Once AsyncContext starts landing in browsers, we will provide better
                    // warnings in development for these cases.
                    if (peekEntangledActionLane() !== NoLane) ;
                    else {
                        // There's no pending async action. The most likely cause is that we're
                        // inside a regular event handler (e.g. onSubmit) instead of an action.
                        error('An optimistic state update occurred outside a transition or ' + 'action. To fix, move the update to an action, or wrap ' + 'with startTransition.');
                    }
                }
            }
            var update = {
                // An optimistic update commits synchronously.
                lane: SyncLane,
                // After committing, the optimistic update is "reverted" using the same
                // lane as the transition it's associated with.
                revertLane: requestTransitionLane(),
                action: action,
                hasEagerState: false,
                eagerState: null,
                next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
                // When calling startTransition during render, this warns instead of
                // throwing because throwing would be a breaking change. setOptimisticState
                // is a new API so it's OK to throw.
                if (throwIfDuringRender) {
                    throw new Error('Cannot update optimistic state while rendering.');
                } else {
                    // startTransition was called during render. We don't need to do anything
                    // besides warn here because the render phase update would be overidden by
                    // the second update, anyway. We can remove this branch and make it throw
                    // in a future release.
                    {
                        error('Cannot call startTransition while rendering.');
                    }
                }
            } else {
                var root = enqueueConcurrentHookUpdate(fiber, queue, update, SyncLane);
                if (root !== null) {
                    // NOTE: The optimistic update implementation assumes that the transition
                    // will never be attempted before the optimistic update. This currently
                    // holds because the optimistic update is always synchronous. If we ever
                    // change that, we'll need to account for this.
                    scheduleUpdateOnFiber(root, fiber, SyncLane); // Optimistic updates are always synchronous, so we don't need to call
                // entangleTransitionUpdate here.
                }
            }
            markUpdateInDevTools(fiber, SyncLane);
        }
        function isRenderPhaseUpdate(fiber) {
            var alternate = fiber.alternate;
            return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
        }
        function enqueueRenderPhaseUpdate(queue, update) {
            // This is a render phase update. Stash it in a lazily-created map of
            // queue -> linked list of updates. After this render pass, we'll restart
            // and apply the stashed updates on top of the work-in-progress hook.
            didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
            var pending = queue.pending;
            if (pending === null) {
                // This is the first update. Create a circular list.
                update.next = update;
            } else {
                update.next = pending.next;
                pending.next = update;
            }
            queue.pending = update;
        } // TODO: Move to ReactFiberConcurrentUpdates?
        function entangleTransitionUpdate(root, queue, lane) {
            if (isTransitionLane(lane)) {
                var queueLanes = queue.lanes; // If any entangled lanes are no longer pending on the root, then they
                // must have finished. We can remove them from the shared queue, which
                // represents a superset of the actually pending lanes. In some cases we
                // may entangle more than we need to, but that's OK. In fact it's worse if
                // we *don't* entangle when we should.
                queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.
                var newQueueLanes = mergeLanes(queueLanes, lane);
                queue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if
                // the lane finished since the last time we entangled it. So we need to
                // entangle it again, just to be sure.
                markRootEntangled(root, newQueueLanes);
            }
        }
        function markUpdateInDevTools(fiber, lane, action) {
            {
                markStateUpdateScheduled(fiber, lane);
            }
        }
        var ContextOnlyDispatcher = {
            readContext: readContext,
            use: use,
            useCallback: throwInvalidHookError,
            useContext: throwInvalidHookError,
            useEffect: throwInvalidHookError,
            useImperativeHandle: throwInvalidHookError,
            useInsertionEffect: throwInvalidHookError,
            useLayoutEffect: throwInvalidHookError,
            useMemo: throwInvalidHookError,
            useReducer: throwInvalidHookError,
            useRef: throwInvalidHookError,
            useState: throwInvalidHookError,
            useDebugValue: throwInvalidHookError,
            useDeferredValue: throwInvalidHookError,
            useTransition: throwInvalidHookError,
            useSyncExternalStore: throwInvalidHookError,
            useId: throwInvalidHookError
        };
        {
            ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;
        }
        {
            ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;
            ContextOnlyDispatcher.useFormState = throwInvalidHookError;
        }
        {
            ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;
        }
        var HooksDispatcherOnMountInDEV = null;
        var HooksDispatcherOnMountWithHookTypesInDEV = null;
        var HooksDispatcherOnUpdateInDEV = null;
        var HooksDispatcherOnRerenderInDEV = null;
        var InvalidNestedHooksDispatcherOnMountInDEV = null;
        var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
        var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
        {
            var warnInvalidContextAccess = function() {
                error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
            };
            var warnInvalidHookAccess = function() {
                error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://reactjs.org/link/rules-of-hooks');
            };
            HooksDispatcherOnMountInDEV = {
                readContext: function(context) {
                    return readContext(context);
                },
                use: use,
                useCallback: function(callback, deps) {
                    currentHookNameInDev = 'useCallback';
                    mountHookTypesDev();
                    checkDepsAreArrayDev(deps);
                    return mountCallback(callback, deps);
                },
                useContext: function(context) {
                    currentHookNameInDev = 'useContext';
                    mountHookTypesDev();
                    return readContext(context);
                },
                useEffect: function(create, deps) {
                    currentHookNameInDev = 'useEffect';
                    mountHookTypesDev();
                    checkDepsAreArrayDev(deps);
                    return mountEffect(create, deps);
                },
                useImperativeHandle: function(ref, create, deps) {
                    currentHookNameInDev = 'useImperativeHandle';
                    mountHookTypesDev();
                    checkDepsAreArrayDev(deps);
                    return mountImperativeHandle(ref, create, deps);
                },
                useInsertionEffect: function(create, deps) {
                    currentHookNameInDev = 'useInsertionEffect';
                    mountHookTypesDev();
                    checkDepsAreArrayDev(deps);
                    return mountInsertionEffect(create, deps);
                },
                useLayoutEffect: function(create, deps) {
                    currentHookNameInDev = 'useLayoutEffect';
                    mountHookTypesDev();
                    checkDepsAreArrayDev(deps);
                    return mountLayoutEffect(create, deps);
                },
                useMemo: function(create, deps) {
                    currentHookNameInDev = 'useMemo';
                    mountHookTypesDev();
                    checkDepsAreArrayDev(deps);
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                    try {
                        return mountMemo(create, deps);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useReducer: function(reducer, initialArg, init) {
                    currentHookNameInDev = 'useReducer';
                    mountHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                    try {
                        return mountReducer(reducer, initialArg, init);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useRef: function(initialValue) {
                    currentHookNameInDev = 'useRef';
                    mountHookTypesDev();
                    return mountRef(initialValue);
                },
                useState: function(initialState) {
                    currentHookNameInDev = 'useState';
                    mountHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                    try {
                        return mountState(initialState);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useDebugValue: function(value, formatterFn) {
                    currentHookNameInDev = 'useDebugValue';
                    mountHookTypesDev();
                    return mountDebugValue();
                },
                useDeferredValue: function(value, initialValue) {
                    currentHookNameInDev = 'useDeferredValue';
                    mountHookTypesDev();
                    return mountDeferredValue(value);
                },
                useTransition: function() {
                    currentHookNameInDev = 'useTransition';
                    mountHookTypesDev();
                    return mountTransition();
                },
                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                    currentHookNameInDev = 'useSyncExternalStore';
                    mountHookTypesDev();
                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
                },
                useId: function() {
                    currentHookNameInDev = 'useId';
                    mountHookTypesDev();
                    return mountId();
                }
            };
            {
                HooksDispatcherOnMountInDEV.useCacheRefresh = function useCacheRefresh() {
                    currentHookNameInDev = 'useCacheRefresh';
                    mountHookTypesDev();
                    return mountRefresh();
                };
            }
            {
                HooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;
                HooksDispatcherOnMountInDEV.useFormState = function useFormState(action, initialState, permalink) {
                    currentHookNameInDev = 'useFormState';
                    mountHookTypesDev();
                    return mountFormState(action, initialState);
                };
            }
            {
                HooksDispatcherOnMountInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {
                    currentHookNameInDev = 'useOptimistic';
                    mountHookTypesDev();
                    return mountOptimistic(passthrough);
                };
            }
            HooksDispatcherOnMountWithHookTypesInDEV = {
                readContext: function(context) {
                    return readContext(context);
                },
                use: use,
                useCallback: function(callback, deps) {
                    currentHookNameInDev = 'useCallback';
                    updateHookTypesDev();
                    return mountCallback(callback, deps);
                },
                useContext: function(context) {
                    currentHookNameInDev = 'useContext';
                    updateHookTypesDev();
                    return readContext(context);
                },
                useEffect: function(create, deps) {
                    currentHookNameInDev = 'useEffect';
                    updateHookTypesDev();
                    return mountEffect(create, deps);
                },
                useImperativeHandle: function(ref, create, deps) {
                    currentHookNameInDev = 'useImperativeHandle';
                    updateHookTypesDev();
                    return mountImperativeHandle(ref, create, deps);
                },
                useInsertionEffect: function(create, deps) {
                    currentHookNameInDev = 'useInsertionEffect';
                    updateHookTypesDev();
                    return mountInsertionEffect(create, deps);
                },
                useLayoutEffect: function(create, deps) {
                    currentHookNameInDev = 'useLayoutEffect';
                    updateHookTypesDev();
                    return mountLayoutEffect(create, deps);
                },
                useMemo: function(create, deps) {
                    currentHookNameInDev = 'useMemo';
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                    try {
                        return mountMemo(create, deps);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useReducer: function(reducer, initialArg, init) {
                    currentHookNameInDev = 'useReducer';
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                    try {
                        return mountReducer(reducer, initialArg, init);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useRef: function(initialValue) {
                    currentHookNameInDev = 'useRef';
                    updateHookTypesDev();
                    return mountRef(initialValue);
                },
                useState: function(initialState) {
                    currentHookNameInDev = 'useState';
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                    try {
                        return mountState(initialState);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useDebugValue: function(value, formatterFn) {
                    currentHookNameInDev = 'useDebugValue';
                    updateHookTypesDev();
                    return mountDebugValue();
                },
                useDeferredValue: function(value, initialValue) {
                    currentHookNameInDev = 'useDeferredValue';
                    updateHookTypesDev();
                    return mountDeferredValue(value);
                },
                useTransition: function() {
                    currentHookNameInDev = 'useTransition';
                    updateHookTypesDev();
                    return mountTransition();
                },
                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                    currentHookNameInDev = 'useSyncExternalStore';
                    updateHookTypesDev();
                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
                },
                useId: function() {
                    currentHookNameInDev = 'useId';
                    updateHookTypesDev();
                    return mountId();
                }
            };
            {
                HooksDispatcherOnMountWithHookTypesInDEV.useCacheRefresh = function useCacheRefresh() {
                    currentHookNameInDev = 'useCacheRefresh';
                    updateHookTypesDev();
                    return mountRefresh();
                };
            }
            {
                HooksDispatcherOnMountWithHookTypesInDEV.useHostTransitionStatus = useHostTransitionStatus;
                HooksDispatcherOnMountWithHookTypesInDEV.useFormState = function useFormState(action, initialState, permalink) {
                    currentHookNameInDev = 'useFormState';
                    updateHookTypesDev();
                    return mountFormState(action, initialState);
                };
            }
            {
                HooksDispatcherOnMountWithHookTypesInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {
                    currentHookNameInDev = 'useOptimistic';
                    updateHookTypesDev();
                    return mountOptimistic(passthrough);
                };
            }
            HooksDispatcherOnUpdateInDEV = {
                readContext: function(context) {
                    return readContext(context);
                },
                use: use,
                useCallback: function(callback, deps) {
                    currentHookNameInDev = 'useCallback';
                    updateHookTypesDev();
                    return updateCallback(callback, deps);
                },
                useContext: function(context) {
                    currentHookNameInDev = 'useContext';
                    updateHookTypesDev();
                    return readContext(context);
                },
                useEffect: function(create, deps) {
                    currentHookNameInDev = 'useEffect';
                    updateHookTypesDev();
                    return updateEffect(create, deps);
                },
                useImperativeHandle: function(ref, create, deps) {
                    currentHookNameInDev = 'useImperativeHandle';
                    updateHookTypesDev();
                    return updateImperativeHandle(ref, create, deps);
                },
                useInsertionEffect: function(create, deps) {
                    currentHookNameInDev = 'useInsertionEffect';
                    updateHookTypesDev();
                    return updateInsertionEffect(create, deps);
                },
                useLayoutEffect: function(create, deps) {
                    currentHookNameInDev = 'useLayoutEffect';
                    updateHookTypesDev();
                    return updateLayoutEffect(create, deps);
                },
                useMemo: function(create, deps) {
                    currentHookNameInDev = 'useMemo';
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                    try {
                        return updateMemo(create, deps);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useReducer: function(reducer, initialArg, init) {
                    currentHookNameInDev = 'useReducer';
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                    try {
                        return updateReducer(reducer, initialArg, init);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useRef: function(initialValue) {
                    currentHookNameInDev = 'useRef';
                    updateHookTypesDev();
                    return updateRef();
                },
                useState: function(initialState) {
                    currentHookNameInDev = 'useState';
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                    try {
                        return updateState(initialState);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useDebugValue: function(value, formatterFn) {
                    currentHookNameInDev = 'useDebugValue';
                    updateHookTypesDev();
                    return updateDebugValue();
                },
                useDeferredValue: function(value, initialValue) {
                    currentHookNameInDev = 'useDeferredValue';
                    updateHookTypesDev();
                    return updateDeferredValue(value);
                },
                useTransition: function() {
                    currentHookNameInDev = 'useTransition';
                    updateHookTypesDev();
                    return updateTransition();
                },
                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                    currentHookNameInDev = 'useSyncExternalStore';
                    updateHookTypesDev();
                    return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
                },
                useId: function() {
                    currentHookNameInDev = 'useId';
                    updateHookTypesDev();
                    return updateId();
                }
            };
            {
                HooksDispatcherOnUpdateInDEV.useCacheRefresh = function useCacheRefresh() {
                    currentHookNameInDev = 'useCacheRefresh';
                    updateHookTypesDev();
                    return updateRefresh();
                };
            }
            {
                HooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;
                HooksDispatcherOnUpdateInDEV.useFormState = function useFormState(action, initialState, permalink) {
                    currentHookNameInDev = 'useFormState';
                    updateHookTypesDev();
                    return updateFormState(action);
                };
            }
            {
                HooksDispatcherOnUpdateInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {
                    currentHookNameInDev = 'useOptimistic';
                    updateHookTypesDev();
                    return updateOptimistic(passthrough, reducer);
                };
            }
            HooksDispatcherOnRerenderInDEV = {
                readContext: function(context) {
                    return readContext(context);
                },
                use: use,
                useCallback: function(callback, deps) {
                    currentHookNameInDev = 'useCallback';
                    updateHookTypesDev();
                    return updateCallback(callback, deps);
                },
                useContext: function(context) {
                    currentHookNameInDev = 'useContext';
                    updateHookTypesDev();
                    return readContext(context);
                },
                useEffect: function(create, deps) {
                    currentHookNameInDev = 'useEffect';
                    updateHookTypesDev();
                    return updateEffect(create, deps);
                },
                useImperativeHandle: function(ref, create, deps) {
                    currentHookNameInDev = 'useImperativeHandle';
                    updateHookTypesDev();
                    return updateImperativeHandle(ref, create, deps);
                },
                useInsertionEffect: function(create, deps) {
                    currentHookNameInDev = 'useInsertionEffect';
                    updateHookTypesDev();
                    return updateInsertionEffect(create, deps);
                },
                useLayoutEffect: function(create, deps) {
                    currentHookNameInDev = 'useLayoutEffect';
                    updateHookTypesDev();
                    return updateLayoutEffect(create, deps);
                },
                useMemo: function(create, deps) {
                    currentHookNameInDev = 'useMemo';
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                    try {
                        return updateMemo(create, deps);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useReducer: function(reducer, initialArg, init) {
                    currentHookNameInDev = 'useReducer';
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                    try {
                        return rerenderReducer(reducer, initialArg, init);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useRef: function(initialValue) {
                    currentHookNameInDev = 'useRef';
                    updateHookTypesDev();
                    return updateRef();
                },
                useState: function(initialState) {
                    currentHookNameInDev = 'useState';
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                    try {
                        return rerenderState(initialState);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useDebugValue: function(value, formatterFn) {
                    currentHookNameInDev = 'useDebugValue';
                    updateHookTypesDev();
                    return updateDebugValue();
                },
                useDeferredValue: function(value, initialValue) {
                    currentHookNameInDev = 'useDeferredValue';
                    updateHookTypesDev();
                    return rerenderDeferredValue(value);
                },
                useTransition: function() {
                    currentHookNameInDev = 'useTransition';
                    updateHookTypesDev();
                    return rerenderTransition();
                },
                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                    currentHookNameInDev = 'useSyncExternalStore';
                    updateHookTypesDev();
                    return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
                },
                useId: function() {
                    currentHookNameInDev = 'useId';
                    updateHookTypesDev();
                    return updateId();
                }
            };
            {
                HooksDispatcherOnRerenderInDEV.useCacheRefresh = function useCacheRefresh() {
                    currentHookNameInDev = 'useCacheRefresh';
                    updateHookTypesDev();
                    return updateRefresh();
                };
            }
            {
                HooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;
                HooksDispatcherOnRerenderInDEV.useFormState = function useFormState(action, initialState, permalink) {
                    currentHookNameInDev = 'useFormState';
                    updateHookTypesDev();
                    return rerenderFormState(action);
                };
            }
            {
                HooksDispatcherOnRerenderInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {
                    currentHookNameInDev = 'useOptimistic';
                    updateHookTypesDev();
                    return rerenderOptimistic(passthrough, reducer);
                };
            }
            InvalidNestedHooksDispatcherOnMountInDEV = {
                readContext: function(context) {
                    warnInvalidContextAccess();
                    return readContext(context);
                },
                use: function(usable) {
                    warnInvalidHookAccess();
                    return use(usable);
                },
                useCallback: function(callback, deps) {
                    currentHookNameInDev = 'useCallback';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountCallback(callback, deps);
                },
                useContext: function(context) {
                    currentHookNameInDev = 'useContext';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return readContext(context);
                },
                useEffect: function(create, deps) {
                    currentHookNameInDev = 'useEffect';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountEffect(create, deps);
                },
                useImperativeHandle: function(ref, create, deps) {
                    currentHookNameInDev = 'useImperativeHandle';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountImperativeHandle(ref, create, deps);
                },
                useInsertionEffect: function(create, deps) {
                    currentHookNameInDev = 'useInsertionEffect';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountInsertionEffect(create, deps);
                },
                useLayoutEffect: function(create, deps) {
                    currentHookNameInDev = 'useLayoutEffect';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountLayoutEffect(create, deps);
                },
                useMemo: function(create, deps) {
                    currentHookNameInDev = 'useMemo';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                    try {
                        return mountMemo(create, deps);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useReducer: function(reducer, initialArg, init) {
                    currentHookNameInDev = 'useReducer';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                    try {
                        return mountReducer(reducer, initialArg, init);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useRef: function(initialValue) {
                    currentHookNameInDev = 'useRef';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountRef(initialValue);
                },
                useState: function(initialState) {
                    currentHookNameInDev = 'useState';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                    try {
                        return mountState(initialState);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useDebugValue: function(value, formatterFn) {
                    currentHookNameInDev = 'useDebugValue';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountDebugValue();
                },
                useDeferredValue: function(value, initialValue) {
                    currentHookNameInDev = 'useDeferredValue';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountDeferredValue(value);
                },
                useTransition: function() {
                    currentHookNameInDev = 'useTransition';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountTransition();
                },
                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                    currentHookNameInDev = 'useSyncExternalStore';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
                },
                useId: function() {
                    currentHookNameInDev = 'useId';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountId();
                }
            };
            {
                InvalidNestedHooksDispatcherOnMountInDEV.useCacheRefresh = function useCacheRefresh() {
                    currentHookNameInDev = 'useCacheRefresh';
                    mountHookTypesDev();
                    return mountRefresh();
                };
            }
            {
                InvalidNestedHooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;
                InvalidNestedHooksDispatcherOnMountInDEV.useFormState = function useFormState(action, initialState, permalink) {
                    currentHookNameInDev = 'useFormState';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountFormState(action, initialState);
                };
            }
            {
                InvalidNestedHooksDispatcherOnMountInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {
                    currentHookNameInDev = 'useOptimistic';
                    warnInvalidHookAccess();
                    mountHookTypesDev();
                    return mountOptimistic(passthrough);
                };
            }
            InvalidNestedHooksDispatcherOnUpdateInDEV = {
                readContext: function(context) {
                    warnInvalidContextAccess();
                    return readContext(context);
                },
                use: function(usable) {
                    warnInvalidHookAccess();
                    return use(usable);
                },
                useCallback: function(callback, deps) {
                    currentHookNameInDev = 'useCallback';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateCallback(callback, deps);
                },
                useContext: function(context) {
                    currentHookNameInDev = 'useContext';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return readContext(context);
                },
                useEffect: function(create, deps) {
                    currentHookNameInDev = 'useEffect';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateEffect(create, deps);
                },
                useImperativeHandle: function(ref, create, deps) {
                    currentHookNameInDev = 'useImperativeHandle';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateImperativeHandle(ref, create, deps);
                },
                useInsertionEffect: function(create, deps) {
                    currentHookNameInDev = 'useInsertionEffect';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateInsertionEffect(create, deps);
                },
                useLayoutEffect: function(create, deps) {
                    currentHookNameInDev = 'useLayoutEffect';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateLayoutEffect(create, deps);
                },
                useMemo: function(create, deps) {
                    currentHookNameInDev = 'useMemo';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                    try {
                        return updateMemo(create, deps);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useReducer: function(reducer, initialArg, init) {
                    currentHookNameInDev = 'useReducer';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                    try {
                        return updateReducer(reducer, initialArg, init);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useRef: function(initialValue) {
                    currentHookNameInDev = 'useRef';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateRef();
                },
                useState: function(initialState) {
                    currentHookNameInDev = 'useState';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                    try {
                        return updateState(initialState);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useDebugValue: function(value, formatterFn) {
                    currentHookNameInDev = 'useDebugValue';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateDebugValue();
                },
                useDeferredValue: function(value, initialValue) {
                    currentHookNameInDev = 'useDeferredValue';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateDeferredValue(value);
                },
                useTransition: function() {
                    currentHookNameInDev = 'useTransition';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateTransition();
                },
                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                    currentHookNameInDev = 'useSyncExternalStore';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
                },
                useId: function() {
                    currentHookNameInDev = 'useId';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateId();
                }
            };
            {
                InvalidNestedHooksDispatcherOnUpdateInDEV.useCacheRefresh = function useCacheRefresh() {
                    currentHookNameInDev = 'useCacheRefresh';
                    updateHookTypesDev();
                    return updateRefresh();
                };
            }
            {
                InvalidNestedHooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;
                InvalidNestedHooksDispatcherOnUpdateInDEV.useFormState = function useFormState(action, initialState, permalink) {
                    currentHookNameInDev = 'useFormState';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateFormState(action);
                };
            }
            {
                InvalidNestedHooksDispatcherOnUpdateInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {
                    currentHookNameInDev = 'useOptimistic';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateOptimistic(passthrough, reducer);
                };
            }
            InvalidNestedHooksDispatcherOnRerenderInDEV = {
                readContext: function(context) {
                    warnInvalidContextAccess();
                    return readContext(context);
                },
                use: function(usable) {
                    warnInvalidHookAccess();
                    return use(usable);
                },
                useCallback: function(callback, deps) {
                    currentHookNameInDev = 'useCallback';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateCallback(callback, deps);
                },
                useContext: function(context) {
                    currentHookNameInDev = 'useContext';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return readContext(context);
                },
                useEffect: function(create, deps) {
                    currentHookNameInDev = 'useEffect';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateEffect(create, deps);
                },
                useImperativeHandle: function(ref, create, deps) {
                    currentHookNameInDev = 'useImperativeHandle';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateImperativeHandle(ref, create, deps);
                },
                useInsertionEffect: function(create, deps) {
                    currentHookNameInDev = 'useInsertionEffect';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateInsertionEffect(create, deps);
                },
                useLayoutEffect: function(create, deps) {
                    currentHookNameInDev = 'useLayoutEffect';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateLayoutEffect(create, deps);
                },
                useMemo: function(create, deps) {
                    currentHookNameInDev = 'useMemo';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                    try {
                        return updateMemo(create, deps);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useReducer: function(reducer, initialArg, init) {
                    currentHookNameInDev = 'useReducer';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                    try {
                        return rerenderReducer(reducer, initialArg, init);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useRef: function(initialValue) {
                    currentHookNameInDev = 'useRef';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateRef();
                },
                useState: function(initialState) {
                    currentHookNameInDev = 'useState';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    var prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                    try {
                        return rerenderState(initialState);
                    } finally{
                        ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                },
                useDebugValue: function(value, formatterFn) {
                    currentHookNameInDev = 'useDebugValue';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateDebugValue();
                },
                useDeferredValue: function(value, initialValue) {
                    currentHookNameInDev = 'useDeferredValue';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return rerenderDeferredValue(value);
                },
                useTransition: function() {
                    currentHookNameInDev = 'useTransition';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return rerenderTransition();
                },
                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                    currentHookNameInDev = 'useSyncExternalStore';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
                },
                useId: function() {
                    currentHookNameInDev = 'useId';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return updateId();
                }
            };
            {
                InvalidNestedHooksDispatcherOnRerenderInDEV.useCacheRefresh = function useCacheRefresh() {
                    currentHookNameInDev = 'useCacheRefresh';
                    updateHookTypesDev();
                    return updateRefresh();
                };
            }
            {
                InvalidNestedHooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;
                InvalidNestedHooksDispatcherOnRerenderInDEV.useFormState = function useFormState(action, initialState, permalink) {
                    currentHookNameInDev = 'useFormState';
                    warnInvalidHookAccess();
                    updateHookTypesDev();
                    return rerenderFormState(action);
                };
            }
            {
           